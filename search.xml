<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android Unit Test 框架比较</title>
    <url>/2017/07/04/Android-unit-test-lib-compare/</url>
    <content><![CDATA[<p>这篇文章列举了现有常见的 Android 单元测试框架，并进行了简单的比较，方便用来进行框架的选型和收藏（毕竟只要收藏了本文，就相当于收藏了各大单元测试框架的主页，是不是很棒棒？）。</p>
<blockquote>
<p>框架对比的部分会带有一定的偏向性，不过光是把本文当做一个单元测试的工具箱也是蛮顺手的。</p>
</blockquote>
<span id="more"></span>
<h2 id="Java-Tests">Java Tests</h2>
<h3 id="JUnit">JUnit</h3>
<blockquote>
<p><a href="http://junit.org/junit4/">JUnit</a> 是基于 xUnit 架构实现的单元测试框架。雏形是1998年在 SmallTalk 上实现的 SUnit，后来原作者将它迁移到 Java 上，从此声名大噪。</p>
</blockquote>
<p>JUnit 在 Android 官网上出现的频率相当高，是 Android 单元测试的基础框架之一，后面提到的 mock 框架都相当于是在丰富这些基础框架的功能。<br>
要做单元测试的开发者们通常都会在 JUnit 和 TestNG 之间选择一个，个人感觉还是选 JUnit 好一些。（理由在 TestNG 的介绍中）</p>
<h3 id="TestNG">TestNG</h3>
<blockquote>
<p><a href="http://testng.org/doc/index.html">TestNG</a>  是一名软件工程师（Cédric Beust）对 JUnit 的改进，他将对 JUnit 的不满写在了 <a href="http://beust.com/weblog/2004/02/08/junit-pain/">这里</a> 和 <a href="http://beust.com/weblog/2004/08/25/testsetup-and-evil-static-methods/">这里</a>，感兴趣的可以去看看。</p>
</blockquote>
<p>TestNG 对 JUnit 的改进主要在两个方面：</p>
<ol>
<li>在 JUnit 中，同一个测试类中的不同测试方法是相互独立的，也就是说，每个测试方法开始前都会执行一次测试类的构造方法，这就让测试方法之间共享某些状态变得不可能</li>
<li>后来 JUnit 对问题1给出了解决方案—— <code>TestSetup</code>，但是它必须通过静态方法去使用（JUnit 的 <code>TestSetup</code> 因为年代久远，已经没有文档了，估计 JUnit 也觉得这个解决方案不妥，赶紧修复了吧）</li>
</ol>
<p>事实上，TestNG 要改进的问题在新版本的 JUnit 上已经不是问题了（毕竟那次抱怨都发自2004年）。从官网最后一次更新是2015年12月来看，TestNG 社区的活跃程度远不如它的改进对象 JUnit，所以还是乖乖滚回 JUnit 的怀抱好了。</p>
<h3 id="Mockito">Mockito</h3>
<blockquote>
<p><a href="http://site.mockito.org/">Mockito</a> 最初是在 <a href="http://easymock.org/">EasyMock</a> 的基础上实现的，持续更新到现在，而始祖 EasyMock 已经在2015年停更了。</p>
</blockquote>
<p>Mockito 的优势正如它官网说的：</p>
<ul>
<li>测试代码和验证提示的良好可读性</li>
<li>良好的社区支持</li>
<li>Java 世界中排名能到达前十的明星框架</li>
<li><a href="https://github.com/mockito/mockito/wiki/Features-And-Motivations">Features And Motivations</a></li>
</ul>
<p>但劣势也同样明显，其实不应该叫做“劣势”，而应该说是因为实现方式所带来的“限制”：<a href="https://github.com/mockito/mockito/wiki/FAQ#what-are-the-limitations-of-mockito">What are the limitations of Mockito</a><br>
不过这些限制也因为 PowerMock 的出现而被化解，所以搭配上 PowerMock 之后，Java 单元测试这边几乎所向披靡。</p>
<h3 id="jMock">jMock</h3>
<blockquote>
<p><a href="http://www.jmock.org/">jMock</a> 是一款爷爷级的 mock 框架。</p>
</blockquote>
<p>在2008年底就已经更新到 2.6.0-RC1 版了，结果在2012年底发布 2.6.0-released 版本之后就再也没有了消息，花费4年打磨了一个版本，估计作者是气死了吧。</p>
<h3 id="PowerMock">PowerMock</h3>
<blockquote>
<p><a href="https://github.com/powermock/powermock">PowerMock</a> 的出现是为了弥补常规 mock 框架的限制问题。Mockito 与 PowerMock 合作紧密，但毕竟不是一伙人，所以后者的大版本更新往往会落后前者一点。</p>
</blockquote>
<p>它绕开了 CGLib，直接修改类的字节码，以实现 mock 某个类的目的。这种风骚的操作让 PowerMock 能够做到上面提到的框架做不到的事情：修改静态或私有方法等等。<br>
然而，它把自己定位为高层次框架的插件，所以用它的时候就不可避免要带上其他的框架（在 gradle 里引入 PowerMock 的时候会自动引入相关框架的依赖）。如果已经使用了 Mockito 之流，那在后期引入 PowerMock 的时候必须让二者的版本相对应，或者抛弃原来的 Mockito，直接使用 PowerMock 依赖的版本。</p>
<h3 id="JMockit">JMockit</h3>
<blockquote>
<p><a href="http://jmockit.org/index.html">JMockit</a> 从2014年提交第一个 commit，到现在已经迭代了将近3年的时间。虽然从 Github 上面看它的社区并不太活跃，但是却保持着良好的更新频率，现在还在持续更新着。</p>
</blockquote>
<p>研究 Android 单元测试好几天了才看到这个框架，真是惭愧。<br>
它相当于一个非插件化的 PowerMock，集成和使用的方式都非常简单。语法上虽然不及 <code>when/thenReturn</code> 这样口语化，但也是一目了然。<br>
所以，一个 JMockit 能搞定的事情，为什么要用 Mockito&amp;PowerMock 组合呢？</p>
<p>关于这类修改字节码的框架是如何实现的，可以看这篇文章：<br>
<a href="https://segmentfault.com/a/1190000003718149">浅谈jmockit中mock机制的实现</a></p>
<h2 id="Android-Test">Android Test</h2>
<h3 id="Robolectric">Robolectric</h3>
<blockquote>
<p><a href="http://robolectric.org/">Robolectric</a> 重写了许多 Android SDK 里的类，使得在 JVM 上进行 Android 测试成为了可能。</p>
</blockquote>
<p>按照<a href="http://robolectric.org/extending/">文档</a>中的描述，Shadow class 是用来修改和扩充 Android OS 下的类的行为的，除了可以 shadow 构造方法外，它和 Mockito 的 mock 没有太大区别，所以它并不能作为 Mockito 的扩充来使用。</p>
<p>官网的介绍中也提及了 Mockito，按照它的说法，我们完全可以用 Mockito 来实现 Robolectric 的功能，只不过要我们自己将 Android SDK 和一些 native 方法一个个 mock 掉而已。这部分工作正是 Robolectric 的价值所在。</p>
<h3 id="Espresso-UI-Automator">Espresso &amp; UI Automator</h3>
<blockquote>
<p><a href="https://developer.android.com/topic/libraries/testing-support-library/index.html#Espresso">Espresso</a> &amp; <a href="https://developer.android.com/topic/libraries/testing-support-library/index.html#UIAutomator">UI Automator</a> 这两兄弟都是 Google 官方推荐的 UI 测试框架，其中前者更适合于白盒测试，后者更适合黑盒测试。</p>
</blockquote>
<p>根据官方的说法，它们还是有一些区别的：<br>
Espresso：适合应用中的功能性 UI 测试<br>
UI Automator：适合跨系统和已安装应用的跨应用功能性 UI 测试</p>
<p>但因为目前还没有涉及到这一块的测试，没有深入研究，所以推荐大家还是去官网看看比较好。</p>
<h2 id="Others">Others</h2>
<h3 id="Hamcrest">Hamcrest</h3>
<blockquote>
<p><a href="https://github.com/hamcrest">Hamcrest</a> 是一个提供更灵活的 Assertion 的 API 的第三方库</p>
</blockquote>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"8225264e14e677544541","clientSecret":"ed2a2c6d5043e9f0b41cae78b0d5b4571099de53","repo":"HexoBlogSource","owner":"davidleee","admin":["davidleee"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>Android</tag>
        <tag>单元测试</tag>
        <tag>JUnit</tag>
        <tag>Mock</tag>
      </tags>
  </entry>
  <entry>
    <title>Gesture Recognizers for iOS - The Basic</title>
    <url>/2017/03/28/Basic-Gesture-Recognizers/</url>
    <content><![CDATA[<blockquote>
<p>Your app should respond to gestures only in ways that users expect.</p>
</blockquote>
<p>既然苹果已经将培养用户习惯的事情给做了，那么除非必要，开发的过程中还是尽量使用苹果自带的手势识别比较好。用文档的话来说，好处有这些：</p>
<ul>
<li>简化代码数量</li>
<li>确保应用行为与用户期望的行为一致</li>
</ul>
<span id="more"></span>
<p>那就先来看点基础的。</p>
<h2 id="基础知识">基础知识</h2>
<h3 id="Gesture-Recognizers与View的关系">Gesture Recognizers与View的关系</h3>
<p>一个手势识别器只能对应一个 view，但是反过来，一个 view可以对应多个手势识别器，因此一个 view 可以根据不同的手势作出不同的响应。<br>
当 recognizer 连接到 view 上去之后，recognizer 会比 view 本身更早的接收到用户触摸事件，所以它也会代替 view 去对这些事件进行响应。</p>
<h3 id="分离与连续">分离与连续</h3>
<p>系统给出的默认手势处理可以分为两类：<strong>分离式</strong>和<strong>连续式</strong>。</p>
<p>分离式手势，比如说点击，每次用户操作一次，只会发来一个消息；而连续式手势，比如缩放，在用户操作的过程中，会不断地发消息过来，直到这个手势结束。<br>
借用文档里的一张图，这两个过程长这个样子：</p>
<img src="/uploads/Basic-Gesture-Recognizers/discrete_vs_continuous_2x.png" class="center" title="Discrete vs Continuous">
<h3 id="事件响应">事件响应</h3>
<p>将手势识别器与视图关联起来有两种途径：</p>
<ol>
<li>通过 IB 连线</li>
<li>代码添加</li>
</ol>
<p>事件的接收和处理都比较简单直接，可以参考官方的实例项目：<a href="https://developer.apple.com/library/ios/samplecode/SimpleGestureRecognizers/Introduction/Intro.html#//apple_ref/doc/uid/DTS40009460">Simple Gesture Recognizers</a></p>
<h2 id="复杂一些的情况">复杂一些的情况</h2>
<h3 id="有限状态机">有限状态机</h3>
<p>Gesture Recognizers 其实是在一个有限状态机的基础上工作的，它们都是通过一个预先设定好的方式从一个状态变化到另一种状态。在开始状态和结束状态之间，手势识别器会分析接收到的多点触控消息队列，并根据分析的结果发出不同的消息。<br>
还是盗文档的图来说明：</p>
<img src="/uploads/Basic-Gesture-Recognizers/gr_state_transitions_2x.png" class="center" title="GestureRecognizer State Transitions">
<p>每次状态的转换手势识别器都会发出对应的通知消息。而当状态到达 Recognized 的时候，手势识别器会将状态重置为 Possible，这个切换并不会向外给出通知。</p>
<h3 id="多手势共存">多手势共存</h3>
<p>通过 view 的 <code>gestureRecognizers</code> 属性可以访问到当前绑定在这个 view 上的所有手势识别器。</p>
<p>默认情况下，同一个 view 上的手势识别器是没有顺序可言的。也就是说，默认并不能确认每次操作会先触发哪个手势后触发哪个手势。但是我们可以重写这些行为已达到这样的效果：</p>
<ol>
<li>某些手势比另一些手势更优先地开始分析处理一个事件。</li>
<li>阻止某个手势的事件处理。</li>
<li>允许两个手势同时处理。</li>
</ol>
<h4 id="手势间的顺序">手势间的顺序</h4>
<p>使用某个手势的 <code>requireGestureRecognizerToFail:</code> 方法可以让这个手势延迟触发，知道作为参数的手势识别器状态改变为 fail。</p>
<p>e.g.<br>
swipe 和 pan 一起添加到 view 上的时候，pan 总是在 swipe 之前被识别到，因为 pan 是一个持续性的手势，所以用户操作一开始就会被识别为 pan；而 swipe 则会在用户手指离开后才进行判断。</p>
<p>所以如果想要在 pan 之前优先识别为 swipe 的话，可以这样做</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span>.panRecognizer requireGestureRecognizerToFail:<span class="keyword">self</span>.swipeRecognizer];</span><br></pre></td></tr></table></figure>
<p>这样就是告诉 pan 手势：你丫给我等到 swipe 手势 fail 了之后再说话！</p>
<p>所以在 swipe 手势 fail 之前，pan 手势识别器会一直处于 Possible 的状态，直到 swipe 手势 fail；反之，如果swipe手势识别器状态变成了 Recognized 或 Began 的话，pan 手势识别器就会自动转变为 Failed 状态。</p>
<blockquote>
<p>如果一个地方同时识别单击和双击，会出现两种不那么友好的情况，最好可以在交互上规避：</p>
<ol>
<li>不使用 <code>requireGestureRecognizerToFail:</code> 方法：在收到双击通知之前，会收到一次单击的通知，需要在单击方法的处理上区分这些情况。</li>
<li>使用 <code>requireGestureRecognizerToFail:</code> 方法：单击方法会有一些延迟，因为它需要等到双击手势识别器确认为 Failed 状态之后才可以执行。</li>
</ol>
</blockquote>
<h4 id="阻止手势识别器处理事件">阻止手势识别器处理事件</h4>
<p>这种高级玩法需要实现 <code>UIGestureRecognizerDelegate</code>，使用里面的两个 optional 代理方法 <code>gestureRecognizerShouldBegin:</code> 和 <code>gestureRecognizer:shouldReceiveTouch:</code>。</p>
<p>在用户进行操作时，如果可以立马判断出是不是需要响应这个事件的话，那就使用 <code>gestureRecognizer:shouldReceiveTouch: </code> 方法，这个方法会在每次新用户事件产生的时候被调到。</p>
<p>当需要等待一段时间之后才能判断是不是要响应这个事件的话，那就应该使用 <code>gestureRecognizerShouldBegin:</code> 方法。这个方法会在手势识别器尝试从Possible状态改变为其他状态的时候被调用，如果返回 <code>NO</code> 的话，这个手势识别器会立马被置为 Failed 状态，然后让下一个识别器继续处理这个用户事件。</p>
<p>UIView 里面也有一个同样的 <code>gestureRecognizerShouldBegin:</code> 方法，方法签名和实现都跟上面提到的这个代理方法一致，在不想实现 delegate 的时候很方便实用。</p>
<h4 id="允许多手势同时识别">允许多手势同时识别</h4>
<p>默认情况下，多个手势是不能同时被识别的到的，但是可以通过实现代理方法 <code>gestureRecognizer:shouldRecognizeSimultaneouslyWithGestureRecognizer: </code> 来达到多手势同时识别的目的。</p>
<blockquote>
<p>想要两个手势同时被识别的话，你只需要针对一个手势识别器实现上面这个方法，并返回 YES。<br>
所以，返回一个 NO 并不能确保这两个手势的识别互斥，因为有可能在另一个手势的对应代理方法中返回的是 YES。</p>
</blockquote>
<h4 id="多手势识别中的单向关系">多手势识别中的单向关系</h4>
<p>这标题比较拗口，举个例子：<br>
触发旋转手势的时候禁用缩放，但是触发缩放的时候可以旋转。</p>
<p>这时候就要重写 <code>canPreventGestureRecognizer: </code> 或 <code>canBePreventedByGestureRecognizer:</code> 方法了。</p>
<p>像上面的例子那种需求，首先要这样写：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[rotationGestureRecognizer canPreventGestureRecognizer:pinchGestureRecognizer];</span><br></pre></td></tr></table></figure>
<p>然后重写旋转手势识别器里面的这个方法，并返回一个 NO。这其实算是自定义手势识别器了，毕竟重写方法最好的做法还是先继承。</p>
<h2 id="总结">总结</h2>
<p>这里其实只涵盖了非常有限的一些基础知识，后面如果有机会就把这个写成一个系列文章。</p>
<p>参考资料：</p>
<blockquote>
<p>以前参考的是苹果官方的 <strong>Event Handling Guide for iOS</strong>，不过这篇文章已经从官网下架了，想了解更多信息的同学们可以看另外一篇 <a href="https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/">Gesture Recognizer Basics</a></p>
</blockquote>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"8225264e14e677544541","clientSecret":"ed2a2c6d5043e9f0b41cae78b0d5b4571099de53","repo":"HexoBlogSource","owner":"davidleee","admin":["davidleee"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Gesture</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 Redux 的 React Native 应用架构（1/2）</title>
    <url>/2017/04/20/Build-App-With-Redux/</url>
    <content><![CDATA[<blockquote>
<p>自从 Facebook 把 <a href="https://facebook.github.io/react-native/">React Native</a> 给开源了之后，使用前端技术进行移动应用开发的趋势已经越来越明显，现在连微软爸爸都用上了 React Native（<a href="https://github.com/Microsoft/reactxp">ReactXP</a>），我们还有什么理由不来一点前端技术尝尝呢？</p>
</blockquote>
<span id="more"></span>
<p>这篇文章是学习了公司现有项目框架、外加查阅一些官方文档之后的总结，受限于我仅有的一丢丢前端知识，如果有错误或没讲清楚的地方，欢迎在评论里给我留言 :)</p>
<p>因为要把现有项目讲清楚内容较多，所以分为两个部分来总结。这篇是第一个部分，主要涉及 Redux 思想的简单应用。</p>
<hr>
<h1>试想一下…</h1>
<p>我们从一个实际可能会遇到的需求出发，考虑一下 Native 的实现和 React Native 的实现有什么不同。</p>
<h2 id="来需求了">来需求了</h2>
<blockquote>
<p>用户在登录之后，在首页要显示用户的头像和名字，然后还应该可以在某个地方看到自己的全部信息。</p>
</blockquote>
<p>( ºωº ) 那还不简单！用户登录之后拉一下服务器上的用户信息，找个合适的界面把信息一股脑显示出来就好了，done！</p>
<h2 id="简单地改一下">简单地改一下</h2>
<blockquote>
<p>用户想要在我们的 App 上编辑自己的信息，我们简单点来，直接在信息显示的界面提供个编辑的入口就好了。</p>
</blockquote>
<p>∑(￣□￣;) …嗯，这个要求也合情合理。</p>
<p>编辑之后发个消息通知其他地方，比如首页的头像和名字就可能要更新…某个列表似乎会根据用户性别来决定显示的内容，不过什么人会用着用着修改性别？！</p>
<h2 id="来，这个更加简单">来，这个更加简单</h2>
<blockquote>
<p>果然修改一下用户信息很简单嘛，那再改回去也是一个道理吧，提供一个撤销修改的按钮吧。</p>
</blockquote>
<p>Σ(°Д°; 这！</p>
<hr>
<h1>为什么用 Redux</h1>
<p>如何优雅地实现上面的需求呢？如果我们的界面是与数据绑定的，并且数据的每一个状态我们都可以追踪到，那我们就不需要理会界面的更新，而可以专注于数据的修改了。</p>
<p>React Native 已经为我们提供了视图与数据绑定的机制，那么状态要怎么追踪呢？</p>
<h2 id="什么是-Redux">什么是 Redux</h2>
<blockquote>
<p><a href="https://github.com/reactjs/redux">Redux</a> 是一个为 JavaScript 应用设计的可预测的状态容器。</p>
</blockquote>
<p>简单来说，Redux 使用了一种叫做 Action 的东西，每一次对状态的变更（也就是对数据的变更）都需要通过 Action 来进行，然后通过另一个叫做 Reducer 的东西将 Action 和数据联系起来。下面这张流程图应该可以帮助你理解：</p>
<img src="/uploads/Build-App-With-Redux/flux.png" class="center" width="600" height="600" title="Flux">
<blockquote>
<p>这张图来自 <a href="https://facebook.github.io/flux/docs/in-depth-overview.html#content">Flux</a>，Redux 可以被理解为是 Flux 的具体实践。</p>
</blockquote>
<p>顾名思义，Action 是一个操作，也可以理解为将要发生的事件，例如“修改用户名”、“撤销修改”；而 Reducer 则位于上图 Dispatcher 和 Store 之间，负责将 Action 反应到对 Store 的修改上。</p>
<h2 id="初衷">初衷</h2>
<p>在上面的需求中，如果可以记录下用户的每一个操作和操作后的状态，那么当用户想要撤销某项操作时，只需要将上一个操作给无效掉就可以了。更暴力一些，我们把应用启动至今的所有用户操作都重播一遍，唯独不执行最后一次操作，就实现了“撤销”的功能了吧？</p>
<p>Redux 提供的机制正好满足了这个需求。</p>
<h2 id="不止如此">不止如此</h2>
<p>React Native 实现的应用可以类比为使用 JavaScript 实现的单页应用，随着开发日趋复杂，我们的应用需要管理的状态（state）会变得越来越多，管理的难度也将成倍增加。</p>
<p>Redux 提供的机制，通过限制数据更新发生的时间和方式，使得 state 的变化变得可以预测，后续的开发也可以放手施展了。</p>
<hr>
<h1>那该怎么做呢？</h1>
<p>接下来我们分别看看 Redux 中主要的三部分是怎么实现的。</p>
<h2 id="Action">Action</h2>
<p>为了描述一个动作，我们需要给这个动作一个名字和这个动作要操作的数据。举个栗子，对于用户想要改变用户名的情况，我们可以这样声明这个动作：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// actions.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> CHANGE_USERNAME = <span class="string">&#x27;CHANGE_USERNAME&#x27;</span> <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">changeUsername</span>(<span class="params">username</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">type</span>: CHANGE_USERNAME, username&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>首先我们将这个动作称为 <code>CHANGE_USERNAME</code>，理论上每一个 Action 都应该有一个独一无二的名字</li>
<li>通过一个创建函数，创建这个 Action 对象返回给调用方</li>
</ol>
<p>例子里的动作名和创建函数都是 <code>export</code> 的，因为一般会把同一个模块的动作声明放到一起，方便外部的调用。</p>
<h2 id="Reducer">Reducer</h2>
<p>需要注意的是，Reducer 必须是一个<a href="https://en.wikipedia.org/wiki/Pure_function">纯函数</a>。它不能修改传入的参数并且不能有任何副作用，它必须要保证只要两次传入的参数相同，得出的结果也要相同。</p>
<p>先看代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reducers.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; CHANGE_USERNAME &#125; <span class="keyword">from</span> <span class="string">&#x27;./actions&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  <span class="attr">username</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demoApp</span>(<span class="params">state = initialState, action</span>) </span>&#123; <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123; <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">case</span> CHANGE_USERNAME:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="comment">// 4</span></span><br><span class="line">        ...state,</span><br><span class="line">        <span class="attr">username</span>: action.username</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="attr">default</span>:</span><br><span class="line">      	<span class="keyword">return</span> state <span class="comment">// 5</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> demoApp</span><br></pre></td></tr></table></figure>
<ol>
<li>在 Redux 应用中，所有的 <code>state</code> 都被保存在一个单一的对象中</li>
<li>这里用到了 ES6 中的参数默认值语法，省去了初始化 <code>state</code> 的过程</li>
<li>当需要处理多个 Action 的时候，可以用 <code>switch</code>、<code>if/else</code> 等方式区分不同的处理方式</li>
<li>再次强调，Reducer 必须是一个纯函数，所以使用对象展开运算符把传入的 <code>state</code> 展开，避免修改到里面的参数</li>
<li>还是因为纯函数的原因，在不处理任何 Action 的时候，需要将传入的 <code>state</code> 原封不动地再传回去</li>
</ol>
<p>通过上面的 Reducer，当有 <code>CHANGE_USERNAME</code> 这个动作发生时，应用会通过 <code>demoApp</code> 方法来更新 <code>state</code> 中的 <code>username</code> 参数，如果有视图绑定在这个参数上，则界面也会发生相应的改变。</p>
<h2 id="Store">Store</h2>
<p>有了 Action 和 Reducer，我们还需要将这二者联系起来的途径，称为 Store。</p>
<p>Store 还具有维持应用 <code>state</code> 的职责，所以它在应用中也是单一存在的。当需要拆分数据处理逻辑的时候，应该做的是拆分 Reducer 而不是创建多个 Store。</p>
<p>继续来看代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// store.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> demoApp <span class="keyword">from</span> <span class="string">&#x27;./reducers&#x27;</span></span><br><span class="line"><span class="keyword">let</span> store = createStore(demoApp)</span><br></pre></td></tr></table></figure>
<p>没啦！我们需要用到的是 <code>store</code> 里面的方法，所以主要还是来看看怎么使用它们吧。</p>
<h2 id="调用">调用</h2>
<p>直接来看代码，我们假设已经存在一个用户信息界面，用户将在这里修改自己的名字：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UserInfo.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; changeUsername &#125; <span class="keyword">from</span> <span class="string">&#x27;./actions&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; store &#125; <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line"></span><br><span class="line">store.dispatch(changeUsername(<span class="string">&quot;Lee&quot;</span>)) </span><br></pre></td></tr></table></figure>
<p>在这里，我们通过 <code>changeUsername</code> 方法构造了一个 Action，并告诉它我们要把名字改成什么；通过 <code>store</code> 中的 <code>dispatch</code> 方法，这个 Action 就会被发送 Reducer 中进行处理。</p>
<p>只是写到这里，得益于纯函数的实现，我们就已经可以给上述代码中的所有方法写单元测试了，就是这么简单。</p>
<hr>
<h1>结语</h1>
<p>上面的例子只涉及到了 Redux 最基本的使用方式，到目前为止还不能做出什么有用的东西来，不过用来让我们感受 Redux 的主要思想应该是足够了。</p>
<p>在下一篇文章中，才会讲到 Redux 应用框架的搭建。其中会用到一些能有效减少代码量的第三方框架（从上面的例子应该不难想象，当程序变复杂之后，这几个类会变得多么庞大）。如果在学习了基础知识之后还是看不懂一些现有项目的代码的话，看完这些第三方框架的使用说不定就懂了呢！</p>
<p>更多更详细的资料可以看参考资料中的网站。关于 React Native 的部分建议上官网看原版，我发现中文网的翻译稍有缺失，更新也可能不那么及时。</p>
<hr>
<p>参考资料：<br>
<a href="https://facebook.github.io/react-native/">React Native</a><br>
<a href="http://reactnative.cn/">React Native 中文网</a><br>
<a href="http://cn.redux.js.org/">Redux 中文文档</a><br>
<a href="https://github.com/luhui/RNPlayground">RNPlayground</a></p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"8225264e14e677544541","clientSecret":"ed2a2c6d5043e9f0b41cae78b0d5b4571099de53","repo":"HexoBlogSource","owner":"davidleee","admin":["davidleee"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>React Native</tag>
        <tag>Redux</tag>
        <tag>Flux</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 句法</title>
    <url>/2018/10/19/CSS-syntax/</url>
    <content><![CDATA[<p>CSS 是声明型语言，这让它的句法（syntax）非常直白易懂。</p>
<p>除此之外，它还有很好的错误恢复机制，它能避免在错误发生时把所有东西都弄得一团乱：比如说在它碰到不认识的声明时，它会直接忽略掉这个东西。但从另一方面来说，这也让错误更难被发现了。</p>
<p>借着最近前端同事事务繁忙的机会，我这客户端工程师赶鸭子上架怼了一个静态网页出来，顺便产下了两篇副产品，都与 CSS 基础相关，这是第二篇（第一篇在此： <a href="/2018/10/19/How-CSS-works/" title="CSS 是怎么运作的">CSS 是怎么运作的</a>），希望对其他可能有相同需要的同志送上一些帮助。</p>
<span id="more"></span>
<h2 id="名词解释">名词解释</h2>
<p>正如<a href="/2018/10/19/How-CSS-works/" title="上一篇文章">上一篇文章</a>里说到的，CSS 是由选择器和一组属性组成的。其中，属性部分是由一系列的键值对组成，在 CSS 的世界里，它们有着自己的名字：</p>
<ul>
<li>属性（Properties）：以“说人话”的方式表明这个玩意儿是干什么的</li>
<li>值（Values）：每个属性都会有对应的值，表示你想要怎么修改这个东西</li>
</ul>
<p>这样的一组“属性-值”的组合，我在前面直接称呼为“键值对”了，但它在 CSS 世界里的本名其实是 <strong>CSS 声明（CSS declaration）</strong>。<br>
被一对大括号包裹起来的一组 CSS 声明被称为 <strong>CSS 声明块（CSS declaration blocks）</strong>。<br>
最后，一个 CSS 声明块会跟一个选择器搭配起来，称为 <strong>CSS 规则（CSS Rulesets/Rules）</strong>。</p>
<h3 id="CSS-声明">CSS 声明</h3>
<p>把 CSS 属性设置为一个特定的值，可以说是 CSS 这门语言的最核心功能了。需要注意的是，属性和值都是区分大小写的，它们之间用 “:” 来分隔。</p>
<p>目前，CSS 世界里一共有<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Reference">300 种不同的属性</a>，每种属性都有其对应的可选值。</p>
<blockquote>
<p>在 CSS 语法里（包括其他 web 标准中），美式拼写是唯一的拼写标准。比如说，在需要设置颜色的时候，<code>color</code> 永远优于 <code>colour</code>。</p>
</blockquote>
<h3 id="CSS-声明块">CSS 声明块</h3>
<p>CSS 声明以代码块的形式存在，用一对大括号括起来。</p>
<blockquote>
<p>CSS 声明块可以是空的（里面不带任何声明）</p>
</blockquote>
<p>CSS 声明块里的不同声明是通过 “;” 来分隔的。</p>
<blockquote>
<p>实际上，最后一组声明是可以不用分号结尾的，但是好好的干嘛要逼死强迫症呢？</p>
</blockquote>
<h3 id="CSS-选择器和规则">CSS 选择器和规则</h3>
<p>在写好了声明块之后，我们还需要告诉浏览器这些属性要用到哪里去，这就需要在这个声明块前面加上一个前缀——选择器了。</p>
<p>选择器可以是非常复杂的：你可以把一个声明块应用到好几个选择器上，通过逗号分隔；你还可以链式地构造一个指向性更明确的选择器，比如：选择一个类名是 “abc” 的元素，它要在 <code>&lt;article&gt;</code> 标签下，而且只有鼠标移动到它上面的时候才生效。</p>
<p>一个元素可能被多个选择器看上，所以同一个属性可能会被改变多次，CSS 会通过层叠算法（cascade algorithm）来判断这些属性修改的优先级。</p>
<blockquote>
<p>对于同一个声明块，在使用复杂选择器的时候（比如存在多个选择器），如果其中的某一项选择有误，那么其他的选择器是不会被影响的，该怎么工作还是怎么工作。</p>
</blockquote>
<h3 id="CSS-语句">CSS 语句</h3>
<p>除了上面看到的声明块之外， CSS 里还有一些其他类型的语句：</p>
<ul>
<li><strong>At-规则</strong> 用来传达元数据、条件信息或其他描述性信息。比如说：
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@charset">@charset</a>  和  <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@import">@import</a>  (元数据)</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@media">@media</a>  或者  <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@document">@document</a>  (条件信息，也叫内部语法)</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face">@font-face</a>  (描述性信息)<br>
完整的写法是这样的：</li>
</ul>
</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;custom.css&#x27;</span>; <span class="comment">/* 从另一个 css 文件中引入规则 */</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>内部语法（Nested statements）</strong> 是 at-规则 的一个子集，这类规则只会在特定条件下才会生效：
<ul>
<li><code>@media</code> 运行设备符合某些条件时才执行</li>
<li><code>@supports</code> 浏览器支持某些测试特性的时候才执行</li>
<li><code>@document</code> 当前页面符合某些条件时才执行<br>
举个例子：</li>
</ul>
</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">801px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">800px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述针对 <code>body</code> 的规则，只在设备宽度大于 800px 的时候才会生效。</p>
<h2 id="小结">小结</h2>
<p>分两篇叙述的 CSS 相关知识就讲完了。这两篇文章的主要目的是把我们领进前端世界的大门，读完之后，我们应该可以实现一些简单的静态页面了！<sub>（小声说：虽然具体怎么用还需要自己去谷歌百度一下）</sub>当然，前端的魅力还远不止如此，要想把 CSS 玩出花儿来，还需要持续的磨练。</p>
<p>我这个半吊子的前端工程师总算是把整个静态页面的需求给怼出来啦！接下来如果有时间的话，我会再把页面里用到的一些 JS 实现的逻辑也拉出来溜一溜。要是这下一篇文章真的有诞生之日的话，那读到完整三个部分的同学们就会在前端界六得飞起<sub>（假的）</sub>了！</p>
<h2 id="参考文章">参考文章</h2>
<p><a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Introduction_to_CSS/Syntax">CSS syntax - Learn web development | MDN</a></p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"8225264e14e677544541","clientSecret":"ed2a2c6d5043e9f0b41cae78b0d5b4571099de53","repo":"HexoBlogSource","owner":"davidleee","admin":["davidleee"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>css</tag>
        <tag>html</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>Gesture Recognizers for iOS - The Customization</title>
    <url>/2017/03/29/Custom-Gesture-Recognizers/</url>
    <content><![CDATA[<p>总觉得看英文文档并做笔记，写着写着就会变成原文翻译…不过这也算是对文档中内容的一种学习和吸收吧。<br>
上一篇文章主要讲的是系统自带的手势识别器的一些使用方法，这篇文章将会把注意力放在自定义的手势处理上。</p>
<span id="more"></span>
<h2 id="面向对象">面向对象</h2>
<p>当一次<em>触摸</em>发生时，会根据触摸手势的不同而产生相应个数的 UITouch 对象，而一个<em>事件</em>是一系列多指触摸事件的汇总。在 iOS 中，触摸用 <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITouch_Class/index.html#//apple_ref/occ/cl/UITouch">UITouch</a> 对象来表示，触摸事件用<code>UIEventTypeTouches</code>类型的 <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIEvent_Class/index.html#//apple_ref/doc/uid/TP40006780-CH3-SW12">UIEvent</a> 对象来表示。</p>
<h3 id="UITouch">UITouch</h3>
<p>每一个触摸对象只对应一只手指的触摸事件，从手指放到屏幕上到手指抬起，持续的捕获这个对象的相关属性，包括：触摸状态、触摸位置、上一个触摸位置和时间戳。</p>
<blockquote>
<p>手指触摸的精度可远比不上鼠标。当触摸事件发生时，触摸的区域其实是个椭圆形，而且触摸的位置比用户认为的会略低一些。这些区别的产生会因为手指的大小和方向不同而不同，另外还可能受到按压力度、使用不同手指和一些其他因素的影响。<br>
不过这些问题已经被底层的多点触控系统处理好了，在上层看来，用户就是触摸到了一个点而已。</p>
</blockquote>
<h3 id="UIEvent">UIEvent</h3>
<p>一个触摸事件包含了所有与这个事件相关的触摸对象（UITouch），所以它很好的反映了这一次触摸的<em>综合</em>情况。所以我们通常都是捕获事件，而不是直接捕获触摸对象。</p>
<ul>
<li><code>touchesBegan:withEvent:</code> 一只或多只手指触摸到了屏幕。</li>
<li><code>touchesMoved:withEvent:</code> 一只或多只手指在屏幕上移动。</li>
<li><code>touchesEnded:withEvent:</code> 一只或多只手指从屏幕上抬起。</li>
<li><code>touchesCancelled:withEvent:</code> 手势队列被系统事件打断，比如来了个电话。</li>
</ul>
<h2 id="触摸事件的传递链">触摸事件的传递链</h2>
<p>如果一个视图上添加了系统的手势识别器，那么当这个视图所在 window 收到了触摸消息时，它会优先传递给手势识别器，然后延迟一小段时间再传递给视图。当手势识别器的状态改变为 Recognized 的时候，接下来还没发送给视图的触摸事件将不会再发送给视图，而视图的事件状态也会被置为 Cancelled。</p>
<img src="/uploads/Custom-Gesture-Recognizers/continuous_gesture_2x.png" class="center" title="手势状态">
<p>关于手势识别器和视图的手势响应事件的一些冲突，可以通过 UIGestureRecognizer 的属性来进行一定的控制，具体就不在这里展开了。</p>
<h2 id="自定义手势识别器">自定义手势识别器</h2>
<p>想要实现自定义的手势识别器，最好的方法就是继承 UIGestureRecognizer，在子类的头文件中引入这个头文件：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIGestureRecognizerSubclass.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>并且重写下面的方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)reset; <span class="comment">// 到达手势的终止状态时，就会调用这个方法</span></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="keyword">void</span>)touchesMoved:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="keyword">void</span>)touchesCancelled:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br></pre></td></tr></table></figure>
<h2 id="举例子">举例子</h2>
<p>说了那么多，还是来写点代码吧，实现一个自定义的缩放手势<code>CMLPinchGestureRecognizer</code>。</p>
<p>对于缩放手势的特性，先做一些限制：</p>
<ol>
<li>只能两指缩放（<code>touches.count == 2</code>）</li>
<li>缩放比例不累加（系统 Pinch 手势会累加）</li>
</ol>
<p>清楚了这些之后就可以开始动手了！</p>
<h3 id="手指数目的判断">手指数目的判断</h3>
<p>上面提到的需要重写的方法中，传入的 <code>touches</code> 参数是动态改变的，所以 <code>touches.count</code> 并不能反映真实的在屏幕上的手指个数。<br>
什么意思呢？看看下面两种情况：</p>
<ol>
<li>两只手指<strong>同时</strong>放到屏幕上，并执行捏合/张开的操作。</li>
<li>先放一只手指，再通过反复滑动另一只手指来达到缩放的效果。</li>
</ol>
<p>第一种情况，<code>touches.count</code> <strong>应该</strong>是等于2的。<br>
而第二种情况，会先收到一次 <code>touchesBegan:withEvent:</code>，它的 <code>touches</code> 参数里只有一个 UITouch（对应第一次放下的手指），然后收到多次<code>touchesBegan:withEvent:</code>，<code>touches</code> 参数里也是只有一个 UITouch（对应后面放下的手指）。</p>
<blockquote>
<p>第一种情况的结果为什么说是<strong>应该</strong>呢？因为如果第一种操作下的<strong>同时</strong>不是很准确的话，也会引起第二种操作的情况。</p>
</blockquote>
<p>所以为了实现手指个数的判断，需要在子类里面保存一个 UITouch 数组。<br>
我们要在<code>touchesBegan:withEvent:</code>记录下新的 UITouch，并在<code>touchesEnded:withEvent:</code>中把抬起的手指对应的 UITouch 从数组中移除掉。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    [<span class="keyword">super</span> touchesBegan:touches withEvent:event];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.beganTouches count] == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSArray</span> *allTouches = [touches allObjects];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UITouch</span> *touch <span class="keyword">in</span> allTouches) &#123;</span><br><span class="line">        <span class="keyword">if</span> (![<span class="keyword">self</span>.beganTouches containsObject:touch]) &#123;</span><br><span class="line">            [<span class="keyword">self</span>.beganTouches addObject:touch];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    [<span class="keyword">super</span> touchesEnded:touches withEvent:event];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSArray</span> *allTouches = [touches allObjects];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UITouch</span> *touch <span class="keyword">in</span> allTouches) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.beganTouches removeObject:touch];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="计算缩放比例">计算缩放比例</h3>
<p>我们已经知道一个 UITouch 里面会保存有当前位置和上一个位置，那么只要用两个触摸点的当前距离除以上一次的距离，就可以得出缩放比例了。</p>
<p>计算距离的方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">CGFloat</span>)distanceBetweenPoint1:(<span class="built_in">CGPoint</span>)p1 point2:(<span class="built_in">CGPoint</span>)p2 &#123;</span><br><span class="line">    <span class="keyword">return</span> sqrt( (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>touchesMoved:withEvent:</code>里面做计算：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesMoved:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    [<span class="keyword">super</span> touchesMoved:touches withEvent:event];</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSArray</span> *touchesArray = [<span class="keyword">self</span>.beganTouches <span class="keyword">copy</span>];</span><br><span class="line">    <span class="built_in">UITouch</span> *f1 = touchesArray[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">UITouch</span> *f2 = touchesArray[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGFloat</span> currentDistance = [<span class="keyword">self</span> distanceBetweenPoint1:[f1 locationInView:<span class="keyword">self</span>.view] point2:[f2 locationInView:<span class="keyword">self</span>.view]];</span><br><span class="line">    <span class="built_in">CGFloat</span> previousDistance = [<span class="keyword">self</span> distanceBetweenPoint1:[f1 previousLocationInView:<span class="keyword">self</span>.view] point2:[f2 previousLocationInView:<span class="keyword">self</span>.view]];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.scale = currentDistance / previousDistance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>到这里，已经可以基本实现一个缩放手势的识别并给出缩放比例了。当然上面给出的代码片段还不完整，还有很多地方需要完善。<br>
例如识别器状态切换、延迟识别（主要为了防止与别的手势冲突）、特殊情况处理等等等等。<br>
另外，在多个手势识别器协同工作的时候，也会有这样那样的一些坑，有时间的话再另开一篇番外篇来描述吧。</p>
<p>参考资料：</p>
<blockquote>
<p>以前参考的是苹果官方的 <strong>Event Handling Guide for iOS</strong>，不过这篇文章已经从官网下架了，想了解更多信息的同学们可以看另外一篇 <a href="https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/ImplementingaCustomGestureRecognizer.html">Implementing a Custom Gesture Recognizer</a></p>
</blockquote>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"8225264e14e677544541","clientSecret":"ed2a2c6d5043e9f0b41cae78b0d5b4571099de53","repo":"HexoBlogSource","owner":"davidleee","admin":["davidleee"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Gesture</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Swift 中的问号感叹号</title>
    <url>/2017/07/14/Dive-in-Swift-Optional/</url>
    <content><![CDATA[<p>对于写惯了 OC 代码的程序员来说，不判空直接调用对象方法可能已经成为习惯了；而当方法的返回值是对象时，通常也是拿来就用。这些情况在 Swift 下都不存在了，因为 Swift 中出现了一个全新的概念：Optional（? &amp; !）。</p>
<span id="more"></span>
<p>Optional 用于表示一种值可能为空的对象类型。一个 Optional 对象表示了两种可能性：要么对象有值，你可以通过 “unwrap” 去获取到这个值；要么对象里面没有任何东西。</p>
<blockquote>
<p>unwrap（解包）：在对象后加 “?” 或 “!” 称为将对象 “unwrap”，可以获取到 Optional 里面的关联值</p>
</blockquote>
<p>Optional 这个概念在 C 语言或 Objective-C 里面并不存在。在 OC 中最接近的概念是：本来要返回对象的方法可能会返回 nil，这个 nil 表示“没有有效的对象可以返回”；然而，这只在对象身上有效，它不能作用在结构体、基础 C 类型或枚举上。这些类型的变量如果没有值，OC 会用 <code>NSNotFound</code> 来表示，它需要方法的调用者意识到这些特殊返回值的存在，并作出特殊的处理。</p>
<p>Optional 解决了上述问题，在 Swift 中，Optional 可以处理任何类型的空值，而不需要用一个特殊的常量去表示。</p>
<p>举个栗子：<br>
当我们需要将字符串转换为数字时，在 Swift 中会使用 <code>Int</code> 的构造方法，如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> possibleNumber <span class="operator">=</span> <span class="string">&quot;123&quot;</span></span><br><span class="line"><span class="keyword">let</span> convertedNumber <span class="operator">=</span> <span class="type">Int</span>(possibleNumber)</span><br></pre></td></tr></table></figure>
<p>此时，<code>convertedNumber</code> 就是一个 Optional，看一下文档可以发现，这个构造方法返回的是 <code>Int?</code>。</p>
<p>原因是这个构造器可能会失败： <code>possibleNumber</code> 也许并不能被转化为数字。这里的 <code>?</code> 表示返回的对象是一个可选值，它可能是某个 <code>Int</code> 类型的对象，也可能什么都没有。（它不可能是别的类型的对象，因为 Swift 是强类型的）</p>
<h2 id="nil">nil</h2>
<p>这里可以套用 OC 中的概念，<code>nil</code> 表示空值，但是在 Swift 中，它只能被赋值给 Optional 对象。当声明一个 Optional 的变量又没有给它赋值时，它会自动被赋值为 <code>nil</code> ：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> surveyAnswer: <span class="type">String</span>?</span><br><span class="line"><span class="comment">// surveyAnswer == nil</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>本质上 Swift 的 <code>nil</code> 跟 OC 的 <code>nil</code> 是不一样的。<br>
在 OC 中，<code>nil</code> 是指向一个不存在对象的指针；在 Swift 中，<code>nil</code> 不是一个指针，它是一个带有特定类型的表示数值缺失的值，任何类型的 Optional 都可以设置为 <code>nil</code> 而不只是对象类型。</p>
</blockquote>
<h2 id="If-和强制解包">If 和强制解包</h2>
<p>可以使用 <code>if</code> 来判断一个 Optional 对象是否有值，就像常见的判空操作。在判空后，这个 Optional 对象可以使用 <code>!</code> 来强制解包，这相当于告诉编译器：“我确定这个 Optional 对象肯定有值，直接取出来用吧！”</p>
<p>举个栗子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> convertedNumber <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;convertedNumber has an integer value of <span class="subst">\(convertedNumber<span class="operator">!</span>)</span>.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当 <code>!</code> 被用在一个空值时，你的程序就会“卡蹦”一声崩掉！</p>
</blockquote>
<h2 id="Optional-Binding">Optional Binding</h2>
<p>这个机制可以用来判断一个 Optional 对象是否有值，如果有值就将它复制给一个局部变量或常量，否则不执行任何操作。</p>
<p>我们用 Optional Binding 来改写上一小节中的例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> actualNumber <span class="operator">=</span> <span class="type">Int</span>(possibleNumber) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\&quot;</span><span class="subst">\(possibleNumber)</span><span class="subst">\&quot;</span> 是一个整型数字 <span class="subst">\(actualNumber)</span>&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\&quot;</span><span class="subst">\(possibleNumber)</span><span class="subst">\&quot;</span> 不能被转化为整型&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 <code>Int()</code> 返回的对象有值，这个值就会被直接赋给前面的 <code>actualNumber</code> ，所以这个变量就不是一个 Optional，可以不需要解包而直接使用了。</p>
<p>在这种用法下，<code>if</code> 原来的作用还是存在的，可以用逗号分隔不同类型的判断，比如这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> firstNumber <span class="operator">=</span> <span class="type">Int</span>(<span class="string">&quot;4&quot;</span>), <span class="keyword">let</span> secondNumber <span class="operator">=</span> <span class="type">Int</span>(<span class="string">&quot;42&quot;</span>), firstNumber <span class="operator">&lt;</span> secondNumber <span class="operator">&amp;&amp;</span> secondNumber <span class="operator">&lt;</span> <span class="number">100</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(firstNumber)</span> &lt; <span class="subst">\(secondNumber)</span> &lt; 100&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果其中一个 Optional 没有值，或者最后那个判断的结果为 false，整个 if 判断会直接返回 false</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过 Optional Binding 声明的变量的作用于只在这个 <code>if</code> 之内，除非用 <code>guard</code> 去声明，详情参见官方文档 <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/ControlFlow.html#//apple_ref/doc/uid/TP40014097-CH9-ID525">Early Exit</a></p>
</blockquote>
<h2 id="隐式解包">隐式解包</h2>
<p>有时候，在特定的代码结构下，一个 Optional 对象可以被确保永远都有值（或者说理应永远都有值）。这种时候，每次使用这个对象都进行判空和解包就显得非常多余了，于是我们可以在声明这个对象的时候用隐式解包来处理：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> forcedString: <span class="type">String</span>!</span><br><span class="line"><span class="built_in">print</span>(forcedString) <span class="comment">// 不需要写成 “forcedString!”</span></span><br></pre></td></tr></table></figure>
<p>事实上，例子中的 <code>forcedString</code> 还是一个 Optional 没变，但是我们让它在使用的时候自动解包，不需要我们手动加 <code>!</code> 了。</p>
<h2 id="链式调用">链式调用</h2>
<p>如果我们要取得的对象被包裹在了一层又一层的 Optional 之中，取得它的过程可能非常繁琐：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> label: <span class="type">UILabel</span>?</span><br><span class="line"><span class="keyword">if</span> label <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">let</span> temp1 <span class="operator">=</span> label.text &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">let</span> temp2 <span class="operator">=</span> temp1.hashText &#123;</span><br><span class="line">			<span class="operator">...</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候，可以使用链式调用的方式改写：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> hashText <span class="operator">=</span> label<span class="operator">?</span>.text<span class="operator">?</span>.hashText &#123;</span><br><span class="line">	<span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这句话当中，<code>?</code> 表达的意思是：“如果这个对象有值就取出来，继续下面的步骤；如果没有值，就当我没写过这句话吧”。</p>
<h2 id="默认值">默认值</h2>
<p>在一些情况下，我们会想要 Optional 对象为 <code>nil</code> 的时候给出一个默认值。比如我们使用一个 <code>String?</code> 给 <code>label.text</code> 赋值时，我们并不希望设置一个 <code>nil</code> 上去，因为那会让 UILabel 的高度变为0。<br>
一种很简便的写法是这样的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s: <span class="type">String</span>?</span><br><span class="line">s <span class="operator">=</span> <span class="operator">...</span></span><br><span class="line">label.text <span class="operator">=</span> s <span class="operator">??</span> <span class="string">&quot;placeholder&quot;</span></span><br></pre></td></tr></table></figure>
<p>这样，当 <code>s</code> 为空时，<code>label.text</code> 的值就会是 “placeholder”。</p>
<h2 id="总结">总结</h2>
<p>Swift 中的 Optional 其实是一个 enum：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Optional</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">case</span> none</span><br><span class="line">	<span class="keyword">case</span> <span class="keyword">some</span>(<span class="type">T</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而它现在所见到的使用方法都可以认为是 Swift 的语法糖：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x: <span class="type">String</span>?</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">let</span> x <span class="operator">=</span> <span class="type">Optional</span>&lt;<span class="type">String</span>&gt;.none</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x: <span class="type">String</span>? <span class="operator">=</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">let</span> x <span class="operator">=</span> <span class="type">Optional</span>&lt;<span class="type">String</span>&gt;.some(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> y <span class="operator">=</span> x<span class="operator">!</span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">switch</span>(x) &#123;</span><br><span class="line">	<span class="keyword">case</span> .some(<span class="keyword">let</span> value): y <span class="operator">=</span> value</span><br><span class="line">	<span class="keyword">case</span> .none: <span class="comment">// 抛个异常并整死你的应用:)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> y <span class="operator">=</span> x &#123;</span><br><span class="line">	y.doSomething()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">switch</span>(x) &#123;</span><br><span class="line">	<span class="keyword">case</span> .some(<span class="keyword">let</span> y):	y.doSomething()</span><br><span class="line">	<span class="keyword">case</span> .none: <span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>什么？你想问这是哪门子的 enum？推荐你去看看官方文档 <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Enumerations.html#//apple_ref/doc/uid/TP40014097-CH12-ID145">Enumeration</a></p>
</blockquote>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID309">The Swift Programming Language (Swift 4)</a></li>
<li><a href="https://itunes.apple.com/us/course/developing-ios-10-apps-with-swift/id1198467120">Developing iOS 10 Apps with Swift</a></li>
</ul>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"8225264e14e677544541","clientSecret":"ed2a2c6d5043e9f0b41cae78b0d5b4571099de53","repo":"HexoBlogSource","owner":"davidleee","admin":["davidleee"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>Swift</tag>
        <tag>Optional</tag>
        <tag>nil</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 是怎么运作的</title>
    <url>/2018/10/19/How-CSS-works/</url>
    <content><![CDATA[<p>CSS 全称 Cascading Style Sheets，网页内容（HTML）会被浏览器转换为 DOM（Document Object Model）以供显示，而 CSS 就是作用在 DOM 上以改变它们的样式、布局或行为等。对于前端工程师来说，这是很常见的基本操作了，但是对其他不常敲网页代码的程序员来说，却可能会有些陌生。</p>
<p>借着最近前端同事事务繁忙的机会，我这客户端工程师赶鸭子上架怼了一个静态网页出来，顺便产下了两篇副产品，都与 CSS 基础相关，这是第一篇，希望能对其他可能有相同需要的同志送上一些帮助。</p>
<span id="more"></span>
<blockquote>
<p>文章的内容基本是翻译 MDN 文档来的，怕有什么遗漏的同学可以直接翻到文末看官文，也欢迎指出本文的错误 :)</p>
</blockquote>
<h2 id="CSS-是怎么作用到-HTML-上的？">CSS 是怎么作用到 HTML 上的？</h2>
<p>网页浏览器会把 CSS 规则应用到文档上，以改变文档内容的表现形式，一个单一的 CSS 规则是由下面这两个东西组成的：</p>
<ol>
<li>一组属性（Properties）：这些参数会更新 HTML 的内容，让它在显示的时候与众不同</li>
<li>一个选择器（Selector）：用来挑选要作用到哪个元素上</li>
</ol>
<p>一个 CSS 规则约定了某个元素长什么样，一个包含了一组 CSS 规则（Rulesets/Rules）的 <code>stylesheet</code> 就定义了一个网页的长相。</p>
<h3 id="举个例子">举个例子</h3>
<p>来看一个简单的 HTML 文档，这个例子里包含了 <code>&lt;h1&gt;</code> 和 <code>&lt;p&gt;</code> 标签，而 <code>stylesheet</code> 则是通过 <code>&lt;link&gt;</code> 元素实现的：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>My CSS experiment<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is my first CSS example<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后看两个 CSS 的规则：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">  <span class="attribute">background-color</span>: yellow;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这两个 CSS 规则是写在 <em>style.css</em> 文件里的，跟上面的 <em>.html</em> 文件放在一起就可以通过相对路径引用到</p>
</blockquote>
<p>大括号签名的标签（<code>h1</code> 和 <code>p</code>）就是选择器，它告诉浏览器这些规则要作用在什么标签上；而大括号里的键值对就约定了这些标签的内容的显示规则。</p>
<h2 id="原理呢？">原理呢？</h2>
<p>浏览器在处理网页的时候，会分两步走：</p>
<ol>
<li>把 HTML 和 CSS 转换为 DOM，DOM 会把内容和样式融合到一起</li>
<li>把 DOM 的内容显示出来<br>
<img src="/uploads/How-CSS-works/D90AF498-F58B-4AEF-91B9-9E38F4863B92.png" alt="DOM"></li>
</ol>
<h2 id="介绍一下-DOM">介绍一下 DOM</h2>
<p>一个 DOM 的内容是以树状结构保存的。每个通过 markup 语言表述的元素、属性、文字等会变成 DOM 节点保存在树上。</p>
<h3 id="DOM-的真面目">DOM 的真面目</h3>
<p>假设我们有一段 HTML 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  Let&#x27;s use:</span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Cascading<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Style<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Sheets<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>将它转换为 DOM 之后，这个 DOM 会是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P</span><br><span class="line">├─ &quot;Let&#x27;s use:&quot;</span><br><span class="line">├─ SPAN</span><br><span class="line">|  └─ &quot;Cascading&quot;</span><br><span class="line">├─ SPAN</span><br><span class="line">|  └─ &quot;Style&quot;</span><br><span class="line">└─ SPAN</span><br><span class="line">   └─ &quot;Sheets&quot;</span><br></pre></td></tr></table></figure>
<p>现在来加一个 CSS 约束试试：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">  <span class="attribute">background-color</span>: lime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>emmm…还是跟刚刚一样的 DOM，不过这些 CSS 约束会被加到 <code>span</code> 选择器上面去，于是渲染出来的样子就不一样了。</p>
<h2 id="三种使用-CSS-的方法">三种使用 CSS 的方法</h2>
<h3 id="外部-stylesheet">外部 stylesheet</h3>
<p>就是上面例子里用到的方法，CSS 约束是写在一个单独的 <em>.css</em> 文件里的</p>
<h3 id="内部-stylesheet">内部 stylesheet</h3>
<p>即直接通过 <code>&lt;style&gt;</code> 标签来定义元素的长相，这个 <code>&lt;style&gt;</code> 需要写在 <code>&lt;head&gt;</code> 标签下才会生效：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>My CSS experiment<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-tag">h1</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">color</span>: blue;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="css">        <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is my first CSS example<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个例子跟之前的例子是同样效果的。</p>
<h3 id="内联样式">内联样式</h3>
<p>对于只想改变单独一个标签元素的情况下，可以通过标签的 <code>style</code> 属性实现：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>My CSS experiment<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&quot;color: blue;background-color: yellow;border: 1px solid black;&quot;</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color:red;&quot;</span>&gt;</span>This is my first CSS example<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然而这种做法并没有很受待见，因为这样定义的样式没办法复用，你可能需要在好几个文档里面写上同样的几个样式，维护成本大大升高了。</p>
<p>另一方面，把 HTML 语法跟 CSS 语法混合在一起，看起来就不那么清晰易懂了，建议是把不同类型的代码分开，保持纯粹。</p>
<h2 id="小结">小结</h2>
<p>到这里，我们已经不止能写 HTML 网页了，还能通过 CSS 给这简陋的网页披上华丽丽的外衣。在下一篇文章里，我们会继续深入学习 CSS 的句法，距离踏入前端世界的大门又要近一些了！</p>
<h2 id="参考文章">参考文章</h2>
<p><a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Introduction_to_CSS/How_CSS_works">How CSS works - Learn web development | MDN</a></p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"8225264e14e677544541","clientSecret":"ed2a2c6d5043e9f0b41cae78b0d5b4571099de53","repo":"HexoBlogSource","owner":"davidleee","admin":["davidleee"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>css</tag>
        <tag>html</tag>
        <tag>web</tag>
        <tag>dom</tag>
      </tags>
  </entry>
  <entry>
    <title>【翻译】Core Animation 3D 绘图（下）</title>
    <url>/2016/07/16/Introduction-to-3D-drawing-in-core-animation-Part-II/</url>
    <content><![CDATA[<p>这是关于 Core Animation 三维绘图的翻译文第二篇（共两篇），这里会承接上一篇的内容，把之前的成果与手势控制结合起来，完成了一个很有趣的效果，原文是 Think &amp; Build 上的 <a href="http://www.thinkandbuild.it/introduction-to-3d-drawing-in-core-animation-part-2">Introduction to 3D drawing in core animation（Part 2）</a>。想看最终成品可以去原文作者的 Github 上看<a href="https://github.com/ariok/TB_3DCoreAnimation">这个地方</a>，把源码下载回来自己跑一下。</p>
<span id="more"></span>
<blockquote>
<p>因为翻译这篇文章的时间已经比较久远了，难免有一些错误的地方，欢迎大家指出来共同进步。</p>
</blockquote>
<p>在上一篇文章中，我们已经学到了用 Core Animation 来绘制三维图的基础。在接下来的这一部分，我们会用到更深入的技巧，去创造一个交互视图。我们会做一个像行李输送带那样的东西，让用户可以通过手势交互来控制它。</p>
<h2 id="“传送带”概览">“传送带”概览</h2>
<p>先来挖掘一下这个效果的设计，好让我们清楚怎么去分解它。</p>
<h3 id="三维的！">三维的！</h3>
<p>首先，我们可以猜到需要用透视图来实现整个画面。因为从用户的角度去看，远方的卡片是立体的。所以，我们会创建一个三维层次（3D hierarchy），正如上一篇文章所描述的那样，使用一个 <code>CATransformLayer</code> 来作为根视图。</p>
<h3 id="卡片们">卡片们</h3>
<p>这个传送带由许多卡片（原文是 Plane，暂且这么叫吧）组成。我们会用一个 <code>CAGradientLayer</code> 来表示这些对象。这是 <code>CALayer</code> 的一个子类，不同的是我们可以用一个渐变色来作为它的背景色，而不是常见的单一色彩。</p>
<p>这些卡片会绕着一个圆心做圆周运动，并且带有旋转的效果。（想象一下机场行李输送带的样子）。</p>
<h3 id="手势（Gesture）">手势（Gesture）</h3>
<p>监听用户的手势操作比较简单，使用一个 <code>Gesture Recognizer</code> 就可以了。<br>
我们要做的就只是跟踪用户的操作，把获取的数据转化为可以用来表示传送带旋转角度的数值。</p>
<p>好，有了一定的“全局观”之后，我们就可以来耍耍了。启动神圣的 Xcode！</p>
<h2 id="代码敲起来！">代码敲起来！</h2>
<p>我们从第一个视图控制器的 viewDidLoad 开始：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">	[<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Initialize the TransformLayer</span></span><br><span class="line">	transformLayer = [<span class="built_in">CATransformLayer</span> layer];</span><br><span class="line">	transformLayer.frame = <span class="keyword">self</span>.view.bounds;</span><br><span class="line">	[<span class="keyword">self</span>.view.layer addSublayer:transformLayer];</span><br><span class="line"></span><br><span class="line">	angle = <span class="number">0</span>;</span><br><span class="line">	XPanOffset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Create 5 planes</span></span><br><span class="line">	[<span class="keyword">self</span> addPlane];</span><br><span class="line">	[<span class="keyword">self</span> addPlane];</span><br><span class="line">	[<span class="keyword">self</span> addPlane];</span><br><span class="line">	[<span class="keyword">self</span> addPlane];</span><br><span class="line">	[<span class="keyword">self</span> addPlane];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Force the first animation to set the planes in place</span></span><br><span class="line">	[<span class="keyword">self</span> animate];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Initialize the Pan gesture recognizer</span></span><br><span class="line">	<span class="built_in">UIPanGestureRecognizer</span> *panGesture =  [[<span class="built_in">UIPanGestureRecognizer</span> alloc]initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(pan:)];</span><br><span class="line">	[<span class="keyword">self</span>.view addGestureRecognizer:panGesture];   </span><br><span class="line">&#125;           </span><br></pre></td></tr></table></figure>
<p>完成！因为这是主干部分，所以只管读下去，看到分解的细枝末节之后，这里的代码自然就理解了。</p>
<p>现在我们清楚知道的是，这里创建了一个 <code>CATransformLayer</code> 的对象（transformLayer）来作为根图层；然后我们用 <code>addPlane</code> 这个方法往根图层里面加入了5张卡片；最后我们用 <code>-[panGesture:]</code> 方法来统一管理所有的 Pan 手势。</p>
<h2 id="把卡片先画出来">把卡片先画出来</h2>
<p><code>-[addPlane]</code> 这个方法很直白了。它只是用来创建一个 <code>CAGradientLayer</code> 并且给它加上一些属性，然后把这个图层作为子图层，插入到 <code>transformLayer</code> 里面去。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** A simple function to create a CAGradientLayer **/</span></span><br><span class="line">- (<span class="keyword">void</span>)addPlane &#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">CGSize</span> planeSize = <span class="built_in">CGSizeMake</span>(<span class="number">250</span>, <span class="number">150</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Initialize the layer</span></span><br><span class="line">	<span class="built_in">CAGradientLayer</span> *layer = [<span class="built_in">CAGradientLayer</span> layer];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Set the frame and the anchorPoint</span></span><br><span class="line">	layer.frame = <span class="built_in">CGRectMake</span>(<span class="number">480</span>/<span class="number">2</span> - planeSize.width/<span class="number">2</span>, <span class="number">320</span>/<span class="number">2</span> - planeSize.height/<span class="number">2</span> <span class="number">-20</span>, planeSize.width, planeSize.height);</span><br><span class="line">	layer.anchorPoint = <span class="built_in">CGPointMake</span>(<span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Set borders and cornerRadius</span></span><br><span class="line">	layer.borderColor = [[<span class="built_in">UIColor</span> colorWithWhite:<span class="number">1.0</span> alpha:<span class="number">0.3</span>]<span class="built_in">CGColor</span>];</span><br><span class="line">	layer.cornerRadius = <span class="number">10</span>;</span><br><span class="line">	layer.borderWidth = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Set the gradient color for the plane background</span></span><br><span class="line">	layer.colors = [<span class="built_in">NSArray</span> arrayWithObjects:</span><br><span class="line">	              (<span class="keyword">id</span>)[<span class="built_in">UIColor</span> purpleColor].CGColor,</span><br><span class="line">	              (<span class="keyword">id</span>)[<span class="built_in">UIColor</span> redColor].CGColor,</span><br><span class="line">	              <span class="literal">nil</span>];</span><br><span class="line">	layer.locations = [<span class="built_in">NSArray</span> arrayWithObjects:</span><br><span class="line">	                 [<span class="built_in">NSNumber</span> numberWithFloat:<span class="number">0.0</span>f],</span><br><span class="line">	                 [<span class="built_in">NSNumber</span> numberWithFloat:<span class="number">1.0</span>f],</span><br><span class="line">	                 <span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Set the shadow</span></span><br><span class="line">	layer.shadowColor = [[<span class="built_in">UIColor</span> blackColor]<span class="built_in">CGColor</span>];</span><br><span class="line">	layer.shadowOpacity = <span class="number">1</span>;</span><br><span class="line">	layer.shadowRadius = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//The double side has to be setted if we want to see the plane when its face is turned back</span></span><br><span class="line">	layer.doubleSided = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Add the plane to the transformLayer</span></span><br><span class="line">	[transformLayer addSublayer:layer];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>唯一需要费点口舌的是 <code>doubleSide</code> 属性。把它设置为 <code>YES</code>，就是告诉这个对象：“嘿，把你的背面也给我涂上颜色。”所以当卡片绕着 Y 轴旋转到接近 180 度的时候，我们还是可以看到它（不然就只能看到一个黑色的东西，要是正巧背景也是黑色的话，就什么都看不到了）。<br>
为了更好的理解这句话的意思，来看看如果 <code>doubleSide</code> 是 <code>NO</code> 的话，会看到什么。<br>
<img src="/uploads/Introduction-to-3D-drawing-in-core-animation-Part-II/double_side.png" alt="double_side">￼</p>
<p>瞧，那个背对着我们的卡片的背面是全黑的（压根就没有被画出来）。</p>
<p>你可能已经注意到了，在 <code>viewDidLoad</code> 里面，我们加入了5张卡片，但是我没有给这些卡片一个指定的位置。它们只是按照在 <code>-[addPlane]</code> 方法中规定的 <code>frame</code> ，把自己在同一个位置上创建了出来而已。</p>
<h2 id="给卡片们定个位">给卡片们定个位</h2>
<p>在 viewDidLoad 里面，紧跟在卡片的创建之后，我们调用了一个方法：<code>-[animate]</code>。<br>
这个方法的主要功能就是更新卡片的位置。我们第一次调用 <code>-[animate]</code> 的时候，触摸事件还没有被触发，所以它目的就只是把卡片排列好，形成一个传送带的样子。</p>
<p>现在来看看这个方法的代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** This function performs the transformation on each plane **/</span></span><br><span class="line">- (<span class="keyword">void</span>)animate &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Define the degree needed for each plane to create a circle</span></span><br><span class="line">	<span class="keyword">float</span> degForPlane = <span class="number">360</span> / [[transformLayer sublayers] count];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//The current angle offset (initially it is 0... it will change through the pan function)</span></span><br><span class="line">	<span class="keyword">float</span> degX = angle;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">CALayer</span> *layer <span class="keyword">in</span> [transformLayer sublayers]) &#123;</span><br><span class="line">	<span class="comment">//Create the Matrix identity</span></span><br><span class="line">	<span class="built_in">CATransform3D</span> t = <span class="built_in">CATransform3DIdentity</span>;</span><br><span class="line">	<span class="comment">//Setup the perspective modifying the matrix elementat [3][4]</span></span><br><span class="line">	t.m34 = <span class="number">1.0</span>f / - <span class="number">1000.0</span>f;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Perform rotate on the matrix identity</span></span><br><span class="line">	t = <span class="built_in">CATransform3DRotate</span>(t, degToRad(degX), <span class="number">0.0</span>f, <span class="number">1.0</span>f, <span class="number">0.0</span>f);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Perform translate on the current transform matrix (identity + rotate)</span></span><br><span class="line">	t = <span class="built_in">CATransform3DTranslate</span>(t, <span class="number">0.0</span>f, <span class="number">0.0</span>f,  <span class="number">250.0</span>f);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Avoid animations</span></span><br><span class="line">	[<span class="built_in">CATransaction</span> setAnimationDuration:<span class="number">0.0</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//apply the transoform on the current layer</span></span><br><span class="line">	layer.transform = t;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Add the degree needed for the next plane</span></span><br><span class="line">	degX += degForPlane;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>defForPlane</code> 的变量表示每张卡片要旋转的角度，它是通过上一张卡片的状态计算出来的，最终会构成一个 360 度的圆。从卡片的上方往下看应该是这个样子的：<br>
<img src="/uploads/Introduction-to-3D-drawing-in-core-animation-Part-II/planes_circle.png" alt="planes_circle">￼</p>
<p>在圆周里的 5 张卡片，每一张都要旋转一定的角度。这个角度是一个从 0 开始，每次增加（360/卡片数目）的值。</p>
<p>我们先让 <code>angle</code> 这个变量暂时为零，后面再来说它。</p>
<p><code>-[animate]</code> 方法会在 <code>transformLayer</code> 的每一个子图层上面调用，也就是那五张卡片。<br>
这个循环主要的作用是让每一张卡片都做出一定的变换：<br>
首先是透视值，我们只是像上一篇文章做的那样，把 <code>m34</code> 设为某一个数值，好确保这些卡片会有一个三维的景深。<br>
而另外两个变换就需要一点计算了。<br>
我们已经讲过每张卡片需要旋转多少，但我们跳过了一个至关重要的地方。</p>
<p>如果我们只是让每张卡片旋转一下，就会看到这样的场景：<br>
<img src="/uploads/Introduction-to-3D-drawing-in-core-animation-Part-II/planes_center.png" alt="planes_center">￼</p>
<p>所以我们还要让每张卡片作出一定的位移，这样才能把每张卡片放到正确的位置上面去。</p>
<p>最后一步就是把这些变换作用到卡片上，只要吧 <code>transform</code> 设置为我们计算出来的数值就好了。<br>
<code>degX</code> 属性最后会加上一个 <code>degForPlane</code>，用来计算下一张卡片要旋转多少。</p>
<h2 id="Pan-Gesture">Pan Gesture</h2>
<p><code>-[pan]</code> 方法负责管理所有的 pan 手势。这个方法的代码长这样：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)pan:(<span class="built_in">UIPanGestureRecognizer</span>*)gesture &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Get the current translation on the X</span></span><br><span class="line">	<span class="keyword">float</span> xOffset = [gesture translationInView:<span class="keyword">self</span>.view].x;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//When gesture begin, reset the offset</span></span><br><span class="line">	<span class="keyword">if</span>(gesture.state == <span class="built_in">UIGestureRecognizerStateBegan</span>) &#123;</span><br><span class="line">		XPanOffset = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//the distance covered since the last gesture event (I slow down a bit the final rotation multiplying by 0.5)</span></span><br><span class="line">	<span class="keyword">float</span> movedBy = xOffset * <span class="number">0.5</span> - XPanOffset;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Calculate the offset from the previous gesture event</span></span><br><span class="line">	XPanOffset += movedBy;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Add the offset to the current angle</span></span><br><span class="line">	angle += movedBy;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Update the plane</span></span><br><span class="line">	[<span class="keyword">self</span> animate];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>pan 手势是持续性的，这意味着从截获到手势事件开始，<code>pan</code> 方法就会随着手指的移动而不断被调用，直到触摸屏幕的所有手指都抬了起来。</p>
<p>为了把这里面的信息转化为对我们的传送带动画有帮助的数据，我们要拿到 X 轴上的相对位移（相对于上一个位置）。<br>
我们用变量 <code>XPanOffset</code> 来暂时保存位置。当手势改变的时候，更新 <code>XPanOffset</code>，加上一个相对位移的距离。这个距离保存在变量 <code>movedBy</code> 里面，最后会被加到变量 <code>angle</code> 上。<br>
调用 <code>-[animate]</code> 方法的结果是，所有卡片都在随之旋转，并自转一个角度。</p>
<p>DONE！</p>
<h2 id="总结">总结</h2>
<p>这只是个使用纯 Core Animation 构建三维视图的简单例子，项目中真实的需求可能要复杂得多，但是 Core Animation 的强大也不止于此。<br>
现在你可以尽情去实验代码里玩耍了！</p>
<p>再一次附上原文：<a href="http://www.thinkandbuild.it/introduction-to-3d-drawing-in-core-animation-part-2">Introduction to 3D drawing in core animation (Part 2)</a></p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"8225264e14e677544541","clientSecret":"ed2a2c6d5043e9f0b41cae78b0d5b4571099de53","repo":"HexoBlogSource","owner":"davidleee","admin":["davidleee"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Translation</tag>
      </tags>
  </entry>
  <entry>
    <title>【翻译】Core Animation 3D 绘图（上）</title>
    <url>/2016/07/07/Introduction-to-3D-drawing-in-core-animation-Part-I/</url>
    <content><![CDATA[<p>这是关于 Core Animation 三维绘图的翻译文第一篇（共两篇），主要讲了 iOS 中做三维变换时所需要用到的一些基础知识，原文是 Think &amp; Build 上的 <a href="http://www.thinkandbuild.it/introduction-to-3d-drawing-in-core-animation-part-1/">Introduction to 3D drawing in core animation (Part 1)</a>。<br>
想要把玩一下完整项目的话，可以去原文中的 Github 地址中看看，不过文中附带的代码已经是项目中最核心的部分了，组合起来也可以得到一样的效果。</p>
<span id="more"></span>
<blockquote>
<p>因为翻译这篇文章的时间已经比较久远了，难免有一些错误的地方，欢迎大家指出来共同进步。</p>
</blockquote>
<p>Core Animation 可以让我们在不直接使用 OpenGL 的情况下实现某些 3D 效果，但是相对的，使用 Core Animation 来写一个复杂的 3D 游戏就不是那么明智了。</p>
<p>这一部分的文章将会探讨一下简单的 3D 绘图的理论，并且构建一个简易的 3D 场景。<br>
下一部分的文章将会用 Core Animation 来创建一个更复杂一些的 3D 场景。</p>
<p>要是想把这些代码跑起来的话，首先要记得将 QuartzCore 框架添加到项目中。</p>
<h2 id="3D-和-矩阵（外加一点点数学运算…）">3D 和 矩阵（外加一点点数学运算…）</h2>
<p>在三维空间绘图，意味着我们需要在传统的二维空间坐标系中加入一个深度，也就是我们高中数学中的 Z 轴。</p>
<p>在这个全新的坐标系中，通过改变 X、Y 和 Z 坐标的数值，我们可以将物体水平、垂直和远近移动（想象你在看着手机屏幕，距离你的脸越近的物体 Z 值越大）。<br>
<img src="/uploads/Introduction-to-3D-drawing-in-core-animation-Part-I/handed.png" alt="handed">￼</p>
<p>无论在二维还是三维空间中，要让物体产生位移或形变，比如移位、缩放和旋转，都需要经过一点数学运算。<br>
使用矩阵是做这些运算最合理的方式。</p>
<p>简单来说，矩阵就相当于多维数组。<br>
举个例子，在三维空间中，我们会使用一个 4x4 的矩阵来表示坐标：</p>
<p>[X][0][0][0]<br>
[0][Y][0][0]<br>
[0][0][Z][0]<br>
[0][0][0][1]</p>
<p>把这个矩阵跟对象每一点的坐标相乘，我们就可以让这个对象发生位移或形变。<br>
再准确一些，这个矩阵是一组比例系数。通过它，按比例地改变每一条坐标轴上的数值，以达到缩放这个对象的目的。<br>
同理，如果想要实现其他效果，例如旋转和位移，那么你只要改变一下上述矩阵中的数值就可以了。<br>
<img src="/uploads/Introduction-to-3D-drawing-in-core-animation-Part-I/headscratch.png" alt="headscratch">￼</p>
<p>莫慌！你不需要完全弄懂这些原理性的东西，而且你也基本不会直接用到。Core Animation 已经像一个黑盒一样帮你完成了这一切。</p>
<p>话说回来，了解一下代码底层到底在做些什么总归是好的。如果你想要更详细地学习一下关于矩阵的一切，可以参考<a href="http://www.matrix44.net/cms/notes/opengl-3d-graphics/basic-3d-math-matrices">这篇文章</a>。</p>
<h3 id="三维变换">三维变换</h3>
<p>现在你已经对三维空间和矩阵的作用有了一些概念，是时候用 Core Animation 创建一些东西了。<br>
下面有几个准备好了的方法，分别会做一些不同的事情，我们一个个来看。</p>
<p><code>A_singlePlane</code> 实现了一个绕Y轴旋转了45度的圆角矩形。</p>
<p>首先，我们创建一个 <code>CALayer</code> 来作为接下来的一切操作的容器（虽然不是必须的，但是感觉要比直接在一个 <code>view</code> 的 <code>layer</code> 上面操作要好）。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)A_singlePlane&#123;</span><br><span class="line">    <span class="comment">// Create the container</span></span><br><span class="line">    <span class="built_in">CALayer</span> *container = [<span class="built_in">CALayer</span> layer];</span><br><span class="line">    container.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">640</span>, <span class="number">300</span>);</span><br><span class="line">    [<span class="keyword">self</span>.view.layer addSublayer:container];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们创建另一个 <code>CALayer</code>，一个圆角矩形。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Create a Plane</span></span><br><span class="line"><span class="built_in">CALayer</span> *purplePlane =</span><br><span class="line">	[<span class="keyword">self</span> addPlaneToLayer:container</span><br><span class="line">	size:<span class="built_in">CGSizeMake</span>(<span class="number">100</span>, <span class="number">100</span>)</span><br><span class="line">	position:<span class="built_in">CGPointMake</span>(<span class="number">100</span>, <span class="number">100</span>)</span><br><span class="line">	color:[<span class="built_in">UIColor</span> purpleColor]];</span><br></pre></td></tr></table></figure>
<p>这里用到了一个工具方法，只是单纯的创建一个 <code>CALayer</code>，加到 <code>container</code> 当中，然后返回这个 <code>CALayer</code>。代码非常简单：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">CALayer</span> *)addPlaneToLayer:(<span class="built_in">CALayer</span>*)container size:(<span class="built_in">CGSize</span>)size position:(<span class="built_in">CGPoint</span>)point color:(<span class="built_in">UIColor</span>*)color &#123;</span><br><span class="line">    <span class="comment">//Initialize the layer</span></span><br><span class="line">    <span class="built_in">CALayer</span> *plane = [<span class="built_in">CALayer</span> layer];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Define position,size and colors</span></span><br><span class="line">    plane.backgroundColor = [color <span class="built_in">CGColor</span>];</span><br><span class="line">    plane.opacity = <span class="number">0.6</span>;</span><br><span class="line">    plane.frame = <span class="built_in">CGRectMake</span>(point.x, point.y, size.width, size.height);</span><br><span class="line">    plane.borderColor = [[<span class="built_in">UIColor</span> colorWithWhite:<span class="number">1.0</span> alpha:<span class="number">0.5</span>]<span class="built_in">CGColor</span>];</span><br><span class="line">    plane.borderWidth = <span class="number">3</span>;</span><br><span class="line">    plane.cornerRadius = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Add the layer to the container layer</span></span><br><span class="line">    [container addSublayer:plane];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> plane;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后我们用 <code>CATransform3D</code> 来完成这个变换。<br>
什么是 <code>CATransform3D</code>？Cmd + click 这个数据类型，你会发现这是一个结构体，代表着一个有点奇怪的矩阵：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="built_in">CATransform3D</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">CGFloat</span> m11, m12, m13, m14;</span><br><span class="line">  <span class="built_in">CGFloat</span> m21, m22, m23, m24;</span><br><span class="line">  <span class="built_in">CGFloat</span> m31, m32, m33, m34;</span><br><span class="line">  <span class="built_in">CGFloat</span> m41, m42, m43, m44;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="built_in">CATransform3D</span> <span class="built_in">CATransform3D</span>;</span><br></pre></td></tr></table></figure>
<p>真正产生变换作用的代码也是非常简单：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Apply the transform to the PLANE</span></span><br><span class="line"><span class="built_in">CATransform3D</span> t = <span class="built_in">CATransform3DIdentity</span>;</span><br><span class="line">t = <span class="built_in">CATransform3DRotate</span>(t, <span class="number">45.0</span>f * M_PI / <span class="number">180.0</span>f, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">purplePlane.transform = t;</span><br></pre></td></tr></table></figure>
<p>首先用 <code>CATransform3DIdentity</code> 来初始化一个 <code>CATransform3D</code>，这个 <code>CATransform3DIdentity</code> 相当于是一个空值。然后我们通过 <code>CATransform3DRotate</code> 这个方法来完成前面提到过的“与旋转矩阵相乘”这个步骤。</p>
<p>这个方法需要几个参数：一个初始矩阵、旋转角（弧度制）和三个坐标轴的影响系数（表示产生多少作用的一个比例系数）。在这个例子中，X 和 Z 轴没有被影响到，而 Y 轴是完全被影响…简而言之，这个对象最后是绕着Y轴旋转了 45 度。</p>
<p>下图就是这个例子的最终效果：<br>
<img src="/uploads/Introduction-to-3D-drawing-in-core-animation-Part-I/pa1.png" alt="pa1">￼</p>
<p>嗯…？它完全不像一个三维图啊！我们只看到了一个沿着 X 轴压缩了一点的矩形。</p>
<p>问题在于我们没有设置它的 <strong>透视数值( perspective value )</strong>。通常我们会用正面投影的方法来实现平面上的三维画面，但是这样产生的是一个变平了的三维图像。换句话说，用了正面投影之后，你就难以察觉 Z 轴变化带来的景深变化了。</p>
<p>为了给我们的画面添加景深，我们要调整变换矩阵的 <code>m34</code> 数值，这个变量决定了视图的透视值。<br>
代码跟前面的很像，只有变换的部分有些不同：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Apply transformation to the PLANE</span></span><br><span class="line"><span class="built_in">CATransform3D</span> t = <span class="built_in">CATransform3DIdentity</span>;</span><br><span class="line"><span class="comment">//Add the perspective!!!</span></span><br><span class="line">t.m34 = <span class="number">1.0</span>/ <span class="number">-500</span>;</span><br><span class="line">t = <span class="built_in">CATransform3DRotate</span>(t, <span class="number">45.0</span>f * M_PI / <span class="number">180.0</span>f, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">purplePlane.transform = t;</span><br></pre></td></tr></table></figure>
<p>我们可以像这样直接改变 <code>m34</code> 属性的值。<br>
就不继续深入研究这个值带来的数学上的影响了，但是要大概明确一点，这个值越接近于零，透视就越明显。<br>
下面是不同 <code>m34</code> 值对应的不同结果：<br>
<img src="/uploads/Introduction-to-3D-drawing-in-core-animation-Part-I/pa2_1.png" alt="pa2_1">￼<br>
<img src="/uploads/Introduction-to-3D-drawing-in-core-animation-Part-I/pa2_2.png" alt="pa2_2">￼</p>
<h3 id="三维变换链">三维变换链</h3>
<p>为了给单一的对象套上不止一种变换，我们可以通过矩阵相乘的方式来实现。</p>
<p>举个例子，如果我们想同时把对象旋转一下并移开一点，我们可以这样构造我们的变换矩阵：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TransformMatrix = TranslateMtx * RotateMtx</span><br></pre></td></tr></table></figure>
<p>在数学上，乘法是满足交换律的，但是矩阵相乘 <strong>不满足交换律</strong>！也就是说，AxB 不等于 BxA。这一点必须要牢记在心！</p>
<p>下面这个例子中，我们会对两个不同的对象施以相同的变换，但是变换的顺序不一样。看看主要的代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Apply transformation to the PLANES</span></span><br><span class="line"><span class="built_in">CATransform3D</span> t = <span class="built_in">CATransform3DIdentity</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Purple plane: Perform a rotation and then a translation</span></span><br><span class="line">t = <span class="built_in">CATransform3DRotate</span>(t, <span class="number">45.0</span>f * M_PI / <span class="number">180.0</span>f, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">t = <span class="built_in">CATransform3DTranslate</span>(t, <span class="number">100</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">purplePlane.transform = t;</span><br><span class="line"></span><br><span class="line"><span class="comment">//reset the transform matrix</span></span><br><span class="line">t = <span class="built_in">CATransform3DIdentity</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Red plane: Perform translation first and then the rotation</span></span><br><span class="line">t = <span class="built_in">CATransform3DTranslate</span>(t, <span class="number">100</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">t = <span class="built_in">CATransform3DRotate</span>(t, <span class="number">45.0</span>f * M_PI / <span class="number">180.0</span>f, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">redPlane.transform = t;</span><br></pre></td></tr></table></figure>
<p>看看结果：<br>
<img src="/uploads/Introduction-to-3D-drawing-in-core-animation-Part-I/pa3.png" alt="pa3">￼</p>
<p>瞧瞧，不一样了吧。</p>
<p>来看看紫色的方块：我们先对它进行了一次旋转变换，这引起了它坐标系的旋转。<br>
下一步，我们改变了紫色方块的 X 坐标，这一改变是在新坐标系上进行的，所以结果就是跟红色方块不一样了。</p>
<p>下面的图片应该可以让你有一个更形象的概念：<br>
<img src="/uploads/Introduction-to-3D-drawing-in-core-animation-Part-I/pa4.png" alt="pa4">￼<br>
<img src="/uploads/Introduction-to-3D-drawing-in-core-animation-Part-I/pa5.png" alt="pa5">￼</p>
<h2 id="图层层次（Layer-Hierarchies）是个啥？">图层层次（Layer Hierarchies）是个啥？</h2>
<p>不知道你注意到了没，到现在为止，我们都是直接对这些方块对象实施变换的。在一个三维场景中，通常是创建一组对象，组成一个带有层次感的画面，然后对层次的根对象进行变换。</p>
<p>再举个栗子。</p>
<p>我们把 4 个方块加入到容器里面。<br>
不进行任何变换，看起来就像这个样子：<br>
<img src="/uploads/Introduction-to-3D-drawing-in-core-animation-Part-I/pa6.png" alt="pa6">￼</p>
<p>接着，对每一个方块都进行一次绕 Y 轴的旋转，我们会看到如下画面：<br>
<img src="/uploads/Introduction-to-3D-drawing-in-core-animation-Part-I/pa7.png" alt="pa7">￼</p>
<p>然而，如果这个变换是直接作用在容器图层上的，景色又完全不同了：<br>
<img src="/uploads/Introduction-to-3D-drawing-in-core-animation-Part-I/pa8.png" alt="pa8">￼</p>
<p>我们可以把最后面这幅图看作是摄像机位置的改变。也就是说，我们没有移动这些方块，而是我们的视角改变了。</p>
<p>上述的两种变换对应下面的代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Transformation</span></span><br><span class="line"><span class="built_in">CATransform3D</span> t = <span class="built_in">CATransform3DIdentity</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span> applyToContainer = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Apply the transformation to each PLANE</span></span><br><span class="line"><span class="keyword">if</span>(!applyToContainer)&#123;</span><br><span class="line">    t.m34 = <span class="number">1.0</span> / <span class="number">-500.0</span>;</span><br><span class="line">    t = <span class="built_in">CATransform3DRotate</span>(t, degToRad(<span class="number">60.0</span>), <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    purplePlane.transform = t;</span><br><span class="line"></span><br><span class="line">    t = <span class="built_in">CATransform3DIdentity</span>;</span><br><span class="line">    t.m34 = <span class="number">1.0</span> / <span class="number">-500.0</span>;</span><br><span class="line">    t = <span class="built_in">CATransform3DRotate</span>(t, degToRad(<span class="number">60.0</span>), <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    redPlane.transform = t;</span><br><span class="line"></span><br><span class="line">    t = <span class="built_in">CATransform3DIdentity</span>;</span><br><span class="line">    t.m34 = <span class="number">1.0</span> / <span class="number">-500.0</span>;</span><br><span class="line">    t = <span class="built_in">CATransform3DRotate</span>(t, degToRad(<span class="number">60.0</span>), <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    orangePlane.transform = t;</span><br><span class="line"></span><br><span class="line">    t = <span class="built_in">CATransform3DIdentity</span>;</span><br><span class="line">    t.m34 = <span class="number">1.0</span> / <span class="number">-500.0</span>;</span><br><span class="line">    t = <span class="built_in">CATransform3DRotate</span>(t, degToRad(<span class="number">60.0</span>), <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    yellowPlane.transform = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Apply the transformation to the CONTAINER</span></span><br><span class="line"><span class="keyword">else</span>&#123;    </span><br><span class="line">    <span class="built_in">CATransform3D</span> t = <span class="built_in">CATransform3DIdentity</span>;</span><br><span class="line">    t.m34 = <span class="number">1.0</span>/<span class="number">-500</span>;</span><br><span class="line">    t = <span class="built_in">CATransform3DRotate</span>(t, degToRad(<span class="number">60.0</span>), <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    container.transform = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="来认识一下-CATransformLayer">来认识一下 CATransformLayer</h2>
<p>目前为止一切看起来都很顺利。不过，其实 <code>CALayer</code> 并不适合作为三维图层层次的根。</p>
<p>来看看为什么。</p>
<p>现在我们创建 4 个 X、Y 坐标都一样的方块，唯一不同的是它们的 Z 坐标。<br>
紫色方块是距离你最近的，黄色方块时距离你最远的。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Apply transforms to the PLANES</span></span><br><span class="line">t = <span class="built_in">CATransform3DIdentity</span>;</span><br><span class="line">t = <span class="built_in">CATransform3DTranslate</span>(t, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-10</span>);</span><br><span class="line">purplePlane.transform = t;</span><br><span class="line"></span><br><span class="line">t = <span class="built_in">CATransform3DIdentity</span>;</span><br><span class="line">t = <span class="built_in">CATransform3DTranslate</span>(t, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-50</span>);</span><br><span class="line">redPlane.transform = t;</span><br><span class="line"></span><br><span class="line">t = <span class="built_in">CATransform3DIdentity</span>;</span><br><span class="line">t = <span class="built_in">CATransform3DTranslate</span>(t, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-90</span>);</span><br><span class="line">orangePlane.transform = t;</span><br><span class="line"></span><br><span class="line">t = <span class="built_in">CATransform3DIdentity</span>;</span><br><span class="line">t = <span class="built_in">CATransform3DTranslate</span>(t, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-130</span>);</span><br><span class="line">yellowPlane.transform = t;</span><br></pre></td></tr></table></figure>
<p>然后，我们像之前那样让整个容器旋转一下。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Apply transform to the CONTAINER</span></span><br><span class="line"><span class="built_in">CATransform3D</span> t = <span class="built_in">CATransform3DIdentity</span>;</span><br><span class="line">t.m34 = <span class="number">1.0</span>/<span class="number">-500</span>;</span><br><span class="line">t = <span class="built_in">CATransform3DRotate</span>(t, <span class="number">80.0</span>f * M_PI / <span class="number">180.0</span>f, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">container.transform = t;</span><br></pre></td></tr></table></figure>
<p>是不是觉得应该要看到这个场景：<br>
<img src="/uploads/Introduction-to-3D-drawing-in-core-animation-Part-I/pa9.png" alt="pa9">￼</p>
<p>但结果却是：<br>
<img src="/uploads/Introduction-to-3D-drawing-in-core-animation-Part-I/pa10.png" alt="pa10">￼</p>
<p>这是因为，<code>CALayer</code> 并不能处理三维图层层次的景深，所以它只是把所有的东西在同一个 Z 平面上压扁了。</p>
<p>为了达到预想的效果，我们要用 <code>CATransformLayer</code> 来作为根对象。</p>
<p>Bug fixed:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Create the container as a CATransformLayer</span></span><br><span class="line"><span class="built_in">CATransformLayer</span> *container = [<span class="built_in">CATransformLayer</span> layer];</span><br><span class="line">container.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">640</span>, <span class="number">300</span>);</span><br><span class="line">[<span class="keyword">self</span>.view.layer addSublayer:container];</span><br></pre></td></tr></table></figure>
<p>要记住，<code>CATransformLayer</code> 是一个特殊的图层，与 <code>CALayer</code> 非常不同的是，它只会渲染自己的子图层，而 <code>backgroundColor</code>、<code>contents</code>、<code>border</code> 等等这些属性则会被完全忽略掉。</p>
<h2 id="总结">总结</h2>
<p>那么第一部分的内容翻译就到此为止了，下半部分也会在整理好之后的第一时间放出来。建议大家去玩玩这些代码，最好试试看上面没有提到的 <code>CATransform3DScale</code> 咯。</p>
<p>再一次附上原文：<a href="http://www.thinkandbuild.it/introduction-to-3d-drawing-in-core-animation-part-1/">Introduction to 3D drawing in core animation (Part 1)</a></p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"8225264e14e677544541","clientSecret":"ed2a2c6d5043e9f0b41cae78b0d5b4571099de53","repo":"HexoBlogSource","owner":"davidleee","admin":["davidleee"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Translation</tag>
      </tags>
  </entry>
  <entry>
    <title>SVG 从“完全不懂”到“足够开个入门分享”</title>
    <url>/2018/10/25/SVG-from-nothing-to-something/</url>
    <content><![CDATA[<p>最近需要在 React-Native 项目里实现一个填满特定图形的效果，找很久都没发现能满足需求的开源库，于是就打算用 SVG 自己怼一个。好在这方面教程还不少，虽然不能一步到位，但几篇文章加一起也能把效果实现出来，于是在这里把入门过程记录一下，希望帮后来者省点功夫。</p>
<span id="more"></span>
<h2 id="SVG-是个啥？">SVG 是个啥？</h2>
<p>SVG（Scalable Vector Graphics） 是一种基于 XML 语法的图像格式。跟基于像素处理的图片格式不同，它是基于对图像形状的描述来实现的，本质上是一个文本文件，体积上较小，而且在放大的时候也不会失真。</p>
<p>因为 SVG 是基于 XML 语法的，所以对于前端开发者来说，写起来应该比较顺手；对于 React-Native 的项目，因为 JSX 的关系，用起 SVG 来也是没有“语言障碍”的。</p>
<h2 id="SVG-长什么样？">SVG 长什么样？</h2>
<p>直接上源码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&#x27;100&#x27;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span> <span class="attr">viewBox</span>=<span class="string">&quot;0 0 100 100&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">xmlns:xlink</span>=<span class="string">&quot;http://www.w3.org/1999/xlink&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">defs</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">clipPath</span> <span class="attr">id</span>=<span class="string">&quot;heart&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">&quot;M81.495,13.923c-11.368-5.261-26.234-0.311-31.489,11.032C44.74,13.612,29.879,8.657,18.511,13.923  C6.402,19.539,0.613,33.883,10.175,50.804c6.792,12.04,18.826,21.111,39.831,37.379c20.993-16.268,33.033-25.344,39.819-37.379  C99.387,33.883,93.598,19.539,81.495,13.923z&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">clipPath</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">defs</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&#x27;0&#x27;</span> <span class="attr">y</span>=<span class="string">&#x27;0&#x27;</span> <span class="attr">fill</span>=<span class="string">&#x27;rgb(217,217,217)&#x27;</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">clip-path</span>=<span class="string">&quot;url(#heart)&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&#x27;0%&#x27;</span> <span class="attr">y</span>=<span class="string">&quot;50%&quot;</span> <span class="attr">fill</span>=<span class="string">&#x27;red&#x27;</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">clip-path</span>=<span class="string">&quot;url(#heart)&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这张 SVG 图渲染出来是这样的：<br>
<img src="/uploads/SVG-from-nothing-to-something/57D524DA-6FD7-4538-A238-B002D099D91A.png" alt=""></p>
<blockquote>
<p>直接把上面的代码保存为文本，就可以用浏览器打开并显示了。macOS 的用户还可以直接空格预览。</p>
</blockquote>
<p>配合一些参数的改变，做动画也是分分钟的事情。对于之前没有怎么用过 SVG 的我来说，简直是打开了新世界的大门。</p>
<p>接下来就让我们一起探究一下上面这个图是怎么来的。</p>
<h2 id="SVG-显示原理">SVG 显示原理</h2>
<p>根据上面的例子，我们可以大胆猜测一下： <code>&lt;path&gt;</code> 标签下 <code>d</code> 属性的值就是用来描绘这个心形的外框路径的。既然描绘路径已经是确定的了，那一张 SVG 图片是怎么实现缩放不失真的特性的呢？<br>
要回答这个问题，就要让我们先了解一下 SVG 的一些基本显示原理。</p>
<h3 id="The-SVG-Canvas">The SVG Canvas</h3>
<p>假设我们要将一个 SVG 图形绘制到一张画布（Canvas）上，概念上这张画布应该是无限大的，这样我们的图形才可以是任意大小。然而，实际上 SVG 图片是显示在一个有限的区域里的，就像我们透过窗户看窗外的风景一样，这个有限区域被称为“观察孔”（Viewport）。</p>
<h3 id="The-Viewport">The Viewport</h3>
<p>“观察孔”指的是 SVG 图片可见的那一部分，想象我们透过窗户看窗外的风景，这个窗子就是外面风景的观察孔。</p>
<blockquote>
<p>类似的，我们在浏览网页的时候面对的也是这种情况，网页的大小通常比浏览器的窗口要大，这时候浏览器就是这个网页的观察孔了。</p>
</blockquote>
<p>我们通过设置 <code>&lt;svg&gt;</code> 标签的 <code>width</code> 和 <code>height</code> 属性来确定这张 SVG 的观察孔大小，对于上面的心形来说，观察孔是 100x100 的正方形：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- the viewport will be 100px by 100px --&gt;</span><br><span class="line">&lt;svg width=&quot;100&quot; height=&quot;100&quot;&gt;</span><br><span class="line">		&lt;!-- SVG content drawn onto the SVG canvas --&gt;</span><br><span class="line">&lt;/svg&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在 SVG 里，数值的单位是可选的。在我们不主动提供的时候，默认会以 <code>px</code> 为单位。可选的单位有 <code>em</code>、<code>ex</code>、<code>px</code>、<code>pt</code>、<code>pc</code>、<code>cm</code>、<code>mm</code>、<code>in</code> 和百分比。</p>
</blockquote>
<h3 id="坐标系统">坐标系统</h3>
<p>在观察孔的大小确定下来之后，SVG 就会建立一套初始的坐标系统：以最左上角为 <code>(0, 0)</code> 点，x 轴和 y 轴分别向右和向下延伸（就像移动客户端和网页显示里那样）。在这个基础上，我们刚刚创建的观察孔也就有了属于自己的一套位置标识：<code>(x: 0, y: 0, width: 100, height: 100)</code>。</p>
<h2 id="The-viewbox">The <code>viewbox</code></h2>
<p>在了解了上述知识之后，我们就可以来说说 <code>viewbox</code> 这个属性了。</p>
<p>我们可以把 <code>viewbox</code> 理解为“真正的坐标系统”，因为它决定了 SVG 图形是怎么绘制到画布上的。一个 SVG 图形的大小可以与观察孔不一样，它可能会完整地显示出来，也可能会被观察孔裁减掉一部分。</p>
<blockquote>
<p>就像一张普通图片一样，当你需要把图形完整地放进一个视图里面时，可以调节图片的拉伸模式，一边让图片的大小更为合理。SVG 里对应的属性是 <code>preserveAspectRatio</code>。</p>
</blockquote>
<p><code>viewbox</code>  会一次性设置4个参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;svg viewbox=&quot;&lt;min-x&gt; &lt;min-y&gt; &lt;width&gt; &lt;height&gt;&quot;&gt;&lt;/svg&gt;</span><br></pre></td></tr></table></figure>
<p>其中，<code>&lt;min-x&gt;</code> 和 <code>&lt;min-y&gt;</code> 不能设置为负数，<code>&lt;width&gt;</code> 和 <code>&lt;height&gt;</code> 设置为 0 的话，元素就压根不会绘制了。</p>
<p>所以说，<code>viewbox=&quot;0 0 100 100&quot;</code> 就做了下面几件事情：</p>
<ol>
<li>在画布上划分出来一个 100x100 大小的区域，放在 (0, 0) 点上</li>
<li>把 SVG 图形缩放成合适这个区域的样子</li>
<li>将整个区域（包括里面的图形）放大到铺满整个观察孔</li>
<li>将这个坐标系统<strong>按比例</strong>映射到到初始坐标系统上</li>
</ol>
<p>那对于上面的爱心图片来说，我们尝试调整一下 <code>viewbox</code> 的原点，将它设置为 <code>viewbox=&quot;50 50 100 100&quot;</code> 试试：<br>
<img src="/uploads/SVG-from-nothing-to-something/353B4442-E68D-4F8A-8D53-CE5EEED21F36.png" alt=""><br>
可以看到，就像地图软件一样，镜头往画面的右下方移动了一段。这也相当于把整个画面往左上方推了过去一点，我们可以通过设置画布的 <code>transform</code> 属性来实现相同的效果：<code>transform=&quot;translate(-50 -50)&quot;</code>。</p>
<blockquote>
<p>当设计师给你一张 SVG 图片的时候，其中的图案路径可能是按照一定的大小和位移来绘制的，比如从(10, 10) 点开始画的一张 40x40 的图，这时候你的 <code>viewbox</code> 就应该设置为 <code>viewbox=&quot;10 10 40 40&quot;</code> ，让图片放到最合适的坐标系统上。</p>
</blockquote>
<h2 id="小结">小结</h2>
<p>上面的例子演示了一张 SVG 图的常规操作，限于篇幅原因，还有一些有意思的情况没有展示到，比如当 <code>viewbox</code> 里设置的宽高比与我们在 <code>&lt;svg&gt;</code> 标签里设置的宽高比不一样会发生什么呢？这种情况下，就需要我们去了解一下 <code>preserveAspectRatio</code> 属性了。</p>
<p>在参考文章 <a href="https://www.sarasoueidan.com/blog/svg-coordinate-systems/">Understanding SVG Coordinate Systems and Transformations (Part 1) </a> 里，有对这方面更详细的解释，而且作者还提供了非常直观的在线预览工具，相信会对偏向于使用图像思维的同学们更有帮助。</p>
<h2 id="参考文章">参考文章</h2>
<ul>
<li><a href="https://www.sarasoueidan.com/blog/svg-coordinate-systems/">Understanding SVG Coordinate Systems and Transformations (Part 1) </a></li>
<li><a href="http://www.ruanyifeng.com/blog/2018/08/svg.html">SVG 图像入门教程 - 阮一峰的网络日志</a></li>
</ul>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"8225264e14e677544541","clientSecret":"ed2a2c6d5043e9f0b41cae78b0d5b4571099de53","repo":"HexoBlogSource","owner":"davidleee","admin":["davidleee"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>svg</tag>
        <tag>xml</tag>
        <tag>markup</tag>
        <tag>react-native</tag>
        <tag>viewbox</tag>
        <tag>clippath</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】符号化iOS崩溃报告</title>
    <url>/2018/03/08/Symbolicating-Your-iOS-Crash-Reports/</url>
    <content><![CDATA[<blockquote>
<p>原文链接：<a href="https://possiblemobile.com/2015/03/symbolicating-your-ios-crash-reports/">Symbolicating Your iOS Crash Reports</a></p>
</blockquote>
<p>你拿到一份 App 的崩溃报告，结果发现里面全是难以理解的内存地址。作为一名合格的开发，应该做些什么呢？简单来说，你需要把调试符号应用到崩溃日志上，让它变得更可读，这个过程叫做符号化（Symbolication）。</p>
<span id="more"></span>
<p>崩溃报告通常是一个 <code>.crash</code> 格式的文件。要拿到这个玩意儿有这几种方式：</p>
<ol>
<li>从 iTunes Connect 上获取</li>
<li>通过 Xcode 从连接的设备上直接获取（Windows -&gt; Devices）</li>
<li>直接从连接设备上获取（ iOS 11 上的位置是：设置 -&gt; 隐私 -&gt; 分析）</li>
<li>通过第三方的框架去获取</li>
</ol>
<p>如果你已经在用第三方的崩溃收集服务的话，崩溃日志应该已经是符号化之后的可读格式了。</p>
<p>然后我们还需要拿到下面两个文件之一，来帮我们定位问题：</p>
<ol>
<li>崩溃应用的 <code>.app</code> 文件。这个包里面存有应用的二进制文件，可能还直接保存了调试符号（如果你手上的是 <code>.ipa</code> 文件，你可以直接把它当成一个压缩包去解压，里面会找到 <code>.app</code> 文件的）</li>
<li>编译崩溃应用时生成的 <code>.dSYM</code> 文件。如果你编译应用的时候，没有指定把调试符号添加到 <code>.app</code> 文件里，那它们就会把这些符号单独放到这个 <code>.dSYM</code> 文件里</li>
</ol>
<p>到底要拿哪一个呢？到 Xcode 项目里的 Build Setting 里面找一个叫 “Strip Debug Symbols During Copy”（<code>COPY_PHASE_STRIP</code>） 的字段，如果它是 <code>YES</code> 的话，调试符号就会从 <code>.app</code> 文件里剔除，并放到 <code>.dSYM</code> 文件里面。</p>
<blockquote>
<p>默认情况下，出于代码混淆的考虑，打包 release 版本的时候调试信息会被放到 <code>.dSYM</code> 文件里。</p>
</blockquote>
<h2 id="等等，调试符号是什么鬼？">等等，调试符号是什么鬼？</h2>
<p>从程序员的角度看，调试符号就相当于我们给方法起的那个可读性高的名字。为了提高代码的混淆度，编译器会在编译过程中把我们的调试符号替换成它自己的。而且编译器每一次编译都可能会改变它自己的符号，即使我们的代码完全没有变化。</p>
<h2 id="开始调试崩溃">开始调试崩溃</h2>
<p>如果你是从 Xcode 的 Organizer 里拿到的崩溃日志，那它里面与 iOS 框架（UIKit 等）相关的部分可能已经被符号化了，而且如果 Xcode 还记得这一次编译的话，整个崩溃日志的符号化过程也可以省掉了。</p>
<p>那在没那么好运的情况下呢？</p>
<h3 id="Symbolicatecrash-工具">Symbolicatecrash 工具</h3>
<p>最简单的方式就是使用苹果官方提供的 Symbolicatecrash 工具了，本质上它就是一个脚本，可以帮我们拿到调试符号并应用到指定的崩溃日志上。</p>
<p>在 Xcode 7.3 之后，这个工具在这个位置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/Applications/Xcode.app/Contents/SharedFrameworks/DVTFoundation.framework/Versions/A/Resources/symbolicatecrash</span><br></pre></td></tr></table></figure>
<p>在 Xcode 6 到 7.2 的版本下，它在这里：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/Applications/Xcode.app/Contents/SharedFrameworks/DTDeviceKitBase.framework/Versions/Current/Resources/symbolicatecrash</span><br></pre></td></tr></table></figure>
<p>如果是更早的版本，可以到这里碰碰运气：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/PrivateFrameworks/DTDeviceKitBase.framework/Versions/Current/Resources/symbolicatecrash</span><br></pre></td></tr></table></figure>
<p>用这个工具之前，要先配置一个环境变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export DEVELOPER_DIR=”/Applications/Xcode.app/Contents/Developer”</span><br></pre></td></tr></table></figure>
<p>然后把 <code>.crash</code>、<code>.app</code> 和 <code>.dSYM</code> 文件都放到同一个目录下，并执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">symbolicatecrash &lt;#YourAppName&gt;.crash &gt; Symbolicated.crash</span><br><span class="line"></span><br><span class="line">// 如果需要明确指定应用二进制文件的话...</span><br><span class="line">// symbolicatecrash &lt;#YourAppName&gt;.crash ./&lt;#YourAppName&gt;.app/&lt;#YourAppName&gt; &gt; Symbolicated.crash</span><br></pre></td></tr></table></figure>
<h3 id="验证文件是否正确">验证文件是否正确</h3>
<p>如果符号化的过程碰到了问题，可以加上 <code>-v</code> 参数让 Symbolicatecrash 告诉我们更多信息。大多数情况下是因为 <code>.dSYM</code> 文件或者 <code>.app</code> 文件拿错了，可以用下面的指令来验证一下 UUID 是否正确：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// App 文件</span><br><span class="line">dwarfdump -u &lt;#YourAppName&gt;.app/&lt;#YourAppName&gt;</span><br><span class="line"></span><br><span class="line">// dSYM 文件</span><br><span class="line">dwarfdump -u &lt;#YourAppName&gt;.app.dSYM/Contents/Resources/DWARF/&lt;#YourAppName&gt;</span><br></pre></td></tr></table></figure>
<p>对比看看两次输出的 UUID 是不是一致的，然后看看崩溃日志里的 UUID 是不是输出的这一个。</p>
<h3 id="定位-Symbolicatecrash-的问题">定位 Symbolicatecrash 的问题</h3>
<p>经过上面的步骤之后，如果还是没法输出有效的信息，那就要仔细看看符号化之后的日志了。官方符号化的工具会尝试寻找与崩溃 App 的 UUID 相匹配的文件和动态库，如果符号化失败的话，从输出的日志里确认它寻找的 App 名称和 UUID 是不是你要的。一般来说，会有这样的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">......fetching symbol file for Crasher[K–[undef] Searching []…– NO MATCH Searching in Spotlight for dsym with UUID of b00cdf0c29653095b1e86078b12d79e5 ... Number of symbols in /Users/You/Workspace/Crasher.app/Crasher: 1 + 106 = 107 Found executable /Users/You/Workspace/Crasher.app/Crasher — MATCH</span><br></pre></td></tr></table></figure>
<p>如果 Spotlight 找不到 <code>.dSYM</code> 文件，输出是这样子的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Did not find executable for dsym Warning: Can’t find any unstripped binary that matches version of /private/var/mobile/Containers/Bundle/Application/956755E3-6C66-4E87-A8BC-352FD4BE3711/Crasher.app/Crasher</span><br></pre></td></tr></table></figure>
<p>如果 <code>.dSYM</code> 文件有问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Number of symbols in ./Crasher: + = 0 ./Crasher appears to be stripped, skipping.</span><br></pre></td></tr></table></figure>
<p>非法输入的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fatal error: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/lipo: can’t figure out the architecture type of: ./Crasher.app.dSYM.zip ./Crasher.app.dSYM.zip doesn’t contain armv7 slice</span><br></pre></td></tr></table></figure>
<p>Xcode 6 上的 <code>symbolicatecrash</code> 会尝试修复 Xcode 5 上没办法解决的 Spotlight 问题，如果你的 <code>symbolicatecrash</code> 版本比较旧，可以尝试手动修复一下 Spotlight 的索引问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mdimport -g /Applications/Xcode.app/Contents/Library/Spotlight/uuid.mdimporter</span><br></pre></td></tr></table></figure>
<h3 id="命令行工具链">命令行工具链</h3>
<p>让我们再深入一步，使用命令行工具去一行行符号化堆栈信息。</p>
<p>先看一行崩溃日志里的堆栈信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">... 13 Crasher 0x000aeef6 0xa8000 + 28406 ...</span><br></pre></td></tr></table></figure>
<p>第一段十六进制数（<code>0x000aeef6</code>）是栈地址。第二段十六进制数（<code>0xa8000</code>）是程序加载地址。接下来的运算操作（<code>+ 28406</code>）是一个十进制的加法操作，这三个信息表示了一个等式：0x000aeef6 = 0xa8000 + 0x6EF6（== 28406）。</p>
<p>顺着崩溃日志往下看，会发现 “Binary Images” 这个字段的内容里包含了我们的程序加载地址，它代表了崩溃应用里加载了的一系列动态库占用的内存地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Binary Images: 0xa8000 – 0xaffff Crasher armv7 /var/mobile/Containers/Bundle/Application/956755E3-6C66-4E87-A8BC-352FD4BE3711/Crasher.app/Crasher</span><br></pre></td></tr></table></figure>
<p>接下来，我们还需要看看崩溃应用的可执行文件的编译架构，可以用 <code>file</code> 或 <code>lipo -info</code> 命令查看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file Crasher.app/Crasher</span><br></pre></td></tr></table></figure>
<p>输出会是这个样子的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Crasher.app/Crasher: Mach-O universal binary with 2 architectures Crasher.app/Crasher (for architecture armv7): Mach-O executable arm Crasher.app/Crasher (for architecture arm64): Mach-O 64-bit executable</span><br></pre></td></tr></table></figure>
<p>现在我们知道所有需要的信息了。使用 <code>atos</code> 指令，可以把地址信息转化为调试符号：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">atos -arch armv7 -o Crasher.app/Crasher -l 0xa8000 0x000aeef6</span><br></pre></td></tr></table></figure>
<p>这里我们需要知道的参数是：应用的编译架构、应用位置、加载地址和栈地址。</p>
<p>输出会是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main (in Crasher) (main.m:14)</span><br></pre></td></tr></table></figure>
<p>完成！如果你还有兴趣继续深入，可以了解一下 Mach-O 对象文件的格式，并尝试使用以下 Mach-O 相关的命令行工具，比如 <code>otool</code> 和 <code>lipo</code>。</p>
<h2 id="延伸阅读">延伸阅读</h2>
<ul>
<li><a href="https://developer.apple.com/library/ios/technotes/tn2151/_index.html#//apple_ref/doc/uid/DTS40008184">Technical Note TN2151: Understanding and Analyzing iOS Application Crash Reports</a></li>
<li><a href="https://developer.apple.com/library/ios/qa/qa1765/_index.html#//apple_ref/doc/uid/DTS40012196">Technical Q&amp;A QA1765: How to Match a Crash Report to a Build</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/DeveloperTools/Conceptual/MachOTopics/0-Introduction/introduction.html">Mach-O Programming Topics</a></li>
<li><a href="http://www.objc.io/issue-6/mach-o-executables.html">Objc.io on Mach-O Executables</a></li>
</ul>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"8225264e14e677544541","clientSecret":"ed2a2c6d5043e9f0b41cae78b0d5b4571099de53","repo":"HexoBlogSource","owner":"davidleee","admin":["davidleee"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Crash</tag>
      </tags>
  </entry>
  <entry>
    <title>小心避开 RxSwift 里的坑（Top Mistakes in RxSwift you want to avoid）</title>
    <url>/2018/04/24/Top-Mistakes-in-RxSwift/</url>
    <content><![CDATA[<p>每当我们要学习一样新的语言或者框架时，总是会犯下这样那样的错误。这就是人类学习新知识的方法。下文列出了一些使用 RxSwift 过程中常见的错误，供大家参考。</p>
<span id="more"></span>
<p>原文链接在文末。</p>
<h2 id="combineLatest-vs-withLatestFrom">combineLatest vs withLatestFrom</h2>
<p>前者会在内部的任意一个 Observable 发出消息时发出一个总的消息，所以把两个按钮的 tap 事件 combineLatest 不是一个合理的做法。这种情况就要看看后者的使用方式了。</p>
<h2 id="Observable-应该延迟初始化">Observable 应该延迟初始化</h2>
<p>当一个 Observable 是为了把耗时操作的结果通知出去时，这个 Observable 本身应该被延迟初始化，这样才能避免在有人 subscribe 之前就在做那个耗时操作。<br>
举个栗子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rx_myFunction</span>()</span> -&gt; <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> someCalculationResult: <span class="type">Int</span> <span class="operator">=</span> calculate()</span><br><span class="line">    <span class="keyword">return</span> .just(someCalculationResult)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>calculte()</code> 是一个耗时操作，这样用户在调用这个方法的时候就已经在跑真正的计算了，而我们写这个方法的本意应该是有人 subscribe 的时候才去执行操作。所以上面的方法应该做一下这样的小修改：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rx_myFunction</span>()</span> -&gt; <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Observable</span>.deferred &#123;</span><br><span class="line">        <span class="keyword">let</span> someCalculationResult: <span class="type">Int</span> <span class="operator">=</span> <span class="keyword">self</span>.calculate()</span><br><span class="line">        <span class="keyword">return</span> .just(someCalculationResult)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="DisposeBag-的错误使用">DisposeBag 的错误使用</h2>
<p>这玩意儿的作用是把一堆 <code>Disposable</code> 在某个对象 <code>deinit</code> 的时候全部结束掉，所以这个管理对象的选择就尤为重要。</p>
<p>比如我们在 tableViewCell 里面进行了一些订阅，该用的 DisposeBag 是 cell 本身声明的一个属性，而不应该直接用 VC 里面的那个，因为 cell 会发生重用，所以这里的 Disposable 的管理应该更积极一点：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">dataSource.configureCell <span class="operator">=</span> &#123; <span class="keyword">_</span>, tableView, indexPath, cellViewModel <span class="keyword">in</span></span><br><span class="line">	<span class="keyword">let</span> cell: <span class="type">TheCell</span> <span class="operator">=</span> tableView.dequeueCell(at: indexPath)</span><br><span class="line">	cellViewModel.image</span><br><span class="line">		.drive(cell.avatarView.image)</span><br><span class="line">		.disposed(by: cell.disposeBag)</span><br><span class="line">	<span class="keyword">return</span> cell</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//somewhere in TheCell.swift file</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TheCell</span>: <span class="title">UITableViewCell</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private(set)</span> <span class="keyword">var</span> disposeBag <span class="operator">=</span> <span class="type">DisposeBag</span>()</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">prepareForReuse</span>()</span> &#123;</span><br><span class="line">		disposeBag <span class="operator">=</span> <span class="type">DisposeBag</span>()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="没有在-UI-层使用-drivers">没有在 UI 层使用 drivers</h2>
<p>Driver 的设计是为了避免线程的混乱，对于 Driver 的订阅的通知都会发生在主线程上，所以可以降低线程问题的概率。具体要看看这个东西的详细用法。</p>
<h2 id="异常处理">异常处理</h2>
<p>当 Observable 抛出异常的时候，它会终止整个流程。如果使用了 <code>flatMap</code> 这类转换方法，那抛出异常的时候被终止的是源头的主流程。</p>
<p>也就是说，如果把一个可能抛出异常的流程绑定到了按钮的点击事件上，一旦这个流程抛出了异常，按钮的点击事件就再也不会响应了。</p>
<p>解决方法是使用 <code>Observable&lt;Result&lt;User&gt;&gt;</code> 或者 <code>materialize()</code> 之类的方法。</p>
<h2 id="同一个-Observable-订阅多次">同一个 Observable 订阅多次</h2>
<p>Observable 是不可变的类。每一个处理方法都是返回一个新的 Observable 而不会对原来的那个做任何变动。</p>
<p>在需要共享某些流程的结果时，可能会对某个 Observable 进行分别处理和订阅，这时候就应该用 <code>share</code> 或者 <code>shareReplay(1)</code> 来避免事件的重复发出：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> items: <span class="type">Observable</span>&lt;[<span class="type">Item</span>]&gt; <span class="operator">=</span> itemsProvider.items</span><br><span class="line">	.share()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">let</span> count: <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt; <span class="operator">=</span> items</span><br><span class="line">	.map &#123; <span class="variable">$0</span>.count &#125;</span><br><span class="line">    </span><br><span class="line">items.subscribe(onNext: &#123; items <span class="keyword">in</span> </span><br><span class="line">	<span class="comment">//do something with items</span></span><br><span class="line">&#125;) </span><br><span class="line">    </span><br><span class="line">numberOfItems.subscribe(onNext: &#123; count <span class="keyword">in</span> </span><br><span class="line">	<span class="comment">//do something with count</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果不加 <code>share()</code>，下面的两次 <code>subscribe</code> 就会触发两次 <code>itemProvider.items</code> 的 <code>get</code> 方法，但是显然我们只需要获取一次就可以满足下面两个订阅了</p>
</blockquote>
<h2 id="过度使用-subjects-variables">过度使用 subjects &amp; variables</h2>
<p>Rx 的世界应该是由“不可变变量”组成的，一旦一个事件已经形成，那么我们不应该对它本身做出任何改动，而是操作事件的流向最终得到我们想要的结果。</p>
<p>而 Subjects &amp; Variables 正是 Rx 世界里的“可变变量”。</p>
<p>不是说不能用它们，而是说我们在大多数时候并不需要用上它们。在更多情况下，我们可以用 <code>merge</code> 、<code>concat</code>、<code>publish</code>&amp;<code>refCount</code> 、<code>defer</code> 和其他一些方法去替代这两个玩意儿。</p>
<ul>
<li>原文链接：<a href="http://adamborek.com/top-7-rxswift-mistakes/">Top mistakes in RxSwift you want to avoid - Code in a suit</a></li>
</ul>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"8225264e14e677544541","clientSecret":"ed2a2c6d5043e9f0b41cae78b0d5b4571099de53","repo":"HexoBlogSource","owner":"davidleee","admin":["davidleee"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>Swift</tag>
        <tag>Reactive</tag>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title>AES是个什么鬼？</title>
    <url>/2016/04/26/about-aes-encryption/</url>
    <content><![CDATA[<p>前段时间参加了部门的几次分享会，主题围绕着数字签名、数字证书和https相关的知识。这些方面的内容都不可避免的要涉及到数据加解密，于是趁热打铁，准备进行一次加解密相关基础的学习和分享。<s>顺便扩充一下博客数量。</s><br>
这一篇是针对AES的学习笔记，主要的知识来源是维基百科和各种网络资源。<br>
因为时间有限，所以研究的不是非常深入，如果有不准确和错误的地方，希望能指出来一起讨论学习。</p>
<span id="more"></span>
<h2 id="前世今生">前世今生</h2>
<p>AES 的出现就是为了取代原来的数据加密标准（DES），作为爷爷级的加密算法，DES在风光过后也是到了该退休的年纪了。</p>
<h3 id="关于DES">关于DES</h3>
<p>在继续了解AES之前，不妨先看看被它取代的DES是什么。<br>
它的全称为 <strong>Data Encryption Standard</strong> ，是一种对称密钥加密块算法，大致的加密流程长这个样子：<br>
<img src="/uploads/AES%E6%98%AF%E4%B8%AA%E4%BB%80%E4%B9%88%E9%AC%BC%EF%BC%9F/des-encrypt.png" alt="des-encrypt">￼<br>
在进入到加密流程之前，64位的块被拆分为两个32位的子块，并作为 IP 的两个输入。中间的 F 是 Feistel function，算法中的密钥就是在这个函数中被用到的。</p>
<blockquote>
<p>块加密：Block cipher， 也叫作分组加密，是将明文分成多个等长模块（block），使用确定的算法和对称密钥对每组分别加密解密的方式。</p>
</blockquote>
<p>DES 在1976年曾经风光一时，被美国联邦政府的国家标准局定为 <strong>联邦资料处理标准（FIPS）</strong>。然而因为它只是用了56位的密钥，所以在当下已经不是一种安全的加密方法。在1999年1月，已经有组织在22小时15分钟内公开破解了一个DES密钥。</p>
<blockquote>
<p>后来出现了一种改进的 DES，叫 TDES 或 3DES。它本质上就是把密钥个数增加到了3个，并没有算法上的改进。（感觉很儿戏的样子）</p>
</blockquote>
<p>在2001年，DES已经不再是 <strong>国际标准科技协会</strong>（NIST，前 FIPS）的一个标准，而且也开始慢慢被AES所取代。</p>
<h3 id="言归正传">言归正传</h3>
<p>AES，全称为 <strong>Advanced Encryption Standard</strong>，原名叫做 <strong>Rijndael 加密法</strong>。（还是新名字好念）</p>
<blockquote>
<p>至于一开始为什么有个这么拗口的名字，因为两位作者的名字是 Joan Daemen 和 Vincent Rijmen，发现为什么了吗？这是不是密码学家约定俗成的某种命名方式呢？</p>
</blockquote>
<p>2001年11月26日，美国的 NIST 公布了 AES 这一标准，并开始了长达5年的标准化进程，直到 Rijndael 被选为最适合的方法。<br>
在2002年5月26日，AES 成为了一项联邦政府标准。它还是联邦安全局（NSA）批准的唯一一种用来加密顶级机密信息的公开加密方法。</p>
<blockquote>
<p>也就是说，如果你想要黑 FBI，也许可以试试看 AES 解密 :)</p>
</blockquote>
<p>严格来说，AES 和 Rijndael 并不完全一样。AES 使用的是固定128位大小的块，密钥的大小只能是128位、192位或256位；而 Rijndael 使用的块大小和密钥长度可以是在128位和256位之间能被32整除的任意值，相对来说灵活性高了很多。</p>
<h2 id="主要过程">主要过程</h2>
<p>AES加密算法的组成可以分成4个主要部分：</p>
<ol>
<li>AddRoundKey</li>
<li>SubBytes</li>
<li>ShiftRows</li>
<li>MixColumns</li>
</ol>
<p>简单来说，就是将上面的几个部分组合起来形成三种不同的序列，然后把这些过程序列重复执行若干个回合，具体的循环次数由密钥的长度决定：</p>
<ul>
<li>128位密钥：循环10次</li>
<li>192位密钥：循环12次</li>
<li>256位密钥：循环14次</li>
</ul>
<p>这三种序列是：</p>
<ul>
<li>
<p>首次循环：</p>
<ol>
<li>AddRoundKey</li>
</ol>
</li>
<li>
<p>一般循环：</p>
<ol>
<li>SubBytes</li>
<li>ShiftRows</li>
<li>MixColumns</li>
<li>AddRoundKey</li>
</ol>
</li>
<li>
<p>末尾循环：</p>
<ol>
<li>SubBytes</li>
<li>ShiftRows</li>
<li>AddRoundKey</li>
</ol>
</li>
</ul>
<p>那么这几个部分到底是干了些什么呢？</p>
<h3 id="AddRoundKey">AddRoundKey</h3>
<p>在每一次循环中，通过 <a href="https://en.wikipedia.org/wiki/Rijndael_key_schedule">Rijndael 密钥生成方案</a>从主密钥中生成一个子密钥，这个子密钥的大小应该等同于块的大小，并且以列优先的方式排列在一个矩阵里（每个块也是以这样的方式排列在矩阵里的）。<br>
接下来将这个子密钥的值与块上对应位置的值 XOR 起来，形成一个新的矩阵，到这里这一过程就算完成了。<br>
<img src="/uploads/AES%E6%98%AF%E4%B8%AA%E4%BB%80%E4%B9%88%E9%AC%BC%EF%BC%9F/AES-AddRoundKey.png" alt="220px-AES-AddRoundKey.svg">￼</p>
<h3 id="SubBytes">SubBytes</h3>
<p>这一步会使用到一个叫做 Rijndael S-box 的东西，它其实就是一个8位的代换表，每一个字节的数据都可以在表中查到对应的代换结果。只要这个 S-box 在构建的时候足够好，就可以大大降低这次加密的线性关系。下面是一个6位 S-box 的例子，输入的值是011011，输出的值是1001。<br>
<img src="/uploads/AES%E6%98%AF%E4%B8%AA%E4%BB%80%E4%B9%88%E9%AC%BC%EF%BC%9F/S-box-DES-input011011.png" alt="S-box-DES--input011011">￼</p>
<p>将块矩阵中的每一个元素通过 S-box 进行代换，组成一个代换后的矩阵，就是 SubBytes 这一步的工作。<br>
<img src="/uploads/AES%E6%98%AF%E4%B8%AA%E4%BB%80%E4%B9%88%E9%AC%BC%EF%BC%9F/AES-SubBytes.png" alt="320px-AES-SubBytes.svg">￼</p>
<h3 id="ShiftRows">ShiftRows</h3>
<p>这一步容易理解，就是把块矩阵中的每一行都进行一个向左循环移位，最后的效果是要让输出矩阵的每一列上的元素都属于输入矩阵原本不同的列。<br>
这样做可以保证每一列上的元素都是非线性相关的。<br>
<img src="/uploads/AES%E6%98%AF%E4%B8%AA%E4%BB%80%E4%B9%88%E9%AC%BC%EF%BC%9F/AES-ShiftRows.png" alt="320px-AES-ShiftRows.svg">￼</p>
<h3 id="MixColumns">MixColumns</h3>
<p>这个部分会接受4个字节的输入，并输出4个字节，而且每一个字节输入的字节都会对输出造成影响，所以它跟上面的 ShiftRows 一起为加密算法提供了良好的扩散性.</p>
<blockquote>
<p>扩散性（Diffusion）：如果改变了任意1位的原文，密文中一半以上的位也应该会跟着改变；反过来，改变了任意1位密文，得到的原文也应该有一半以上的位被改变。—— Stallings, William (2014). Cryptography and Network Security (6th ed.)</p>
</blockquote>
<p>简单来说，这一步就是讲输入矩阵的每一列与一个固定的多项式在一定条件下相乘。最终得到的将会是一个与输入矩阵完全不一样的输出矩阵。<br>
<img src="/uploads/AES%E6%98%AF%E4%B8%AA%E4%BB%80%E4%B9%88%E9%AC%BC%EF%BC%9F/AES-MixColumns.png" alt="320px-AES-MixColumns.svg">￼</p>
<blockquote>
<p>更多资料</p>
<ul>
<li><a href="http://blog.csdn.net/mengboy/article/details/1514445">伽罗华域(Galois Field，GF，有限域)乘法运算</a></li>
<li><a href="https://en.wikipedia.org/wiki/Confusion_and_diffusion">Confusion and diffusion</a></li>
</ul>
</blockquote>
<h2 id="填充算法">填充算法</h2>
<p>对于块加密算法来说，如果数据的长度不满一个块的大小，我们就需要主动填充一些数据，让这个块的大小可以满足要求，于是，一个合适的填充算法就显得尤为重要。<br>
经过导师的提醒并且在网上读了一些博客之后发现，<a href="http://my.oschina.net/nicsun/blog/95632">Java 端与 iOS 端使用的 AES 填充算法是不一样的</a>，在 Java 端上使用的是 PKCS5Padding ，而在iOS端上使用的是 PKCS7Padding 。所以就会导致在其中一端上加解密没有问题，但是把密文发到另一端上解密就会得到完全不同的结果。<br>
P.S. 这里说到的 <em>Java 端</em> 应该是指服务器端，<em>Android SDK</em> 上不知道还有没有这个问题。</p>
<blockquote>
<p>PKCS5 相当于是 PKCS7 的一个子集，因为 PKCS7 理论上支持1~255字节的块大小填充，而 PKCS5 只支持8字节的块大小填充。其实 PKCS5 更多是应用在 DES/3DES 上。</p>
</blockquote>
<p>具体的填充过程也非常好理解，直接举例子好了：比如说块大小为8字节的加密算法，现在有一串长度为9的数据：<br>
<code>FF FF FF FF FF FF FF FF FF</code>（9个 FF）<br>
使用 PKCS7 算法去填充的话，结果就是这样的<br>
<code>FF FF FF FF FF FF FF FF FF 07 07 07 07 07 07 07</code>（9个 FF 和7个07）<br>
填充的目的就是把块给补满，所以这里填充的长度为7；而采用 PKCS7 算法的话，填充的每一个字节都是填充长度的十六进制数，那就也是7。</p>
<blockquote>
<p>有趣的是，如果采用 PKCS5 去填充，因为它的目标块大小是8，所以这里会填充一个01。详情可以参考<a href="http://crypto.stackexchange.com/a/11274">Can AES use PKCS#5 padding</a>里的最佳答案。</p>
</blockquote>
<h2 id="写在最后">写在最后</h2>
<p>从上面的流程可以看出，一个逻辑严密的加密算法其实就是由一个个结构精巧的小算法构成的。在我看来，不深入到每个算法的内部，而只是看看它们之间的联系，还是蛮有意思的。研究算法的事情还是交给专业的人去做吧~</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard">Advanced Encryption Standard</a></li>
<li><a href="https://en.wikipedia.org/wiki/Rijndael_key_schedule">Rijndael 密钥生成方案</a></li>
<li><a href="http://blog.csdn.net/mengboy/article/details/1514445">伽罗华域(Galois Field，GF，有限域)乘法运算</a></li>
<li><a href="https://en.wikipedia.org/wiki/Confusion_and_diffusion">Confusion and diffusion</a></li>
<li><a href="http://my.oschina.net/nicsun/blog/95632">关于AES256算法java端加密，ios端解密出现无法解密问题的解决方案</a></li>
<li><a href="http://crypto.stackexchange.com/questions/11272/can-aes-use-pkcs5-padding">Can AES use PKCS#5 padding</a></li>
</ul>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"8225264e14e677544541","clientSecret":"ed2a2c6d5043e9f0b41cae78b0d5b4571099de53","repo":"HexoBlogSource","owner":"davidleee","admin":["davidleee"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>加解密</tag>
        <tag>安全</tag>
        <tag>AES</tag>
        <tag>DES</tag>
      </tags>
  </entry>
  <entry>
    <title>在 OC 项目中使用基于 Swift 的 CocoaPods 库</title>
    <url>/2016/05/12/Use-Swift-framework-in-OC-project/</url>
    <content><![CDATA[<p>随着 Swift 的流行，各种神奇的库也开始有对应的 Swift 版本了，而其中一些更神奇的库却只有 Swift 版本…<br>
正巧接手了一个前人用 Swift 写的项目，里面有一个非常关键的图表库，找了半天硬是没有发现类似的 OC 版开源库。出于不想造轮子的心态，就让我们这些&quot;落后&quot;的 OC 党想办法兼容这些库吧！好在苹果为了推广这门新语言已经做好了准备工作，虽然还是需要绕个路，但是比起造轮子来，还是简单了不少。</p>
<span id="more"></span>
<p>因为项目是用 CocoaPods 来管理第三方库的，所以这次的兼容工作也会在 CocoaPods 上展开。不过道理还是那个道理，如果没有用到 CocoaPods 的话，直接跳过下面关于 Podfile 的那一步就好了。</p>
<h2 id="Podfile">Podfile</h2>
<p>要用 CocoaPods，首先要修改的当然是 Podfile，这是最简单的一步，只需要在文件开始加上这一句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use_frameworks!</span><br></pre></td></tr></table></figure>
<p>这是告诉 CocoaPods：“请把我要用到的第三方库用动态框架的形式集成进来”。<br>
因为 Apple 不允许开发者构建内含 Swift 代码的静态库，所以要往 OC 项目中集成第三方 Swift 代码的时候就只能通过动态框架（ framework ）的形式了。</p>
<p>而 CocoaPods 还不能很好地将 framework 和静态库混编到一起，所以要么不用 framework，要用就要全部用上。关于这一点，<a href="https://blog.cocoapods.org/CocoaPods-0.36/">CocoaPods 官博</a>上的原话是这样说的：</p>
<blockquote>
<p>This is an all or nothing approach per integrated targets, because we can’t ensure to properly build frameworks, whose transitive dependencies are static libraries.</p>
</blockquote>
<h2 id="Xcode配置">Xcode配置</h2>
<p>这一步的操作比较绕，但总体来说还是简单的。</p>
<p>首先在你的项目中任意创建一个 Swift 文件，这时候聪明的 Xcode 会问你需不需要它帮助你创建一个 Bridging 文件。<br>
<img src="/uploads/Use-Swift-framework-in-OC-project/bridging-header.png" alt="bridging-header">￼</p>
<p>嘛，这当然是最好不过了，然而如果（像我这样）手贱点了 <em>Don’t create</em> ，那以后不管你创建再多的 Swift 文件，它都不会问你了。不过，这当然是有手动操作的途径：</p>
<ol>
<li>手动创建一个头文件，名字叫 <code>Your_Product_Module_Name-Bridging-Header.h</code>，注意不是 <code>Project_Name</code>。</li>
<li>确保你的项目目录下至少有一个 Swift 文件。</li>
<li>确保在 <strong>Targets</strong> 的 Build Settings 里，<strong>Product Module Name</strong> 是有值的。（如果没有，直接设置为 <code>$(PRODUCT_NAME)</code> 就可以了）</li>
<li>将 <strong>Project</strong> 的 Build Settings 里的 <strong>Defines Modules</strong> 设置为 <code>Yes</code>。（如果项目里没有创建过 Swift 文件的话，这个设置可能是不可见的）</li>
</ol>
<p>配置完成！进入代码环节！</p>
<h2 id="代码">代码</h2>
<p>其实也不需要什么代码啦。</p>
<p>完成了上面的所有步骤之后，Xcode 会自动生成一个名为 Your_Product_Module_Name-Swift.h 的文件，以后只要在需要使用到 Swift 代码的地方 import 这个文件就可以了。<br>
现在已经可以直接按照 OC 的语法去调用 Swift 里的属性和方法了，开始愉快地 coding 吧 :)</p>
<blockquote>
<p>P.S. 为了避免循环引用，<code>-Swift.h</code> 文件只能在 <code>.m</code> 文件中 import。如果需要在 <code>.h</code> 文件中使用，就只能用 @class 来前向声明。</p>
</blockquote>
<h2 id="参考文章">参考文章</h2>
<ul>
<li><a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-ID122">苹果官方文档：Mix and Match</a></li>
<li><a href="http://stackoverflow.com/a/30202319">Importing Project-Swift.h into a Objective-C class…file not found</a></li>
<li><a href="https://blog.cocoapods.org/CocoaPods-0.36/">CocoaPods 0.36 - Framework and Swift Support</a></li>
</ul>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"8225264e14e677544541","clientSecret":"ed2a2c6d5043e9f0b41cae78b0d5b4571099de53","repo":"HexoBlogSource","owner":"davidleee","admin":["davidleee"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
        <tag>CocoaPods</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 单元测试入门</title>
    <url>/2017/06/23/android-unit-test/</url>
    <content><![CDATA[<p>正在学习 Android 单元测试 ，光看文章怕有理解偏差，所以写一下博客帮助理解，如果能有人给我反馈建议或者错误就更好了。这篇文章主要讲到 <em>JUnit</em> 和 <em>Mockito</em> 这两个框架的使用，有了它们就已经可以跑绝大多数的单元测试了。</p>
<span id="more"></span>
<h2 id="JUnit">JUnit</h2>
<blockquote>
<p>使用断言（Assertion）对 <strong>带返回值</strong> 的方法进行测试。</p>
</blockquote>
<h3 id="Test">@Test</h3>
<p>使用 <code>@Test</code> 标注的方法为测试方法，JUnit 会自动执行这些方法。<br>
理论上测试方法的名字是可以随便取的，但为了方便阅读，应该在要测试的方法名前加上 <code>test</code> 来命名，比如方法 <code>add()</code> 的测试方法应该叫 <code>testAdd()</code> 。</p>
<p>除了常规的返回值测试， <code>@Test</code> 还可以用来测试异常和超时，举例来说：</p>
<ul>
<li><code>@Test(expected=NullPointerException.class)</code><br>
这样声明之后，只有当方法内抛出了空指针异常，才会认为测试通过。</li>
<li><code>@Test(timeout=3000)</code><br>
这会给测试方法一个超时时间，在上面这个例子中，如果方法执行超过了3秒，方法会被系统强行终止，并汇报终止的原因是超时。</li>
</ul>
<h3 id="其他注解">其他注解</h3>
<p>有一些常用的注解可以简化一下测试代码：</p>
<ul>
<li><code>@Before</code><br>
这个注解标识的方法会在每一个测试方法前被调用，通常用来做一些初始化的工作。</li>
<li><code>@After</code><br>
对应的，这个方法会在每一个测试方法后调用，用来做资源释放的工作。</li>
<li><code>@Ignore</code><br>
忽略某个测试方法，通常用于真正的方法还没有实现而你又正在写测试用例的时候。这样测试结果会显示有几个方法被忽略，而不是直接让测试失败。</li>
<li><code>@BeforeClass</code></li>
<li><code>@AfterClass</code><br>
跟开头的两个注解类似，不过这两个是作用于整个测试类的，可以将它们想象成测试对象创建和释放时会调用的方法。与之前不同的是，这两个注解修饰的方法必须是 <code>public static</code> 的。</li>
<li><code>@RunWith</code> &amp; <code>@Parameter</code><br>
<a href="https://github.com/junit-team/junit4/wiki/Test-runners">Test runners · junit-team/junit4 Wiki · GitHub</a></li>
</ul>
<h3 id="举个栗子">举个栗子</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Calculator mCalculator;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        mCalculator = <span class="keyword">new</span> Calculator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSum</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//expected: 6, sum of 1 and 5, tolerance 0</span></span><br><span class="line">        assertEquals(<span class="number">6</span>, mCalculator.sum(<span class="number">1</span>, <span class="number">5</span>), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSubstract</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        assertEquals(<span class="number">1</span>, mCalculator.substract(<span class="number">5</span>, <span class="number">4</span>), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<blockquote>
<p>节选自<a href="http://www.jianshu.com/p/03118c11c199">在Android Studio中进行单元测试和UI测试 - 简书</a></p>
</blockquote>
<h3 id="Rule">@Rule</h3>
<p>在 JUnit 4.7 版本开始，增加了一个新特性：Rule。</p>
<p>当我们使用 <code>@Before</code> 这类注解时，可以在测试方法执行前运行一些初始化的代码，然而如果这个初始化需要在多个测试类中被用到，比如初始化一个 <em>ContextHolder</em> ，还是要分别在每一个测试类的 <code>@Before</code> 方法中都写一遍。这就到了 Rule 发挥的时候了。</p>
<p>JUnit 提供了一些现成的 Rule，借用 InfoQ 上看到的一篇<a href="http://www.infoq.com/cn/news/2009/07/junit-4.7-rules">博客</a>的截图：</p>
<img src="/uploads/android-unit-test/test_rule.png" class="center" title="Test Rules">
<p>简单来说，这些类继承自一个叫 <code>TestRule</code> 的类，告诉了 JUnit 我们定义了一些测试规则，并希望在我们初始化这些规则对象的测试类中，所有测试方法都要满足这些规则，否则测试失败。</p>
<p>既然如此，如果我们创建一个类继承 <code>TestRule</code>，也就可以定义我们自己的测试规则了，具体的方法可以看<a href="https://segmentfault.com/a/1190000005923632">这篇文章</a></p>
<h3 id="小结">小结</h3>
<p>按照上文的叙述，这些注解修饰的方法会以下面这个顺序调用：<br>
<code>@BeforeClass</code> -&gt; <code>@Before</code> -&gt; <code>@Test</code> -&gt; <code>@After</code> -&gt; <code>@AfterClass</code></p>
<p>回到这个段落的开头：</p>
<img src="/uploads/android-unit-test/junit.png" class="center" title="JUnit">
<p>因为最终的测试工作落在了断言上，所以我们只能对数值的正确与否进行测试。</p>
<p>这在大多数情况下是足够了，然而有时候我们要测试的类可能会依赖许多其他的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ToBeTest</span> </span>&#123;</span><br><span class="line">	Class notTested;</span><br><span class="line">	Class alsoNotTested;</span><br><span class="line">	Class stillNotTested;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		notTested.doSomething();</span><br><span class="line">		alsoNotTested.doSomething();</span><br><span class="line">		stillNotTested.doSomething();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>又或者，如果我们要验证的方法并没有返回值，怎么知道这个方法的正确性呢？<br>
这时候我们需要了解一种叫 mock 的测试方式。</p>
<h2 id="Mockito">Mockito</h2>
<blockquote>
<p>Mock 测试：对不容易构建的对象，用一个虚拟对象来替代测试的方法</p>
</blockquote>
<p>简单理解，Mock 对象其实就是一个虚拟的对象，我们完全可以手动创建一个，并让它模拟真实对象的行为，从而达到测试的目的。一些 mock 测试框架（比如 Mockito）已经给我们提供了很好的工具，我们可以直接用它们来创建 mock 对象。</p>
<img src="/uploads/android-unit-test/mock.png" class="center" title="Mock">
<p>配图来源：<a href="http://www.vogella.com/tutorials/Mockito/article.html">Unit tests with Mockito - Tutorial</a></p>
<h3 id="创建-mock-对象">创建 mock 对象</h3>
<p>我们有两种方法去创建一个 mock 对象，举例来说，它们分别长这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">TestClass tc = Mockito.mock(TestClass.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="meta">@Mock</span></span><br><span class="line">TestClass tc; <span class="comment">// 1</span></span><br><span class="line"><span class="meta">@Rule</span> <span class="keyword">public</span> MockitoRule mockitoRule = MockitoJUnit.rule(); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>方法一就是让 Mockito 帮我们创建了一个指定类型的 mock 对象，方法二把这个过程分成了两步：</p>
<ol>
<li>通过 <code>@Mock</code> 注解声明我们要 mock 的对象</li>
<li>使用 JUnit Rule 的方式来对这些对象进行了一次全局的配置，这一步类似于 dagger 里 <code>inject()</code> 的调用</li>
</ol>
<p>经过 mock 之后的对象，</p>
<h3 id="举个栗子-v2">举个栗子</h3>
<p>Mockito 更像是 JUnit 的一种补充，所以一般都会搭配 JUnit 使用，借用一个例子（来源 <a href="http://www.vogella.com/tutorials/Mockito/article.html">Unit tests with Mockito - Tutorial</a>）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockitoTest</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mock</span></span><br><span class="line">    MyDatabase databaseMock; </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Rule</span> <span class="keyword">public</span> MockitoRule mockitoRule = MockitoJUnit.rule(); </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQuery</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        ClassToTest t  = <span class="keyword">new</span> ClassToTest(databaseMock); </span><br><span class="line">        <span class="keyword">boolean</span> check = t.query(<span class="string">&quot;* from t&quot;</span>); </span><br><span class="line">        assertTrue(check); </span><br><span class="line">        verify(databaseMock).query(<span class="string">&quot;* from t&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码里，我们用了 <code>@Mock</code> 注解的方式生成了一个 mock 对象 <code>databaseMock</code> 来模拟数据库，并将它作为参数构造了我们的 <code>ClassToTest</code>。<br>
在 <code>testQuery()</code> 方法里，我们用了 JUnit 的  <code>assertTrue()</code> 的方式去判断数据库查询是否成功，然后使用 Mockito 的  <code>verify()</code> 去测试 <code>databaseMock.query()</code> 是否被调用了。</p>
<h3 id="限制">限制</h3>
<p>Mockito 也有这它的限制：</p>
<ul>
<li>不能 mock 静态方法</li>
<li>不能 mock 私有方法</li>
<li>不能 mock 构造方法</li>
<li>不能 mock <code>equals()</code> &amp; <code>hashCode()</code></li>
</ul>
<blockquote>
<p>更详细的约束项可以看官方的<a href="https://github.com/mockito/mockito/wiki/FAQ#what-are-the-limitations-of-mockito">文档</a></p>
</blockquote>
<p>这几条约束其实已经足够搞死人了。<br>
在原本没有集成单元测试的项目中，会发现一些较低层级的代码几乎不可测试，但对于使用了 MVP 模式的模块，这种情况理应会有所改善。</p>
<h3 id="小结-v2">小结</h3>
<p>JUnit 搭配 Mockito 之后，你会发现写单元测试是一件挺轻松的事情，毕竟最麻烦的依赖问题已经基本解决了。<br>
如果碰到一些实在没法下手的情况，比如待测方法里包含了太多的类方法，那就只能祭出大杀器——重构了。</p>
<h2 id="写在最后">写在最后</h2>
<p><code>static</code> 方法在开发过程中还是挺常见的，比如 <code>Log.d()</code> 什么的。因为实现方式的问题，Mockito 是不支持这些方法的，所以有一个叫 Powermock 的工具应运而生了，为了提高单元测试的可用性，我会尝试使用这个工具或者其他的框架，到时候看看能不能再输出一篇文章。</p>
<p>到此为止，Android 开发中纯 Java 部分的单元测试已经可以展开了，但涉及到 Android SDK 的部分还是没办法动的。鉴于现在的项目是基于 React Native 开发的，没有太多关于 Android SDK 的部分，所以就到此为止了。</p>
<p>换个角度想想，如果项目中有很多 Android SDK 相关的部分，而你又不想进行单元测试的话，是不是可以考虑说服技术经理往 React Native 上迁移呢？</p>
<h2 id="参考文档">参考文档</h2>
<ul>
<li><a href="https://developer.android.com/training/testing/start/index.html">Getting Started with Testing | Android Developers</a></li>
<li><a href="http://junit.org/junit4/">JUnit</a></li>
<li><a href="http://www.vogella.com/tutorials/Mockito/article.html">Unit tests with Mockito - Tutorial</a></li>
</ul>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"8225264e14e677544541","clientSecret":"ed2a2c6d5043e9f0b41cae78b0d5b4571099de53","repo":"HexoBlogSource","owner":"davidleee","admin":["davidleee"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>Android</tag>
        <tag>单元测试</tag>
        <tag>JUnit</tag>
        <tag>Unit Test</tag>
        <tag>Mockito</tag>
        <tag>mock</tag>
      </tags>
  </entry>
  <entry>
    <title>简易 Core Data 入门</title>
    <url>/2016/05/09/easy-core-data/</url>
    <content><![CDATA[<p>也不知道是我搜索的方法不对还是别的什么问题，网络上很少见 Core Data 的入门教程，所以这篇东西就这样定位了：比看官方文档轻松得多，却可以马上在自己的 App 里用上 Core Data。<br>
不求深入到可以拿出去显摆，但是起码要可以用上手，并且能分享一篇入门指南，就像现在这样:)</p>
<span id="more"></span>
<h2 id="Launch-our-Xcode">Launch our Xcode!</h2>
<p>不管怎么样，先把咱熟悉的 Xcode 召唤起来，创建一个新项目。本项目的完整代码可以在<a href="https://github.com/davidleee/CoreDataTryout">这里</a>找到。对了，创建项目的时候记得把下面这个小勾给勾上，让 Xcode 帮我们创建模型文件。</p>
<img src="/uploads/easy-core-data/use_core_data.png" class="center" title="创建项目">
<p>然后就可以看到项目中出现一个后缀为 xcdatamodeld 的文件，这个文件相当于 Core Data 的 storyboard （不知道 <a href="https://developer.apple.com/videos/wwdc/2012/?id=407">storyboard</a>？）。选中它，你会看到这样几个东西：</p>
<img src="/uploads/easy-core-data/model_document.png" class="center" title="xcdatamodeld">
<p>在这篇文章里，我们就只关注 Entities 部分。</p>
<h2 id="浅入浅出">浅入浅出</h2>
<p>想要详细了解 Core Data 里面的结构关系的话，可以去翻翻<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreData/cdProgrammingGuide.html#//apple_ref/doc/uid/TP40001075">官方文档</a>。但是一开始接触的时候，不外乎就是这么几个类：</p>
<ul>
<li>NSManagedObjectModel</li>
</ul>
<p>这玩意儿是什么呢？说白了，你可以认为它就是我们的 xcdatamodeld 。它包含了我们自己定义的实体( Entitiy )、实体内部的属性( Attribute )和实体之间的关系( Relationship )，就像是我们在设计数据库的时候画的E-R图。原则上，这个模型越是完善，你的 App 对 Core Data 的支持就越好。</p>
<ul>
<li>NSManagedObjectContext</li>
</ul>
<p>按照官方文档的<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreData/Articles/cdBasics.html#//apple_ref/doc/uid/TP40001650-SW3">说法</a>，<code>NSManagedObjectContext</code> 就像是一个智能的工作台。当你想从数据库中获取数据的时候，这些数据会被暂时复制一份到这个工作台上，然后你就可以对它们进行操作了。这样，除非你确实进行了一次保存，否则数据库里的真实数据是不会被改变的。</p>
<p>而在实际使用中，我们最频繁接触的也是这个 <code>NSManagedObjectContext</code>。</p>
<ul>
<li>NSPersistentStoreCoordinator</li>
</ul>
<p>从名字大概可以猜到，这个类是不同数据库存储之间的协调者。</p>
<p>在 App 里面创建出来的数据对象和实际保存着的数据之间，存在着一个持久栈( Persistence Stack )。这个栈的最顶层是 <code>NSManagedObjectContext</code>，而它的最底层则是一个个数据文件( Persistent Object Store )，在它们之间的就是 <code>NSPersistentStoreCoordinator</code>。我们因为 <code>NSManagedObjectContext</code>的存在，而不需要直接操作这些数据文件；而且 Persistent Store Coordinator 的存在，是基于外观模式的设计，这就使得 <code>NSManagedObjectContext</code> 不需要面对多个数据文件，只和 Coordinator 打交道就可以了。</p>
<p>整个持久栈看起来就是这个样子：<br>
￼<img src="/uploads/easy-core-data/persistence_stack.png" class="center" title="Persistence Stack"></p>
<p>好，铺垫了那么久，也该用实践来检验一下真理了。</p>
<h2 id="准备工作">准备工作</h2>
<p>什么？上面讲了那么久的三个东西，Xcode 已经帮我们在 AppDelegate 里都准备好了？<br>
嗯，没错，很贴心嘛。<br>
￼<img src="/uploads/easy-core-data/r_u_kidding.png" class="center" width="250" height="250"></p>
<p>不过我们还是来简单理一理这些代码里面的关系吧。</p>
<p>可以发现，这几个对象的创建顺序是这样的 NSManagedObjectModel -&gt; NSPersistentStoreCoordinator -&gt; NSManagedObjectContext，跟持久栈的关系很一致。<br>
不过在此之前，我们还是需要拿到我们的 xcdatamodeld 才可以创建我们的模型：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSURL</span> *modelURL = [[<span class="built_in">NSBundle</span> mainBundle] URLForResource:<span class="string">@&quot;CoreDataTryout&quot;</span> withExtension:<span class="string">@&quot;momd&quot;</span>];</span><br><span class="line">_managedObjectModel = [[<span class="built_in">NSManagedObjectModel</span> alloc] initWithContentsOfURL:modelURL];</span><br></pre></td></tr></table></figure>
<p>然后用这个模型来创建 <code>NSPersistentStoreCoordinator</code>：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">_persistentStoreCoordinator = [[<span class="built_in">NSPersistentStoreCoordinator</span> alloc] initWithManagedObjectModel:[<span class="keyword">self</span> managedObjectModel]];</span><br><span class="line"> <span class="built_in">NSURL</span> *storeURL = [[<span class="keyword">self</span> applicationDocumentsDirectory] URLByAppendingPathComponent:<span class="string">@&quot;CoreDataTryout.sqlite&quot;</span>];</span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (![_persistentStoreCoordinator addPersistentStoreWithType:<span class="built_in">NSSQLiteStoreType</span> configuration:<span class="literal">nil</span> URL:storeURL options:<span class="literal">nil</span> error:&amp;error]) &#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>程序会在 App 的 document 目录中创建一个名为 CoreDataTryout.sqlite 的文件，<code>NSSQLiteStoreType</code> 是我们选择的数据库类型，我们还可以选择 XML（ iOS 上不支持）、Atomic 或者 In-Memory，如果这些类型你都不喜欢，你还可以创建<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreData/Articles/cdPersistentStores.html#//apple_ref/doc/uid/TP40002875-SW6">自定义存储类型</a>。</p>
<p>最后，在 <code>managedObjectContext</code> 的 setter 里面，我们给它装上准备好的 <code>persistentStoreCoordinator</code> 就大功告成了：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">_managedObjectContext = [[<span class="built_in">NSManagedObjectContext</span> alloc] init];</span><br><span class="line">[_managedObjectContext setPersistentStoreCoordinator:coordinator];</span><br></pre></td></tr></table></figure>
<p>注意到在 <code>application:didFinishLaunchingWithOptions:</code> 的最后还调用了一个 <code>saveContext</code> 方法。</p>
<p>Core Data 里面的数据都是自动保存的，也就是说，你完全可以在代码里把实体的对象创建出来，乱改一通，然后留下一个帅气的背影，奔向下一段代码。<br>
<code>managedObjectContext</code> 在发现有数据被改动了之后，会在一个<em>合适的时机</em>保存这些更改。这个保存也许不是数据变化后马上进行的，但是也足够智能可以让我们免去时不时保存一下的烦恼。有些时候（比如你暂停了你运行中的程序） <code>managedObjectContext</code> 会来不及做这些工作，或者你想要确保当下的数据被写进了数据库里，那么这个 <code>saveContext</code> 就会派上用场了。</p>
<h2 id="创建实体">创建实体</h2>
<p>一切准备就绪，我们终于要真正开始操作我们的数据库了！</p>
<p>先在我们的 xcdatamodeld 文件里面添加一个 Entity ，随便起个名字叫 User 好了，然后在右边 Attributes 那一栏里面添加一些属性。</p>
<img src="/uploads/easy-core-data/attributes.png" class="center" title="Attributes">
<p>Attributes 都是强类型的，所以如果你不手动给它们指定类型，编译器就会直接报错。能够写入数据库的类型还是挺丰富的，值得一提的是，数字和布尔值最终都会被转换成 <code>NSNumber</code> 来处理，而图片这一类比较大的文件就必须转换成 <code>NSData</code> 再写入了。</p>
<p>接下来，让 Xcode 帮我们生成这个实体的子类：</p>
<img src="/uploads/easy-core-data/create_subclasses.png" class="center" title="创建子类">
<p>选择一下 Model 和想要子类化的 Entity （有的项目会使用多个 Model，我们这里就只有一个）：</p>
<img src="/uploads/easy-core-data/choose_model.png" class="center" title="选择 Model">
<img src="/uploads/easy-core-data/choose_entity.png" class="center" title="选择 Entity">
<p>然后点 create ，你会发现项目文件夹中多两个文件 User.h/m。这两个文件由 Xcode 生成也由 Xcode 管理，所以如果我们改动了里面的内容，Xcode 可能就会跟我们发牢骚了。（如果确实需要添加某些功能，可以使用 category ）</p>
<p>如今这个类已经全权代表了我们在模型里面创建的实体，它的 property 和我们添加的 attributes 是一一对应的关系，也就是可以直接从这些属性访问到实体的变量了。</p>
<p>多说无益，赶紧来动动手！</p>
<img src="/uploads/easy-core-data/accept_challenge.png" class="" width="250" height="250">
<h2 id="Write-the-code-change-the-world">Write the code, change the world!</h2>
<p>首先拉一个简陋的界面出来给我们的用户输入信息，下面放一个输出信息的地方，省的我们每次都跑到 Debug Area 里面看：</p>
<img src="/uploads/easy-core-data/main_vc.png" class="center" width="500" height="500" title="Main VC">
<p>把所有控件都 hook 起来，然后在“写进去”和&quot;读出来&quot;两个按钮的 IBAction 里写代码。<br>
首先把数据写进数据库：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">IBAction</span>)writeAction:(<span class="keyword">id</span>)sender</span><br><span class="line">&#123;</span><br><span class="line">    AppDelegate *appDelegate = [[<span class="built_in">UIApplication</span> sharedApplication] delegate];</span><br><span class="line">    <span class="built_in">NSManagedObjectContext</span> *context = appDelegate.managedObjectContext;</span><br><span class="line"></span><br><span class="line">    User *newUser = [<span class="built_in">NSEntityDescription</span> insertNewObjectForEntityForName:<span class="string">@&quot;User&quot;</span> inManagedObjectContext:context];</span><br><span class="line">    newUser.name = <span class="keyword">self</span>.nameTextField.text;</span><br><span class="line">    newUser.age = @([<span class="keyword">self</span>.ageTextField.text intValue]);</span><br><span class="line">    newUser.height = @([<span class="keyword">self</span>.heightTextField.text intValue]);</span><br><span class="line">    newUser.weight = @([<span class="keyword">self</span>.weightTextField.text intValue]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//    [context save:NULL];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Core Data 用起来还是挺直观的吧？<br>
我们从 AppDelegate 里面拿到了老早就创建好了的 <code>managedObjectContext</code>，通过 <code>NSEntityDescription</code> 新建了一个准备插入到数据库中的 User；<br>
然后把用户输入的数据填充到 User 里面，保存一下。</p>
<p>等等！ Core Data 是会自动保存的，所以最后一句注释掉也没有影响咯。</p>
<p>接下来是读取数据：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">IBAction</span>)readAction:(<span class="keyword">id</span>)sender</span><br><span class="line">&#123;</span><br><span class="line">    AppDelegate *appDelegate = [[<span class="built_in">UIApplication</span> sharedApplication] delegate];</span><br><span class="line">    <span class="built_in">NSManagedObjectContext</span> *context = appDelegate.managedObjectContext;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSFetchRequest</span> *fetchRequest = [[<span class="built_in">NSFetchRequest</span> alloc] initWithEntityName:<span class="string">@&quot;User&quot;</span>];</span><br><span class="line">    <span class="built_in">NSError</span> *error;</span><br><span class="line">    <span class="built_in">NSArray</span> *results = [context executeFetchRequest:fetchRequest error:&amp;error];</span><br><span class="line">    <span class="keyword">if</span> ([results count]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.consoleTextView.text = [results description];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.consoleTextView.text = [error localizedDescription];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>认识一个新伙伴—— <code>NSFetchRequest</code>，数据库的读取基本都是靠这家伙了，你还可以对它加上各式各样的条件和约束，进行更精确的数据库查询。查询的结果会保存在一个 NSArray 里面，不管它，直接输出给我们看看。</p>
<p>这就够了！让我们的程序跑起来吧！<br>
￼<img src="/uploads/easy-core-data/let_run.png" class="" width="250" height="250"></p>
<h2 id="结果">结果</h2>
<p>随便录入点数据，按下“写进去”，嗯，和预期的一样，什么反应也没有。<br>
然后按下&quot;读出来&quot;：</p>
<img src="/uploads/easy-core-data/result.png" class="center" width="500" height="500" title="Result">
<p>嗯？输出的结果看起来有点奇怪？<br>
那是因为我们直接把数组的 description 打印了出来。这个数组里面其实就是我们之前创建好的 User 对象，直接拿出来当Model用就可以了。</p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"8225264e14e677544541","clientSecret":"ed2a2c6d5043e9f0b41cae78b0d5b4571099de53","repo":"HexoBlogSource","owner":"davidleee","admin":["davidleee"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Core Data</tag>
      </tags>
  </entry>
  <entry>
    <title>给哈希加点盐</title>
    <url>/2016/04/26/hash-with-salt/</url>
    <content><![CDATA[<p>又一篇学习笔记，这篇比较水，相当于是把原文给简化了一下，如果想要深入了解的话推荐还是看看原文<a href="http://drops.wooyun.org/papers/1066">加盐hash保存密码的正确方式</a>.</p>
<p>基于 <a href="https://en.wikipedia.org/wiki/Kerckhoffs%27s_principle">Kerckhoffs’s principle</a>，我们需要一种没有人能“看懂”但是又可以被验证的密码系统，听起来非常矛盾，但是哈希算法恰好满足了这个要求，于是通过加盐 hash 保存密码的方式应该是市面上比较稳妥的做法了。<br>
在说明加盐是什么之前，先来看看它所使用到的 Hash 的作用和一些常见的密码破解手段，相信看完之后，”为什么要加盐”这个问题也就自然而然的解决了。</p>
<span id="more"></span>
<h2 id="Hash">Hash</h2>
<p>Hash 算法是一种单向的函数，它可以把任意数量的数据转换成固定长度的 <em>指纹</em>，这个过程是不可逆的，而且只要输入的数据中有一丝改变，结果的 hash 值也会有很大的不同。<br>
这里的 Hash 算法跟数据结构上的 hash 函数不完全相同，根据不同的使用场景，需要使用具有不同特性的 hash 函数。实现 hash 表的函数具有快速的特点，而加密 hash 函数是用来进行密码加密的，所以必须要确保安全性，比如 SHA256、SHA512、RipeMD、WHIRLPOOL。</p>
<h2 id="一些常见的破解手段">一些常见的破解手段</h2>
<h3 id="字典-暴力破解">字典&amp;暴力破解</h3>
<p>基本上一切密码都可以用这种途径来破解，只是时间长短的问题了。</p>
<ul>
<li>字典破解：根据所有能找到的常用密码，生成一个密码字典，然后遍历字典中的值，一个个去尝试</li>
<li>暴力破解：对于给定长度的密码，尝试每一种可能的字符组合。</li>
</ul>
<p>既然没有办法阻止这种破解方式，那么只能让这种方式变得低效，从而达到花费时间不可接受的地步，让破解者主动放弃。</p>
<h3 id="查表破解">查表破解</h3>
<p>其实就是密码破解的进阶版。将密码字典中的每一个密码的 hash 值预先计算出来，放到另一张表里，这样做可以加快配对的速度。缺点是建立这个 hash 表需要耗费比较长的时间。</p>
<h3 id="反向查表破解">反向查表破解</h3>
<p>这一招是针对同时破解大量用户的时候用的。<br>
一般的密码破解的本质是：对同一个用户名，用不同的密码去试，看看哪个是正确的。<br>
而反向查表的本质是：用一个密码去试所有用户，看看谁在用这个密码，一直换密码直到表里面所有的密码都试过了。</p>
<p>这里用的表还是查表破解里经过了 hash 加密的密码表。</p>
<h3 id="彩虹表">彩虹表</h3>
<p>一种用时间换取了空间的表，牺牲了一些破解时间，以求表内包含的密码更全面。目前已经可以破解8位长度的任意 MD5 hash 。</p>
<h2 id="加盐">加盐</h2>
<p>各种查表的方法之所以有效，是因为 hash 函数的特性导致的，只要用户的密码相同，得到的 hash 值也一定相同。但是如果给每个人的密码加上一个随机的字符串再进行加密，那么即使两个用户使用了同一个密码，他们的密码存在数据库中的 hash 值也是不同的。<br>
这个随机的字符串就是盐（salt）。</p>
<blockquote>
<p>盐本身不需要保密，因为它的作用只是为了让各种表没那么容易生成。如果每次都要针对特定用户生成一个特定的表，那这个加盐的效果就达到了。</p>
</blockquote>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="http://drops.wooyun.org/papers/1066">加盐hash保存密码的正确方式</a></li>
</ul>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"8225264e14e677544541","clientSecret":"ed2a2c6d5043e9f0b41cae78b0d5b4571099de53","repo":"HexoBlogSource","owner":"davidleee","admin":["davidleee"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>加解密</tag>
        <tag>安全</tag>
        <tag>Hash</tag>
        <tag>Salt</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS获取图片附加信息</title>
    <url>/2016/04/21/get-exif-from-image-ios/</url>
    <content><![CDATA[<p>为了提供更好的体验，iOS上的App通常都会在条件允许的情况下尽可能多地获取用户信息（说好的隐私呢？！）。比如说，在用户选取了相册中的某张图片后，自动补充图片的拍摄日期、时间、地点等等，给用户一个非常智能的感觉。当然，前提是用户给予了我们这样做的权限。</p>
<span id="more"></span>
<h2 id="那么问题来了">那么问题来了</h2>
<p>如何获得这些信息呢？</p>
<p>稍微查一下可以知道，有一种叫做<a href="http://en.wikipedia.org/wiki/Exchangeable_image_file_format">EXIF</a>(Exchangeable image file format)的东西可以用来在图片中保存一定的数据（像素、ISO等）。这种标准通常应用在数码相机上，在用户照相同时，默默把当前的日期和时间给记录下来。而如今的智能手机在这个基础上还加入了地理位置等信息，包装成了一大个MetaData，信息数据应有尽有，可谓是给各位开发者提供了大大的方便啊。</p>
<p>可是，照片上的这些信息我们要怎样读取出来呢？</p>
<h2 id="前提">前提</h2>
<p>首先你的这张照片一定要存有这些信息才能被读取出来吧？<br>
<img src="/uploads/iOS%E8%8E%B7%E5%8F%96%E5%9B%BE%E7%89%87%E9%99%84%E5%8A%A0%E4%BF%A1%E6%81%AF/focus.png" alt="focus"></p>
<p>喂！这真的不是废话！</p>
<p>虽然现在的手机已经非常智能了，但是可以照相的应用却是五花八门，并不是每一位开发者都会考虑那么多，有相当一部分应用不管这部分数据的“死活”，它们想要的只是那一张图片而已。</p>
<p>所以，手机相册中的照片也不是百分百的带有我们想要的数据。有可能数据是完整的，但更多情况下，数据是残缺的，甚至完全没有这些数据。碰上这种情况，而你又迫切需要这些信息，那就只好求我们的用户大发慈悲地给我输入一下了。</p>
<p>特殊情况，特殊处理，这里不处理…<br>
就先把我们的用户当成一个非常有耐心、对手机非常信任、照相时网络状况良好的上帝吧:)</p>
<h2 id="照片哪里来">照片哪里来</h2>
<p>对于直接从照相机获取的照片来说，因为过程太短，所以并不能指望这张照片上面有多少我们想要的信息。如果条件允许的话，我们可以自己在后台采集（记录时间、定位等）。</p>
<p>从相册里面拿出来的照片就好多了。因为照片有一个保存的过程，耗时相对比较长，该采集的信息也采集得差不多了，没采集的我们也没有什么办法，所以就在这些已有的数据上下功夫就好了。</p>
<p>题外话：在用<code>UIImagePickerController</code>的时候，不小心遇到了一个问题，虽然和这篇文章的主题没有太大关系，不过我还是在<a href="https://github.com/davidleee/GetExifInfoDemo">完整代码</a>里把解决方案写了下来。</p>
<h2 id="动手吧！">动手吧！</h2>
<p>用<code>UIImagePickerController</code>来获取相册照片的过程就不多说了，我们主要来看它的一个代理方法<code>-[imagePickerController:didFinishPickingMediaWithInfo:]</code>。</p>
<p>这个代理方法会给我们一个字典info，如果用户选择的是一张图片的话，这个info里面除了有这张图片以外，还有图片的URL等信息。<br>
这张图片对我们接下来要做的事情作用不大，要关注的是这个URL。</p>
<p>在继续之前，我们还要加入这两个库：（下面的代码其实不需要ImageIO库，看<a href="https://github.com/davidleee/GetExifInfoDemo">完整代码</a>就知道怎么回事了）</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;AssetsLibrary/AssetsLibrary.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;ImageIO/ImageIO.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>在UIImagePickerController.h里面，对这个info字典的key给出了定义：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// info dictionary keys</span></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">UIImagePickerControllerMediaType</span>;      <span class="comment">// an NSString (UTI, i.e. kUTTypeImage)</span></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">UIImagePickerControllerOriginalImage</span>;  <span class="comment">// a UIImage</span></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">UIImagePickerControllerEditedImage</span>;    <span class="comment">// a UIImage</span></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">UIImagePickerControllerCropRect</span>;       <span class="comment">// an NSValue (CGRect)</span></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">UIImagePickerControllerMediaURL</span>;       <span class="comment">// an NSURL</span></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">UIImagePickerControllerReferenceURL</span>        <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">4</span>_1);  <span class="comment">// an NSURL that references an asset in the AssetsLibrary framework</span></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">UIImagePickerControllerMediaMetadata</span>       <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">4</span>_1);  <span class="comment">// an NSDictionary containing metadata from a captured photo</span></span><br></pre></td></tr></table></figure>
<p>而我们需要的只有<code>UIImagePickerControllerReferenceURL</code>对应的值。</p>
<p>因为UIKit都已经帮我们封装好了，所以真正要做的只剩下很少一部分。<br>
起作用的代码就只有下面这几行：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">ALAssetsLibrary *library = [[ALAssetsLibrary alloc] init]; <span class="comment">// 1</span></span><br><span class="line">[library assetForURL:[info objectForKey:<span class="built_in">UIImagePickerControllerReferenceURL</span>] resultBlock:^(ALAsset *asset) &#123; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSDictionary</span> *imageInfo = [asset defaultRepresentation].metadata;</span><br><span class="line"></span><br><span class="line">&#125; failureBlock:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>这里做了什么呢？</p>
<ol>
<li>初始化了一个<code>ALAssetsLibrary</code>，可以把它想象成当前应用与系统相册之间的一个通道，通过它我们就可以对系统的相册进行一定程度上的数据存取；</li>
<li>根据<code>UIImagePickerController</code>提供的URL，找到这张照片在相册中对应的对象（ALAsset），并返回给我们操作。</li>
</ol>
<p>剩下的事情就一目了然了，metadata就是我们想要的数据字典。</p>
<h2 id="结语">结语</h2>
<p>读取照片中的信息并没有我们想象中的复杂，网上有许多实现用到了一些更底层的方法，我在代码里也有写下来。更完整的叙述可以看Stackoverflow上的<a href="http://stackoverflow.com/a/9767129/4177374">这个回答</a>。</p>
<br/>
[完整代码传送门](https://github.com/davidleee/GetExifInfoDemo)

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"8225264e14e677544541","clientSecret":"ed2a2c6d5043e9f0b41cae78b0d5b4571099de53","repo":"HexoBlogSource","owner":"davidleee","admin":["davidleee"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Exif</tag>
      </tags>
  </entry>
  <entry>
    <title>让人眼花缭乱的 macOS 菜单</title>
    <url>/2018/08/22/how-menus-work/</url>
    <content><![CDATA[<blockquote>
<p>这是 macOS 开发系列的第二篇文章——让人眼花缭乱的 macOS 菜单。</p>
<p>这有什么好说的，你不要骗我！手机上的菜单都是我用自定义视图撸出来的！</p>
</blockquote>
<span id="more"></span>
<h2 id="菜单的类型">菜单的类型</h2>
<p>在 macOS 开发中，所谓“菜单”并不只是一个自定义视图了（虽然自定义视图也可以实现），在 AppKit 里面名字直接叫“菜单”的类就占了两席之地，分别是 <a href="https://developer.apple.com/documentation/appkit/nsmenu">NSMenu</a> 和 <a href="https://developer.apple.com/documentation/appkit/nsmenuitem">NSMenuItem</a>。</p>
<p>在实际应用中，菜单对应了 5 种表现形式：</p>
<ul>
<li>
<p>应用的菜单栏，在屏幕的最上方<br>
<img src="/uploads/how-menus-work/D54DBE49-05EB-4638-AEC3-FA37D500ECC7.png" alt=""></p>
</li>
<li>
<p>弹出菜单，可以出现在当前窗口中的任何地方<br>
<img src="/uploads/how-menus-work/3D50179E-F77C-4A53-85E5-9296B53895D7.png" alt=""></p>
</li>
<li>
<p>状态栏，从屏幕上方的菜单栏右边开始向左延伸<br>
<img src="/uploads/how-menus-work/WX20180821-170602@2x.png" alt=""></p>
</li>
<li>
<p>“上下文菜单”（Contextual Menus），点击右键或 “control + 左键” 触发<br>
<img src="/uploads/how-menus-work/56863C68-CAB1-4BCE-B0DD-82C7E4C03F5F.png" alt=""></p>
</li>
<li>
<p>Dock 菜单，对程序坞（Dock）的应用图片点击右键或 “control + 左键” 触发<br>
<img src="/uploads/how-menus-work/4948EFFA-1E19-4922-AB52-5FD4518F4268.png" alt=""></p>
</li>
</ul>
<p>看着挺多，但是用起来倒是挺简单方便的。下面就把这几个新玩具都拉出来溜一溜～</p>
<h2 id="应用菜单栏（Application-Menu）">应用菜单栏（Application Menu）</h2>
<p>这个菜单栏在上一篇文章（<a href="/2018/08/21/storyboard-in-macos/" title="不一样的 macOS Storyboard">不一样的 macOS Storyboard</a>）里已经纠结过了。</p>
<p>概括一下：每个应用初始化的时候就自带了一个应用菜单栏，如果是使用 Storyboard 开发的项目，在 “Main.storyboard” 里面就可以直接对这个菜单栏进行各种各样功能上的调整了（也就限于逻辑，样子大概是改不动了，只能用系统控件…）</p>
<h2 id="弹出菜单（Pop-up-Menu）">弹出菜单（Pop-up Menu）</h2>
<p>这种菜单的含义比较宽泛，所有在当前窗口里面出现的、带有“弹出”感觉的菜单都可以属于这一类。从视觉上大致可以分成两种：对话框型 &amp; 按钮型。</p>
<h3 id="对话框型">对话框型</h3>
<p>这中文名是我自己取的…因为它长得像呀！它就是上面类型介绍里的图片所示的样子，对应的类是 <a href="https://developer.apple.com/documentation/appkit/nspopover">NSPopover</a>。</p>
<p>这玩意儿在 iOS 9 和更老的版本中有类似的用法叫 <a href="https://developer.apple.com/documentation/uikit/uipopovercontroller">UIPopoverController</a>，在 iOS 9 之后就变成了 UIViewController 的一种展现方式了，具体参见 <a href="https://developer.apple.com/documentation/uikit/uipopoverpresentationcontroller">UIPopoverPresentationController</a>。</p>
<p>NSPopover 用起来跟上面说的几个类也是差不多的，只是它本身不是一个 ViewController，所以在展示之前需要先设置 <code>contentViewController</code> 以负责界面的显示。</p>
<p>更多风骚的用法还是参考官方文档为好 -  <a href="https://developer.apple.com/documentation/appkit/nspopover">NSPopover</a>。</p>
<h3 id="按钮型">按钮型</h3>
<p>顾名思义，这是个看起来很像按钮的菜单，打开系统偏好设置 -&gt; 通用，就能见到大把的按钮型弹出菜单，它们对应的类是 <a href="https://developer.apple.com/documentation/appkit/nspopupbutton">NSPopUpButton</a>。</p>
<p>在 xib 或者 storyboard 里面拖一个出来，能看到它跟普通按钮相比多出了这么一些独有的配置：<br>
<img src="/uploads/how-menus-work/A7088EFE-96C5-4124-BA69-05E917716EB1.png" alt=""></p>
<p>其中 “Type” 部分有两个可选值：Pop up &amp; Pull Down，它们最直观的区别在于按钮后面跟着的蓝色部分，前者是上下箭头，后者则只有一个向下的箭头：<br>
<img src="/uploads/how-menus-work/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%884.40.57.png" alt=""></p>
<p>当然，它们在列表展开方式和使用场景上也是不一样的，想要追究其中细节的童鞋们，推荐一篇官方文档：<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MenuList/Articles/ManagingPopUpItems.html#//apple_ref/doc/uid/20000274-BAJDEEJA">Managing Pop-Up Buttons and Pull-Down Lists</a></p>
<h2 id="状态栏（Status-Bar）">状态栏（Status Bar）</h2>
<p>作为一个中规中矩的菜单，状态栏菜单也是由两个部件组成的：<a href="https://developer.apple.com/documentation/appkit/nsstatusbar">NSStatusBar</a> &amp; <a href="https://developer.apple.com/documentation/appkit/nsstatusitem">NSStatusItem</a>，从名字就能看出它们的关系了，具体用法也是看文档咯。</p>
<blockquote>
<p>额外推荐一篇很详细的文章：<a href="https://www.raywenderlich.com/450-menus-and-popovers-in-menu-bar-apps-for-macos">Menus and Popovers in Menu Bar Apps for macOS | Ray Wenderlich</a></p>
</blockquote>
<p>根据官方的说法，状态栏的位置稀缺，不保证你应用的菜单在上面一直是可用的，所以建议把它放在最后考虑（是的，甚至在 Dock Menu 之后）。做事比较克制的微信只把它用来显示未读消息条数，点击回调也只是打开微信主窗口而已。</p>
<p>而且苹果还建议我们提供一个隐藏的选项，在必要时给用户隐藏掉我们状态栏图标的机会。</p>
<p>Emmm….虽然苹果的话我们也不一定听就是了…</p>
<h2 id="“上下文菜单”（Contextual-Menus）">“上下文菜单”（Contextual Menus）</h2>
<p>也就是俗称的右键菜单？</p>
<blockquote>
<p>macOS 上还可以用 control + 左键触发</p>
</blockquote>
<p>它跟应用菜单栏一样，是通过最常见的菜单样式来展现的，对应的类是： <a href="https://developer.apple.com/documentation/appkit/nsmenu">NSMenu</a> &amp; <a href="https://developer.apple.com/documentation/appkit/nsmenuitem">NSMenuItem</a>。</p>
<p>唯一不同的是，它不是通过点击一个什么按钮去触发的，而是通过重载 NSView 的 <code>defaultMenu</code> 属性来实现的，我们只需要定义好菜单的样子和内部逻辑，打开/收起菜单这样的琐事就交给系统去做好了。</p>
<p>在 xib 或 storyboard 里，把菜单链接到其他视图的 Outlets -&gt; menu 上面，同样能实现右键触发的效果：<br>
<img src="/uploads/how-menus-work/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%885.16.55.png" alt=""></p>
<p>话说上图这个界面本身也是一个 Contextual Menu 呢。</p>
<h2 id="Dock-菜单（Dock-Menu）">Dock 菜单（Dock Menu）</h2>
<p>阿哈！这也是个普普通通的 Menu，通过实现 <a href="https://developer.apple.com/documentation/appkit/nsdocktileplugin">NSDockTilePlugIn</a> 这个协议里的 <code>dockMenu()</code> 方法就可以返回一个我们自定义的菜单啦。</p>
<p>我们还可以通过它来自定我们的应用图标在 Dock 上面的样子，比如加个角标或者改一下图标颜色什么的，不过在这样做之前，我们还需要看看这个类 <a href="https://developer.apple.com/documentation/appkit/nsdocktile">NSDockTile</a>。这就超纲了啊，不说了不说了。</p>
<h2 id="总结">总结</h2>
<p>虽说自定义视图和显隐逻辑也可以实现菜单的功能，但是 AppKit 已经为我们封装了好几个类，让我们可以方便快捷地怼出一个功能丰富的应用了，它们是：</p>
<ul>
<li><a href="https://developer.apple.com/documentation/appkit/nsmenu">NSMenu</a> &amp; <a href="https://developer.apple.com/documentation/appkit/nsmenuitem">NSMenuItem</a></li>
<li><a href="https://developer.apple.com/documentation/appkit/nspopover">NSPopover</a> &amp; <a href="https://developer.apple.com/documentation/appkit/nspopupbutton">NSPopUpButton</a></li>
<li><a href="https://developer.apple.com/documentation/appkit/nsstatusbar">NSStatusBar</a> &amp; <a href="https://developer.apple.com/documentation/appkit/nsstatusitem">NSStatusItem</a></li>
<li><a href="https://developer.apple.com/documentation/appkit/nsdocktile">NSDockTile</a> &amp; <a href="https://developer.apple.com/documentation/appkit/nsdocktileplugin">NSDockTilePlugIn</a></li>
</ul>
<p>除了一些特殊的应用之外，我们的主要功能应该是在窗口里面提供的，而菜单通常都是些锦上添花的东西。不过在有余力的时候，为我们的用户增添一分“意外之喜”也是极好的吧。</p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"8225264e14e677544541","clientSecret":"ed2a2c6d5043e9f0b41cae78b0d5b4571099de53","repo":"HexoBlogSource","owner":"davidleee","admin":["davidleee"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>Swift</tag>
        <tag>macOS</tag>
        <tag>AppKit</tag>
        <tag>NSMenus</tag>
        <tag>NSPopover</tag>
        <tag>NSPopupButton</tag>
        <tag>Dock</tag>
        <tag>NSDockTile</tag>
        <tag>NSStatusBar</tag>
      </tags>
  </entry>
  <entry>
    <title>怎么在命令行给 macOS 设置开机启动任务</title>
    <url>/2018/11/07/login-items-for-macos/</url>
    <content><![CDATA[<p>最近通过 docker + nginx 在 一台 Mac mini 上面配了个简易文件系统，好让其他人能方便地下载一些预先写好的配置文件，这部分就不细说了。文件系统跑起来之后，考虑到便利性，想要再添加一个开机自启动的逻辑，让这个文件系统在电脑重启之后也能自己跑起来。</p>
<p>在 Linux 系统下面，我们可以通过 <code>systemctl</code>  或者直接修改 <em>rc.local</em> 文件<br>
来实现启动项的添加。但是这一套在 macOS 上面玩不转了，因为我们需要通过一个完全不一样的机制—— <strong>Launch Daemon</strong> 来实现这个功能。</p>
<span id="more"></span>
<h2 id="要做的事情">要做的事情</h2>
<p>因为 macOS 的启动项是通过一个 plist 去配置的，配置一个脚本远比配置一段要执行的命令行指令要简单，所以这里采用脚本的方式去实现。</p>
<p>于是我们要做的事情只有两步：</p>
<ol>
<li>创建一个脚本文件去执行 docker-compose 的启动指令</li>
<li>让这个脚本在系统启动的时候执行（不需要用户登录）</li>
</ol>
<h2 id="开始吧">开始吧</h2>
<h3 id="创建脚本">创建脚本</h3>
<p>先创建一个脚本文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim startup.sh</span><br></pre></td></tr></table></figure>
<p>不考虑异常情况，就是简单地进到 docker-compose.yaml 所在的目录，然后执行一下启动命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">cd /Users/davidleee/Desktop/docker-nginx</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> make sure it runs</span></span><br><span class="line">while [ $(docker inspect -f &#x27;&#123;&#123;.State.Running&#125;&#125;&#x27; docker-nginx_nginx_1) != &quot;true&quot; ]</span><br><span class="line">do</span><br><span class="line">  echo &quot;Launching file-service with docker-compose...&quot;</span><br><span class="line">  docker-compose up -d</span><br><span class="line">  sleep 2</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为了避免我们执行 <code>docker-compose</code> 的时候 docker 自己还没有跑起来，所以用一个循环去检测我们的服务是不是真的启动了。</p>
<p>另外还要记得把上面的 <code>docker-nginx_nginx_1</code> 改成你真正的的容器名称。</p>
</blockquote>
<p>别忘了给脚本加上执行权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod +x startup.sh</span><br></pre></td></tr></table></figure>
<h3 id="配置启动项">配置启动项</h3>
<p>现在我们要把上面的脚本添加到 <strong>Launch Daemon</strong> 里面去。</p>
<p>在此之前，让我们先理清一些概念。</p>
<p>macOS 通过一系列的 plist 文件来配置启动项，这些 plist 根据存放位置的不同而分为 <strong>Launch Daemon</strong> 和 <strong>Launch Agent</strong>。它们的区别在于，Agent 是在用户登录之后以该用户的身份去执行的任务，而 Daemon 是以根用户或 <code>UserName</code> 里指定的用户去执行的任务。</p>
<p>它们一般存放在这两个地方：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/Library/LaunchDaemons</span><br><span class="line"></span><br><span class="line">/Library/LaunchAgents/</span><br></pre></td></tr></table></figure>
<p>我们这次的任务需要用到 root 权限，所以我们将会在 LaunchDaemons 里创建一个配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /Library/LaunchDaemons/com.file-service.plist</span><br></pre></td></tr></table></figure>
<p>然后在里面填上以下内容：（注释部分可以去掉咯）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">plist</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//Apple//DTD PLIST 1.0//EN&quot;</span> <span class="meta-string">&quot; [http://www.apple.com/DTDs/PropertyList-1.0.dtd](http://www.apple.com/DTDs/PropertyList-1.0.dtd) &quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plist</span> <span class="attr">version</span>=<span class="string">&quot;1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Launch Daemon 不一定有权限访问所有需要的环境变量</span></span><br><span class="line"><span class="comment">	在没有权限的时候，启动项执行会失败，所以我们在这里配置一下脚本需要的环境变量 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>EnvironmentVariables<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">key</span>&gt;</span>PATH<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">string</span>&gt;</span>/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>Label<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 习惯上，我们会用一个 identifier 样式的名字来作为启动项的名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>com.file-service<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>Program<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 要执行的脚本的绝对路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>/Users/davidleee/Desktop/docker-nginx/startup.sh<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这个 key 告诉系统在启动的时候执行我们的脚本</span></span><br><span class="line"><span class="comment">  对于 daemons 来说是系统启动之后，对于 agent 来说则是用户登录之后 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>RunAtLoad<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 判断是按需启动我们的启动项，还是永远运行下去</span></span><br><span class="line"><span class="comment">	现在我们自己跑的是自己的脚本，按需启动就可以了 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>KeepAlive<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">false</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>LaunchOnlyOnce<span class="tag">&lt;/<span class="name">key</span>&gt;</span>        </span><br><span class="line">    <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在调试脚本的时候很好用，可以指定脚本正常/错误输出的路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>StandardOutPath<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>/tmp/startup.stdout<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>StandardErrorPath<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>/tmp/startup.stderr<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>UserName<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 执行脚本的用户 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>davidleee<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plist</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>最后就是把这个 plist 加载到 launchctl 里面去了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># `-w` 会把 plist 永久添加到 Launch Daemon 里面</span></span><br><span class="line">sudo launchctl load -w /Library/LaunchDaemons/com.file-service.plist</span><br><span class="line"></span><br><span class="line"><span class="comment"># ...如果你不想让它自启动了</span></span><br><span class="line">sudo launchctl unload -w /Library/LaunchDaemons/com.file-service.plist</span><br></pre></td></tr></table></figure>
<h2 id="写在最后">写在最后</h2>
<p>在执行完上面的 <code>launchctl load</code> 指令之后，plist 里面配置的脚本会马上被执行，你可以通过 <code>launchctl start</code> 和 <code>launchctl stop</code> 来控制它的开关，不过我们这里只是执行了一个脚本，并不会像其他应用那样长驻，所以其实也就没有“开关”一说了。</p>
<h2 id="参考文章">参考文章</h2>
<ul>
<li><a href="https://medium.com/@fahimhossain_16989/adding-startup-scripts-to-launch-daemon-on-mac-os-x-sierra-10-12-6-7e0318c74de1">Adding Startup Scripts to Launch Daemon on Mac OS X Sierra 10.12.6</a></li>
<li><a href="https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingLaunchdJobs.html">Creating Launch Daemons and Agents</a></li>
</ul>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"8225264e14e677544541","clientSecret":"ed2a2c6d5043e9f0b41cae78b0d5b4571099de53","repo":"HexoBlogSource","owner":"davidleee","admin":["davidleee"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>macOS</tag>
        <tag>Launch Daemons</tag>
        <tag>Launch Agent</tag>
        <tag>plist</tag>
        <tag>launchctl</tag>
      </tags>
  </entry>
  <entry>
    <title>【翻译】消息传递</title>
    <url>/2016/12/02/messaging-translation/</url>
    <content><![CDATA[<blockquote>
<p>本文翻译自苹果官方文档<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtHowMessagingWorks.html#//apple_ref/doc/uid/TP40008048-CH104-SW1">《Messaging》</a>。如有不正确的地方，欢迎在评论内指出。</p>
</blockquote>
<span id="more"></span>
<h3 id="传说中的-objc-msgSend-函数">传说中的 objc_msgSend 函数</h3>
<p>在 OC 内，消息（messages）会一直拖到运行时（runtime）才会绑定到方法实现（implementations）上。编译器会将下面这样的语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[receiver message]</span><br></pre></td></tr></table></figure>
<p>转化为对 objc_msgSend 这个消息传递函数的调用。</p>
<p>这个函数会将消息的接收者（上面的 receiver）和方法名（上面的 message，这个“方法名”也就是 method selector）作为它的两个主要参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">objc_msgSend(receiver, selector)</span><br></pre></td></tr></table></figure>
<p>任何传给方法的参数，都会原封不动地转交给 objc_msgSend：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">objc_msgSend(receiver, selector, arg1, arg2, ...)</span><br></pre></td></tr></table></figure>
<p>这个强大的消息传递函数真是为动态绑定（dynamic binding）操碎了心：</p>
<ul>
<li>它首先要找到 selector 对应的方法实现。因为同一个方法可能会在不同的类里面有不同的实现，如何判断要使用哪一种实现取决于消息接收者是哪个类。</li>
<li>然后它要调用那个方法实现，并把方法实现所需要的接收者对象（一个指向对象数据的指针）和所有参数都传递过去。</li>
<li>最后，它会把方法实现的返回值作为自己的返回值给出去。</li>
</ul>
<blockquote>
<p>嘛，objc_msgSend 已经辣么忙了，你就不要在你自己写的代码里面调用它了吧？嗯？—— Apple.</p>
</blockquote>
<p>能实现消息传递这一特性的关键，在于编译器在编译每一个类和对象时所使用的结构（structure）。类的结构包括了两个必备的元素：</p>
<ul>
<li>一个指向父类的指针。</li>
<li>一个类的分派表（dispatch table）。从这张表上，你可以查到方法的 selector 在这个类里对应的地址（class-specific addresses）。比如说，根据 <code>setOrigin::</code> 的 selector，你可以找到这个方法实现的地址（address of the procedure that implements <code>setOrigin::</code>）。</li>
</ul>
<p>在一个对象被创建出来的时候，它会被分配一块内存，而且它的成员变量也会进行相应的初始化。在它这些变量当中，排头的就是一个指向它类结构（class structure）的指针。这个指针叫做 <code>isa</code>，通过<code>isa</code>，对象可以访问它自己的类，而通过它自己的类，它还可以访问到它继承下来的所有父类。</p>
<blockquote>
<p>虽然严格来说，<code>isa</code> 不是 Objective-C 语言的一部分，但它是对象与 Objective-C 运行时系统打交道所必备的东西。一个对象必须与一个 <code>struct objc_object</code>（在 objc/objc.h 里声明）等价。尽管你几乎不会有需要创建一个根对象（root object），但是你要知道，所有继承自 <code>NSObject</code> 或 <code>NSProxy</code> 的对象都会自动带上一个 <code>isa</code> 变量。</p>
</blockquote>
<p>关于消息传递的框架，可以参考下面这个图：</p>
<p><img src="/uploads/messaging-translation/messaging1.gif" alt="message">￼</p>
<p>当有消息被发送到对象的时候，消息传递函数会顺着 <code>isa</code> 指针找到类结构，在这个地方它可以从分派表里找到对应的方法实现。<br>
如果很不幸的没找着，<code>objc_msgSend</code> 会继续顺着指向父类的指针找上去，企图从父类的分派表里找到对应的方法实现。不断地失败让 <code>objc_msgSend</code> 越战越勇，直到它来到了 <code>NSObject</code> 这里。<br>
如果它找到了，就像上面提到的那样，它会调用对应的方法，并把所有参数一股脑丢给方法实现。</p>
<p>这就是运行时选择方法实现的一种途径，或者，用面向对象编程的行话来说，这是将方法动态绑定到了消息上。</p>
<p>为了加速消息传递的过程，运行时系统缓存了它用到的 selectors 和方法的地址。每一个类都有一个独立的缓存，这个缓存会将继承下来的方法也一并保存了，就像保存自己声明的方法一样。在搜索分派表之前，消息传递会惯例先查一下消息接收对象的类的缓存（因为理论上，一个被起码用过一次的方法，会更有可能被再用一次）。如果方法的 selector 在缓存里，那么消息传递就只会比方法调用慢那么一丢丢。一旦程序运行了足够久，缓存已经被充分调动起来了，那几乎所有发送的消息都可以在缓存里找到对应的方法。缓存的大小会随着程序的运行而慢慢地增长，以便让新的消息可以有地方妥当地安置下来。</p>
<h3 id="使用隐藏参数">使用隐藏参数</h3>
<p>当 <code>objc_msgSend</code> 找到了想要的方法实现之后，它会调用那个方法实现并把所有传进来的参数都丢过去，除此之外它还会传过去两个不为人知的隐藏参数：</p>
<ul>
<li>接收者对象</li>
<li>方法的 selector</li>
</ul>
<p>这两个参数告诉了我们调用每一个方法实现的消息表达式的主要信息。为什么说是“隐藏”的呢？因为它们不会出现在声明方法的源码中，它们只在编译的时候才会被加入到方法实现里面。</p>
<p>尽管这两个参数没有被显式声明，但是在代码里还是可以引用它们（就像代码里可以引用对象里的其他实例变量那样）。在方法内，可以用 <code>self</code> 来引用接收消息的对象，用 <code>_cmd</code> 来引用它本身的 selector。举个栗子，下面的代码里，<code>_cmd</code> 表示 <code>strange</code> 方法的 selector，而 <code>self</code> 则表示接收 <code>strange</code> 这个方法的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- strange</span><br><span class="line">&#123;</span><br><span class="line">    id  target = getTheReceiver();</span><br><span class="line">    SEL method = getTheMethod();</span><br><span class="line"></span><br><span class="line">    if ( target == self || method == _cmd )</span><br><span class="line">        return nil;</span><br><span class="line">    return [target performSelector:method];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这两个参数里面，<code>self</code> 是比较有用的哪那一个。它其实是成员变量可以在方法里被调用到的关键。</p>
<h3 id="获取方法地址">获取方法地址</h3>
<p>唯一可以绕开动态绑定的方法，是获取到方法的地址，然后把它当做一个函数那样直接调用。这种做法用到的机会不多，但是如果一个方法会被一连串地反复调用，这样做可以避免每次都进行消息传递从而节省一些时间。</p>
<p>你可以用 <code>NSObject</code> 里声明的方法 <code>methodForSelector:</code> 来获取到实现一个方法的程序的指针，然后用这个指针来直接调用这段程序。<code>methodForSelector:</code> 返回的指针在使用前要小心地转换成正确的方法类型，在这个转换里，返回值和参数类型都是必不可少的。</p>
<p>再举个栗子，它将会告诉你 <code>setFilled:</code> 方法的执行程序是怎么被调用的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void (*setter)(id, SEL, BOOL);</span><br><span class="line">int i;</span><br><span class="line"></span><br><span class="line">setter = (void (*)(id, SEL, BOOL))[target</span><br><span class="line">    methodForSelector:@selector(setFilled:)];</span><br><span class="line">for ( i = 0 ; i &lt; 1000 ; i++ )</span><br><span class="line">    setter(targetList[i], @selector(setFilled:), YES);</span><br></pre></td></tr></table></figure>
<p>前两个传递给执行程序的参数就是接收对象（<code>self</code>）和方法 selector（<code>_cmd</code>）。这些变量对于方法的语法来说是隐藏的，但在方法作为函数调用的时候，它们必须显式地传递过去。</p>
<p>用 <code>methodForSelector:</code> 来规避动态绑定可以节省消息传递过程所浪费的大多数时间。然而，这种节俭只有特定方法被频繁调用很多次的时候才有意义，比如像上面例子中的 <code>for</code> 循环那样。</p>
<p>需要注意的是，<code>methodForSelector:</code> 是 Cocoa 运行时系统所提供的，它并不是来自 Objective-C 这门语言本身。</p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"8225264e14e677544541","clientSecret":"ed2a2c6d5043e9f0b41cae78b0d5b4571099de53","repo":"HexoBlogSource","owner":"davidleee","admin":["davidleee"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Translation</tag>
        <tag>runtime</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS 7.2 网卡配置</title>
    <url>/2017/02/28/network-setup-on-centos/</url>
    <content><![CDATA[<blockquote>
<p>本文是对 CentOS 7.2 网络环境配置的教程，一步步将刚安装好系统的 CentOS-7-Minimal 服务器接入互联网。</p>
</blockquote>
<span id="more"></span>
<blockquote>
<p>文中所用到的指令都是在 root 权限下执行的，如果发现找不到网卡配置文件等异常，进入到 root 用户下试试看</p>
</blockquote>
<h2 id="折腾个啥？">折腾个啥？</h2>
<p>因为用到的软件对性能的要求没有很高，所以一直以来用的都是 Everything 版本的 CentOS 系统作为服务器。</p>
<p>然而，最近部署任务的数量上去之后，发现 Everything 版本的防火墙不太稳定，或者说我们的软件跟这个防火墙不太对味，加上带 UI 的系统在部署上的操作反而会更加绕，所以选择改用 Minimal 版本以求获得一个更干净的环境，性能的提升倒是其次了。</p>
<p>装好系统之后一 <code>ping</code> 就懵逼了，原来 Minimal 版本的 CentOS 竟然干净成这样，连网卡的配置都省了，那我们就只好自己折腾折腾咯。</p>
<h2 id="找到要配置的网卡">找到要配置的网卡</h2>
<blockquote>
<p>刚安装好的 CentOS 7.2 系统是不带 <code>ifconfig</code> 这类网络工具的，而是被 <code>ip</code> 指令取代了</p>
</blockquote>
<p>下图是两种找到网卡配置文件的方式：</p>
<img src="/uploads/network-setup-on-centos/p1.png" class="center" title="找到要配置的网卡">
<h3 id="1-直接在网络脚本目录中找">1. 直接在网络脚本目录中找</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /etc/sysconfig/network-scripts/</span><br><span class="line">ls</span><br></pre></td></tr></table></figure>
<p>可以看到目录中有至少两个 <code>ifcfg-xxx</code> 文件，其中 <code>ifcfg-enpxxx</code> 是我们要找的网卡配置文件。</p>
<blockquote>
<p>如果设备上有多个网卡的话，可能会有多个 <code>ifcfg-enpxxx</code>，后面的 <code>xxx</code> 可能是不同的数字与字母组合，任意选择一个去配置就好了，在上图的情况下，我们要修改的网卡文件就是 <code>ifcfg-enp2s0</code></p>
</blockquote>
<h3 id="2-通过-ip-命令查找">2. 通过 ip 命令查找</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip addr show</span><br></pre></td></tr></table></figure>
<p>这是查看 IP 地址的指令，相当于原来的 <code>ifconfig</code>。<br>
可以看到这边有两个网络，<code>lo</code> 是本地回环，而 <code>enp2s0</code> 就是我们要找的网卡。同样，这个地方也可能出现多个 <code>enpxxx</code>，还是任意选择一个。</p>
<h2 id="修改网卡配置文件">修改网卡配置文件</h2>
<p>不管用哪个方法，都应该能得到网卡的名字 <code>enpxxx</code>，以上图的 <code>enp2s0</code> 为例做修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/sysconfig/network-scripts/ifcfg-enp2s0</span><br></pre></td></tr></table></figure>
<p>可以看到该网卡的配置类似下图，主要关注红框的部分：</p>
<img src="/uploads/network-setup-on-centos/p2.png" class="center" title="网卡配置文件">
<p>如果发现文件中没有这两个字段，可以手动给它加上，<code>ONBOOT</code> 配置为 <code>yes</code> 让网卡可以开机自启动，<code>BOOTPROTO</code> 是配置获取 IP 的方式，需要根据具体的网络环境来设定，主要分为两种情况：</p>
<h3 id="1-确定分配给当前设备的-IP-地址不会改变">1. 确定分配给当前设备的 IP 地址不会改变</h3>
<p>这种情况比较好办，直接像上图那样设置为 <code>dhcp</code> 就可以保存并退出编辑模式了。服务器具体获取到的是哪个 IP，我们可以通过 <code>ip addr show</code> 来确认。</p>
<h3 id="2-IP-动态分配，有可能发生变化">2. IP 动态分配，有可能发生变化</h3>
<p>这种情况就需要当前设备和路由器一起配合了。<br>
假设我们给这台 CentOS 设备绑定的地址是 <code>192.168.1.100</code>，路由器的路由和网关分别为 <code>192.168.1.1</code> 和 <code>255.255.255.0</code>。</p>
<p>回到网卡配置文件中，将 <code>BOOTPROTO</code> 设置为 <code>none</code>，并添加下列三个字段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IPADDR=192.168.1.100</span><br><span class="line">GATEWAY=192.168.1.1</span><br><span class="line">NETMASK=255.255.255.0</span><br></pre></td></tr></table></figure>
<p>完成之后应该是像下图这样，红框部分是经过修改的地方：</p>
<img src="/uploads/network-setup-on-centos/p3.png" class="center" title="修改后的网卡配置文件">
<h2 id="重启网络">重启网络</h2>
<p>为了使配置生效，我们需要重启一下网络服务，这里一条指令就搞定了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service network restart</span><br></pre></td></tr></table></figure>
<p>网卡重启后，可以通过 <code>ip addr show</code> 查看配置生效了没有：</p>
<img src="/uploads/network-setup-on-centos/p4.png" class="center" width="400" height="400" title="查看 IP 地址">
<p>红框部分应该是刚才配置的 <code>IPADDR</code> 中的内容，或者是路由器上分配过来的 IP 地址。</p>
<p>现在尝试 <code>ping</code> 一下外网的网址，如果能通就说明网卡配置好了。</p>
<h2 id="特殊情况">特殊情况</h2>
<p>如果 <code>ping</code> 外网不通，返回类似 <code>unknown host</code> 的字样，那说明还需要配置一下 DNS 地址。</p>
<blockquote>
<p>每个企业的 DNS 服务的情况可能会有不同，有些企业的网络会在连上之后自动分配一个 DNS 地址，而有些却不会，这时就需要我们手动进行 DNS 地址的配置了。</p>
</blockquote>
<p>假设我们用的 DNS 地址是 <code>8.8.8.8</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/resolv.conf</span><br></pre></td></tr></table></figure>
<p>这里可能会打开一个空白的文件，也没有关系，直接在文件末尾加入下面这一行内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nameserver 8.8.8.8</span><br></pre></td></tr></table></figure>
<p>然后再次重启网络，就可以使这个 DNS 配置生效了。</p>
<h2 id="总结">总结</h2>
<p>其实配置 CentOS 的网卡并不难，但是网上查找的资料很少有完整介绍全过程的，于是就需要花费很多时间在搜索引擎里拼凑资料。<br>
希望这篇文章能对后来者有些许帮助，节约一丢丢时间也是极好的 :)</p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"8225264e14e677544541","clientSecret":"ed2a2c6d5043e9f0b41cae78b0d5b4571099de53","repo":"HexoBlogSource","owner":"davidleee","admin":["davidleee"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>CentOS</tag>
        <tag>network</tag>
        <tag>nameserver</tag>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title>NSTextField(1) —— macOS 输入框概览</title>
    <url>/2019/04/12/nstextfield-for-macos/</url>
    <content><![CDATA[<blockquote>
<p>这是 macOS 开发系列的第四篇文章 —— NSTextField。<br>
最常见的控件之一，却不一定是你最熟悉的控件之一。</p>
</blockquote>
<span id="more"></span>
<p>将近半年没发文了，这段时间过得真是充实得过分，以至于完全没有时间好好整理一下手边可以写的内容。最近好不容易有点时间可以把存货整理整理，发现当时写的好多东西都已经过时了！赶紧收拾干净先发一篇上来，不然指不定哪天连整个主题都没用了…</p>
<p>咱们直接进入正题！</p>
<h2 id="NSTextField">NSTextField</h2>
<p>一个完整的 TextField 是由两个类组成的：<a href="https://developer.apple.com/documentation/appkit/nstextfieldcell">NSTextFieldCell</a>，干了绝大多数脏活累活的一个类，和 <a href="https://developer.apple.com/documentation/appkit/nstextfield">NSTextField</a>，作为 NSTextFieldCell 的容器而存在。所有 NSTextFieldCell 里的方法在 NSTextField 里面都有对应的存在（有点像 UIView 对 Layer 的封装）。</p>
<p>对于绝大多数情况来说，我们直接用 NSTextField 就足够了（那这篇文章不久没什么作用了吗？！）。如果你想要对自己的输入框有更多的掌控权，那可能还需要了解一个叫 <a href="https://developer.apple.com/documentation/appkit/nscontrol">NSControl</a> 的家伙。</p>
<h2 id="NSControl">NSControl</h2>
<p>正如 iOS 里的 <a href="https://developer.apple.com/documentation/uikit/uicontrol">UIControl</a>，<a href="https://developer.apple.com/documentation/appkit/nscontrol">NSControl</a> 是一个抽象类，必须通过子类继承来使用。但是跟比较纯粹的 UIControl 不同，NSControl 除了支持 Target/Action 机制和一些常见的属性设置之外，还加上了支持文字编辑的一系列代理方法。</p>
<p>举个两组最常用的例子：</p>
<h3 id="controlTextDidxxx">controlTextDidxxx(_:)</h3>
<p>这么多方法里面，比较好用的当属 <code>did</code> 系列方法了：</p>
<ol>
<li><a href="https://developer.apple.com/documentation/objectivec/nsobject/1428934-controltextdidbeginediting?language=objc"><code>controlTextDidBeginEditing(_:)</code></a></li>
<li><a href="https://developer.apple.com/documentation/objectivec/nsobject/1428847-controltextdidendediting?language=objc"><code>controlTextDidEndEditing(_:)</code></a></li>
<li><a href="https://developer.apple.com/documentation/objectivec/nsobject/1428982-controltextdidchange?language=objc"><code>controlTextDidChange(_:)</code></a></li>
</ol>
<p>这三个方法虽然已经在官方文档里被标记为 “macOS 10.0-10.14 Deprecated”了，<s>但它们仍然在勤勤恳恳地工作着</s>。<s>鉴于 macOS 的 10.14 还没出来</s>（2018.8），<s>我们但用无妨</s>。2019年4月再看，系统版本已经到10.14以上了，是时候考虑正式换成下面的方法了。</p>
<blockquote>
<p>上面三个方法的链接都是 Objective-C 版本的，被 Deprecated 的也是这个版本的方法。在 Swift 版的文档里，在 NSControlTextEditingDelegate 里已经加入这三个方法<s>的 Beta 版</s>了（2019.4 Beta 标识已经去掉了）：<a href="https://developer.apple.com/documentation/appkit/nscontroltexteditingdelegate/3005176-controltextdidbeginediting">controlTextDidBeginEditing(_:)</a>、 <a href="https://developer.apple.com/documentation/appkit/nscontroltexteditingdelegate/3005177-controltextdidchange">controlTextDidChange(_:)</a>、 <a href="https://developer.apple.com/documentation/appkit/nscontroltexteditingdelegate/3005178-controltextdidendediting">controlTextDidEndEditing(_:)</a>。方法签名看起来是一样的，估计新方法的正式版出来之后也可以无缝迁移。</p>
</blockquote>
<p>顾名思义，它们代表了输入过程中的三个状态，不过有一点要注意的是：每次出现 didEnd 并不一定会有一个对应的 didBegin。因为 didBegin 表示的是用户<strong>开始输入</strong>的状态，也就是说，单单是光标在控件上面闪烁着是不算数的，一定要用户敲下第一个字符的时候才会回调 <code>controlTextDidBeginEditing(_:)</code>。</p>
<p>而相对的，didEnd 表示<strong>结束编辑</strong>，只要用户选中输入框之后点击了输入框以外的地方，都会被算作“结束”，即使他从头到尾都没有输入过一个字。</p>
<p>这三个方法传入的参数都是 <code>Notification</code> 类型，说明它们其实都是系统通知的回调方法，只要实现了这个方法，系统就会自动帮你注册这三个消息的监听器。</p>
<blockquote>
<p>虽然参数是个 <code>Notification</code> ，但它会把触发消息的输入框作为 object 属性一起传进来，可以做的事情就相当多了。</p>
</blockquote>
<h3 id="NSControlTextEditingDelegate">NSControlTextEditingDelegate</h3>
<p>这个代理是专门为了编辑操作而设计的，除了<s>还在 Beta 版的</s>三个 did 系列方法外（2019.4 Beta 标识已经去掉了），还有分工明确的另外7个方法，一共10个。这部分在现在的项目里还没怎么接触，就只是把文档搬过来方便大家参考。</p>
<p>验证：</p>
<ul>
<li><a href="https://developer.apple.com/documentation/appkit/nscontroltexteditingdelegate/1428873-control">control(_:isValidObject:)</a></li>
<li><a href="https://developer.apple.com/documentation/appkit/nscontroltexteditingdelegate/1428941-control">control(_:didFailToValidatePartialString:errorDescription:)</a></li>
</ul>
<p>格式化文本：</p>
<ul>
<li><a href="https://developer.apple.com/documentation/appkit/nscontroltexteditingdelegate/1428883-control">control(_:didFailToFormatString:errorDescription:)</a></li>
</ul>
<p>文本编辑响应：</p>
<ul>
<li><a href="https://developer.apple.com/documentation/appkit/nscontroltexteditingdelegate/1428865-control">control(_:textShouldBeginEditing:)</a></li>
<li><a href="https://developer.apple.com/documentation/appkit/nscontroltexteditingdelegate/1428984-control">control(_:textShouldEndEditing:)</a></li>
</ul>
<p>自动补全：</p>
<ul>
<li><a href="https://developer.apple.com/documentation/appkit/nscontroltexteditingdelegate/1428925-control">control(_:textView:completions:forPartialWordRange:indexOfSelectedItem:)</a></li>
</ul>
<p>按键事件响应：</p>
<ul>
<li><a href="https://developer.apple.com/documentation/appkit/nscontroltexteditingdelegate/1428898-control">control(_:textView:doCommandBy:)</a></li>
</ul>
<p>成员方法 <s>Beta</s>:</p>
<ul>
<li><a href="https://developer.apple.com/documentation/appkit/nscontroltexteditingdelegate/3005176-controltextdidbeginediting">controlTextDidBeginEditing(_:)</a></li>
<li><a href="https://developer.apple.com/documentation/appkit/nscontroltexteditingdelegate/3005177-controltextdidchange">controlTextDidChange(_:)</a></li>
<li><a href="https://developer.apple.com/documentation/appkit/nscontroltexteditingdelegate/3005178-controltextdidendediting">controlTextDidEndEditing(_:)</a></li>
</ul>
<h2 id="总结">总结</h2>
<p>没有错！到这里就结束了！（因为实在是没什么存货…）希望这篇文章能起到入门和索引的作用。</p>
<p>有了这些内容，应该大概能知道怎么去控制输入框的内容，也可以避免一些简单的坑了。</p>
<p>如果没人注意到标题里的“(1)”的话，我就在这里打住了…不然我可能会把打造一个真实情景下使用的输入框的过程讲一讲。</p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"8225264e14e677544541","clientSecret":"ed2a2c6d5043e9f0b41cae78b0d5b4571099de53","repo":"HexoBlogSource","owner":"davidleee","admin":["davidleee"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>Swift</tag>
        <tag>macOS</tag>
        <tag>NSTextField</tag>
        <tag>NSControl</tag>
      </tags>
  </entry>
  <entry>
    <title>隐私协议</title>
    <url>/2021/03/05/privacy/</url>
    <content><![CDATA[<p>本软件尊重并保护所有使用服务用户的个人隐私权。为了给您提供更准确、更有个性化的服务，本软件会按照本隐私权政策的规定使用和披露您的个人信息。但本软件将以高度的勤勉、审慎义务对待这些信息。除本隐私权政策另有规定外，在未征得您事先许可的情况下，本软件不会将这些信息对外披露或向第三方提供。本软件会不时更新本隐私权政策。您在同意本软件服务使用协议之时，即视为您已经同意本隐私权政策全部内容。本隐私权政策属于本软件服务使用协议不可分割的一部分。</p>
<p>1.适用范围</p>
<p>a)在您使用本软件网络服务，本软件自动接收并记录的您的手机上的信息，包括但不限于您的健康数据、使用的语言、访问日期和时间、软硬件特征信息及您需求的网页记录等数据；</p>
<p>2.信息的使用</p>
<p>a)在获得您的数据之后，本软件会将其上传至服务器，以生成您的排行榜数据，以便您能够更好地使用服务。</p>
<p>3.信息披露</p>
<p>a)本软件不会将您的信息披露给不受信任的第三方。</p>
<p>b)根据法律的有关规定，或者行政或司法机构的要求，向第三方或者行政、司法机构披露；</p>
<p>c)如您出现违反中国有关法律、法规或者相关规则的情况，需要向第三方披露；</p>
<p>4.信息存储和交换</p>
<p>本软件收集的有关您的信息和资料将保存在本软件及（或）其关联公司的服务器上，这些信息和资料可能传送至您所在国家、地区或本软件收集信息和资料所在地的境外并在境外被访问、存储和展示。</p>
<p>5.信息安全</p>
<p>a)在使用本软件网络服务进行网上交易时，您不可避免的要向交易对方或潜在的交易对方披露自己的个人信息，如联络方式或者邮政地址。请您妥善保护自己的个人信息，仅在必要的情形下向他人提供。如您发现自己的个人信息泄密，请您立即联络本软件客服，以便本软件采取相应措施。</p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"8225264e14e677544541","clientSecret":"ed2a2c6d5043e9f0b41cae78b0d5b4571099de53","repo":"HexoBlogSource","owner":"davidleee","admin":["davidleee"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title>移动应用消息推送的准备工作</title>
    <url>/2016/06/06/push-notification-preparation/</url>
    <content><![CDATA[<p>每个移动应用开发者都会幻想自己的 App 被成千上万人每天不断地使用着，然而现实总是冰冷的：用户们总是会有意无意地把你的 App 关掉，并且有意无意地将它们晾在某个角落里。<br>
然而聪明的程序员们总有各种办法引起用户们的注意，而消息推送（ Push Notifications ）无疑是这些办法中最直接了当的一种。</p>
<span id="more"></span>
<p>说了那么多，就是为了讲讲移动应用上常用的消息推送的<strong>准备工作（不涉及代码）</strong> ，内容将会涵盖 iOS 和 Android 两个平台。（你说 Win… 什么来着？）因为这方面做的工作实在算不上多，所以难免有错误和纰漏，欢迎大家提出来交流和讨论。</p>
<h2 id="写在开头">写在开头</h2>
<p>一听到要实现消息推送机制，首先会想到的应该是对服务器的需求了。想要定制化程度更高的推送机制，当然是要有自己的服务器比较稳妥，但在某些追求快捷方便的情况下，服务器倒也不是必要。</p>
<p>对于追求开发速度的情况，已经有许多非常优秀的第三方服务商<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>可以提供跨平台的解决方案，你压根就不需要考虑服务器的事情，甚至都不需要头疼集成的问题，因为这些产品的文档上都已经说明得很详细了。</p>
<p>所以，本文要提到的将是 iOS 和 Android 两方自家的推送服务。</p>
<h2 id="两家的区别">两家的区别</h2>
<p>对于生态环境封闭的 iOS 来说，想要推送消息就必须走苹果的服务器。你需要从自己的服务器向苹果的推送服务器发起推送请求，再由它替你将消息推向<em>用户的设备</em>。整个过程中，你自己的服务器是完全接触不到用户设备的。</p>
<p>而对于开放的 Android，虽然该 Google 有提供官方的服务，但你完全可以自己搭建一个推送服务器，将消息直接从你自己的服务器推送到<em>你自己的 App</em> 上。</p>
<p>注意上面两段文字中推送目标的差异：</p>
<ul>
<li>iOS 的推送服务器只是负责把消息推送到设备。每台 iOS 设备都有一个类似 IM 的程序跑在后台，统一接收来自服务器的推送，再分派到对应的 App 上去。</li>
<li>Android 的推送服务通常是把消息直接推送到应用。每个需要接收推送的应用都会跑一个常驻后台的消息接收器，从这个方面看，Android 的设备会比iOS 设备稍微更耗电一些。</li>
</ul>
<h2 id="iOS">iOS</h2>
<p>想要在 iOS 系统中完成一次推送，就必须要借助 APNs<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup> 的力量。这一步是无论如何都绕不开的，所以市面上所有的第三方 iOS 推送服务都相当于是在官方的渠道上封装了一层，不过这比起自己架设服务器来说还是便捷了不少。</p>
<p>于是，各种配置还是必不可少的，区别只在最后生成的证书是你自己管还是让第三方托管。那么具体需要做些什么呢？</p>
<h3 id="Enabling-Push-Notification-Service">Enabling Push Notification Service</h3>
<p>这一步在 Xcode 中操作非常简单，就只需要两步：</p>
<ol>
<li>在 Xcode 应用设置的 General 标签栏下设置 App 的 Bundle Identifier</li>
<li>在 Capabilities 标签栏下打开消息推送的开关<br>
<img src="/uploads/push-notification-preparation/push-off.jpg" alt="push-off">￼</li>
</ol>
<p>等它加载一会，成功后会变成这个样子：<br>
<img src="/uploads/push-notification-preparation/push-on.jpg" alt="push-on"></p>
<p>这是为了告诉苹果：“我这个 ID 对应的 App 是要接收消息推送的”。</p>
<h3 id="SSL-Certificate">SSL Certificate</h3>
<p>完成了上面那一步之后，去到 Member Center 里找到刚刚填的那个 App ID，会看到下面 Push Notifications 的状态是两个黄黄的 “Configurable”，那说明现在已经万事俱备，只欠证书啦！</p>
<p>点编辑进去，果真如此：<br>
<img src="/uploads/push-notification-preparation/apple-push-notification.jpg" alt="apple-push-notification"></p>
<p>如果是在开发环境下，点 Development SSL Certificate 里面的 “Create Certificate…” 会有教程教你怎么申请自己的 CSR 文件，其实就是下面这张图这里：<br>
<img src="/uploads/push-notification-preparation/request-csr.jpg" alt="request-csr"></p>
<p>在弹出窗口的 “Request is” 后面选 “Saved to disk”，然后就可以在指定位置找到一个 “.certSigningRequest” 文件，把它上传到刚刚的网页上就可以了。</p>
<p>传好之后点击 “Generate” 就可以生成属于你的 SSL 证书。把它下载下来，双击安装，然后就可以在 Keychain Access 里面找到对应的 Push Services 证书，在开发的过程中，Xcode会自动找到这里的证书并打包到对应的 App 里面去。</p>
<h3 id="小结">小结</h3>
<p>如果使用的是第三方的服务，在生成了 SSL 证书之后，通常还需要将它的私钥导出为一个 .p12 后缀的文件，上传到第三方的服务器上。这就相当于授权了第三方使用你的身份去发推送消息了。如果你自己搭建了服务器，那就还需要将 .p12 文件转为 .pem 文件才能使用。这些都是后话了。</p>
<blockquote>
<p>关于数字证书的相关知识，可以看看导师大人写的这篇<a href="http://www.enkichen.com/2016/04/12/certification-and-pki/">《PKI系统与数字证书结构》</a>。</p>
</blockquote>
<p>P.S. 在应用要发布之前，还需要再走一遍上面的证书申请流程，不过这次要申请的是 Production SSL Certificate。</p>
<h2 id="Android">Android</h2>
<p>得益于其开放的生态环境，对比于 iOS 端，Android 这边几乎看不到什么证书相关的操作。</p>
<p>类似于 APNs，Android 也有一套推送服务，叫 FCM<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>。它的强大之处在于：它还提供了对 iOS 设备的推送服务。如果想要选择一个有背景的、可媲美官方可靠性的（人家本来就是 Google 官方…）第三方推送服务商，FCM 绝对是一个不错的选择。</p>
<p>Google 已经把 FCM 很好地封装成 SDK 了，再加上已经不需要考虑证书的问题，你要做的就只是在网页上把 FCM 配置好，并把它的 SDK 下载下来，放到项目中。</p>
<blockquote>
<p>可以参考 <a href="https://firebase.google.com/docs/cloud-messaging/android/client#set-up-firebase-and-the-fcm-sdk">Set Up a Firebase Cloud Messaging Client App on Android<br>
</a>和 <a href="https://firebase.google.com/docs/android/setup#prerequisites">Add Firebase to your Android Project</a>。</p>
</blockquote>
<h2 id="写在结尾">写在结尾</h2>
<p>没想到抛开了证书问题，Android 的准备工作就可以浓缩到一个小节里面了（虽然那两个网页也够看一会了），iOS可是洋洋洒洒分了三个部分呢。<br>
上面也只是介绍了开发消息推送的前期准备工作，做完这些之后才是我们程序员老本行的开始。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://www.raywenderlich.com/123862/push-notifications-tutorial">Push Notifications Tutorial: Getting Started</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/Introduction.html">About Local and Remote Notifications</a></li>
<li><a href="https://firebase.google.com/">Firebase</a></li>
</ul>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>国外： <a href="https://www.parse.com/">Parse</a>、<a href="https://firebase.google.com/">FCM（原来的 GCM ）</a>；国内： <a href="https://www.jpush.cn/">极光推送（ JPush ）</a>、 <a href="http://www.getui.com/">个推</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>即 <a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/ApplePushService.html">Apple Push Notification service</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>即 <a href="https://firebase.google.com/docs/cloud-messaging/">Firebase Cloud Messaging</a>，前身是 Google Cloud Messaging ( GCM ) <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"8225264e14e677544541","clientSecret":"ed2a2c6d5043e9f0b41cae78b0d5b4571099de53","repo":"HexoBlogSource","owner":"davidleee","admin":["davidleee"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>Android</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>不一样的 macOS Storyboard</title>
    <url>/2018/08/21/storyboard-in-macos/</url>
    <content><![CDATA[<p>从 iOS 转来 macOS 阵营已经有几个月了，断断续续踩了一些这样那样的坑，特此写一个系列记录下来。这个系列碰到的问题都是已经找到了解决方法的，希望对其他人也能有些帮助。</p>
<blockquote>
<p>这是 macOS 开发系列的第一篇文章。</p>
<p>从项目开始的地方讲起 —— Storyboard。</p>
</blockquote>
<span id="more"></span>
<h2 id="Main-Storyboard">Main.Storyboard</h2>
<p>新建 macOS 项目的时候，如果勾上了 “Use Storyboards” 的话，工程里会自带了一个 “Main.storyboard”。</p>
<p>打开看看，发现跟 iOS 项目中的样子大同小异，不同的地方在于，原来的 “Navigation Controller” 在这里变成了 “Window Controller”，而且上面还多了一个没见过的 “Main Menu”。（关于菜单的内容会在第三篇文章里讲到）</p>
<p><img src="/uploads/storyboard-in-macos/4BB6559C-64F4-421D-A8D5-6427C96EF774.png" alt=""></p>
<p>如果把应用跑起来，会发现 “Window Controller” 对应的是应用的启动窗口，而 “Main Menu” 对应的是显示在顶部的系统菜单栏。</p>
<p><img src="/uploads/storyboard-in-macos/6D230E15-056A-495D-8063-96FA6F4E9792.png" alt=""></p>
<p>到目前为止，一切都还是合乎逻辑的，直到某天我手贱把 Main.storyboard 删掉了…</p>
<h2 id="自定义-Storyboard">自定义 Storyboard</h2>
<p>按照我们在 iOS 里学来的经验，这没什么大不了的嘛！</p>
<p>让我们重新创建一个 Storyboard<br>
<img src="/uploads/storyboard-in-macos/AAA78593-47E1-4E34-A6FE-34D08C3D5328.png" alt=""></p>
<p>拖一个 “Window Controller” 出来，程序入口也要设置上（就是图片中间那个小箭头，位置在 Window Controller -&gt; Attributes Inspector -&gt; “Is Initial Controller”）<br>
<img src="/uploads/storyboard-in-macos/7BCBD120-A01E-48A9-9146-9A07CD956C81.png" alt=""></p>
<p>然后到项目配置里设置一下<br>
<img src="/uploads/storyboard-in-macos/35E29846-E2B3-4A94-A221-C9CB866FFC42.png" alt=""></p>
<p>Done！好像忘了点什么…不过先跑起来看看！<br>
<img src="/uploads/storyboard-in-macos/7AC50D3E-EF1B-43AE-80CE-0D12D5520CFE.png" alt=""></p>
<p>Emmm….菜单栏你怎么了！我的菜单栏呢！</p>
<h2 id="拯救被误删的-Main-storyboard">拯救被误删的 Main.storyboard</h2>
<p>回到新建的 ”Main.storyboard“ 里瞅瞅，发现跟自带的 Storyboard 相比，少了 “Main Menu“ 这个玩意儿，相应的，在左边的场景列表里，应该要有一个叫 “Application Scene” 的场景。</p>
<p><img src="/uploads/storyboard-in-macos/BCD3A74F-812C-47F1-992C-E8BA3E1B5EE1.png" alt=""></p>
<p>翻遍了控件库，都没有找到任何与 “Application” 和 “Main Menu” 相关的东西，最后在一个 StackOverflow 的问题里找到了答案</p>
<blockquote>
<p><a href="https://stackoverflow.com/questions/24418936/create-application-scene-in-blank-os-x-storyboard">macos - Create Application Scene in blank OS X Storyboard - Stack Overflow</a></p>
</blockquote>
<p>简单总结一下就是：即使时隔多年，macOS 上还是不怎么支持让一个不是基于 Storyboard 开发的应用升级到使用 Storyboard 的版本，所以控件库里压根就没有提供 Application Scene。</p>
<p>难道就没有办法了？</p>
<p>虽然没有试过在非 Storyboard 项目上集成 Storyboard，但是对于误删的情况还是有救的：（答案也来自于上面的链接里）</p>
<ol>
<li>创建一个新的、带 Storyboard 的项目</li>
<li>查看新项目里的 Main.storyboard 的源码</li>
<li>将下图 <code>&lt;!--Application--&gt;</code> 注释下面的 <code>&lt;Scene&gt;...&lt;/Scene&gt;</code> 的全部内容都拷贝到我们刚刚新创建的 Storyboard 里面<br>
<img src="/uploads/storyboard-in-macos/35685F05-E093-4A08-93B4-80332BE704B0.png" alt=""></li>
</ol>
<p>保存后重新打开 Storyboard，你会发现世界又恢复到原本的样子了！我们的菜单栏终于又回来了！</p>
<p>当然，因为是复制粘贴过来的，菜单栏里的一些信息还是新项目里的样子，在 Storyboard 稍加修改就可以了。</p>
<h2 id="总结">总结</h2>
<p>虽说长得差不多，但 macOS 开发里用到的 Storyboard 和 iOS 上的还是有不少的出入。</p>
<p>比如有时候 IB 里修改了文案，但是跑起来却不一样了，那可能是 Storyboard 生成了国际化配置文件，在里面搜索一下也许会找到元凶：<br>
<img src="/uploads/storyboard-in-macos/E490581B-53D5-4537-97B2-FC377985545E.png" alt=""></p>
<p>而更多的时候，在 IB 里调整了颜色之类的配置是不能直接看到效果的，还是要跑起来验证一下，以实际运行效果为准。</p>
<p>总而言之，在 macOS 开发过程中使用 Storyboard 需要更多的耐心和实际运行验证，这样的情况也许要到 macOS 支持 UIKit 的时候才能改善了。</p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"8225264e14e677544541","clientSecret":"ed2a2c6d5043e9f0b41cae78b0d5b4571099de53","repo":"HexoBlogSource","owner":"davidleee","admin":["davidleee"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>Swift</tag>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>SwiftUI 系列教程（1）—— 初识 SwiftUI</title>
    <url>/2019/06/12/swiftui-serial-tutorial-1/</url>
    <content><![CDATA[<blockquote>
<p>可能是全网最早的 SwiftUI 中文教程？</p>
</blockquote>
<p>这篇文章来源于苹果官方的教程，相当于是我自己学习过程的一个记录。这个系列教程会跟着官方教程构造一个新的项目，还会加入一些 WWDC 的东西作为补充，可能偶尔会有一些自由发挥的部分。（不过我这里是做不出官方教程那种酷炫的动画了…）</p>
<span id="more"></span>
<h2 id="全新的编码体验！">全新的编码体验！</h2>
<p>目前（2019.6.5）要体验到这个新东西，需要用到 <strong>Xcode 11 beta</strong>，而如果要体验新的预览机制和对画布上的预览进行操作，还需要把系统更新到 <strong>macOS Catalina 10.15 beta</strong>， 看来这个系列的新功能提供了系统层面的支持。</p>
<blockquote>
<p>话说回来，下了 iPadOS 之后用 iTunes 死活升不上去，报错说 macOS 有软件要更新，但总更新失败，最后下载 Xcode 11 beta 让它跑完 install components 那一步就可以成功升级 iPad 了…告诉我不是一个人…</p>
</blockquote>
<p>让我们先用新鲜热辣的 Xcode 11 beta 创建一个项目吧！</p>
<p>前面的步骤身为 iOS 开发的同学们应该很熟悉了，这里要创建的是 Xcode project -&gt; Single View App（playground 我还没试过，也许也被“强化”过了？），然后在取名字的那一步稍作停留，瞧瞧我在打勾区发现了什么：<strong>Use SwiftUI</strong>！当然选择钩上它！</p>
<p><img src="/uploads/swiftui-serial-tutorial-1/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A72019-06-10%E4%B8%8B%E5%8D%889.55.44.png" alt=""></p>
<p>完事之后我们就可以看到熟悉又带点陌生的编辑器界面了。点开默认提供给我们的 <em>ContentView.swift</em>，可以看到里面已经写好了两个 <code>struct</code>：<br>
<img src="/uploads/swiftui-serial-tutorial-1/F31CF147-5F01-422B-8ECB-C9AEFC274150.png" alt=""></p>
<hr>
<p>先打个岔，看看编辑区域右边新加入的 Minimap 界面，这虽然是一个在代码编辑器中比较常见的功能，但苹果一出手，还是给改进了一番：</p>
<ol>
<li>当鼠标在 Minimap 移动时，会像上图那样高亮并在左边把对应方法或变量名凸显出来，此时点击任意一块高亮区域都可以跳转到对应的代码位置</li>
<li>鼠标放在 Minimap 上时，按住 Command 键，所有的方法和变量名都会凸显出来（上图其实是按下了 Command 后的状态），重要的代码结构一目了然</li>
</ol>
<blockquote>
<p>苹果的每次大更新，着重宣传的主要变化，在我都尝试一遍之后就没什么感觉了，反而是这些小地方特别打动我</p>
</blockquote>
<hr>
<p>言归正传，看回代码。</p>
<p>这两个是 SwiftUI 默认提供的结构体，其中遵循 <code>View</code> 协议的那个定义了我们的界面内容和布局，而遵循 <code>PreviewProvider</code> 协议的那个则负责处理这个界面的预览。</p>
<p>那什么是预览？我们可以先把旁边的所谓预览窗口跑起来，点击右上角的 <em>Resume</em>（这个版本的 Xcode 默认会显示下图这个界面，没有的话，也可以在 <em>Editor</em> 里面打开它）：<br>
<img src="/uploads/swiftui-serial-tutorial-1/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A72019-06-10%E4%B8%8B%E5%8D%8810.22.22.png" alt=""></p>
<p>这时，Xcode 会把我们的项目运行起来，就跟平时点 <em>Run</em> 跑到模拟器上一样。有所不同的是，这次的模拟器直接显示成了 Xcode 的一个子界面，我们甚至可以直接操作这个模拟器里的视图，就像操作 xib 和 storyboard 一样！</p>
<p><img src="/uploads/swiftui-serial-tutorial-1/38B1BE43-FECA-471C-A845-FBFB8E5FA2C0.png" alt=""></p>
<blockquote>
<p>仔细看，点选了界面上的文案之后，左侧编辑器里相应的视图代码也被高亮了起来，是不是有一种根据按钮事件找 IBAction 代码的感觉？</p>
</blockquote>
<p>尝试修改一下代码里 <code>Text</code> 中的内容，会发现模拟器里的显示也实时更新了！对这个更加强大的模拟器，苹果给它起了个名字叫 <strong>画布（Canvas）</strong>。</p>
<h2 id="自定义文本视图">自定义文本视图</h2>
<p>那既然 <strong>画布</strong> 有着跟 Storyboard 相似的体验，那是不是意味着我们也可以直接改动界面上的元素？答案是肯定的，所有功能都隐藏在 Command + 左键点击里：<br>
<img src="/uploads/swiftui-serial-tutorial-1/AA6AA015-7832-46DD-83E7-063BC1631D83.png" alt=""></p>
<p>点击后会出现一个内容丰富的弹出框，这些操作会根据点击的视图不同而不同。</p>
<p>我们可以通过 <em>Inspect…</em> 来修改视图的一些基本元素：<br>
<img src="/uploads/swiftui-serial-tutorial-1/D0D9CEBC-7A12-4479-9541-34C80D177817.png" alt=""></p>
<blockquote>
<p>图上应该能看出来，这个弹出框是可以滚动的，它已经可以取代原来我们常用的 Attributes Inspector。实际上，如果你在这个时候点开右侧边栏，会发现 Attributes Inspector 的内容跟这里是完全一致的</p>
</blockquote>
<p>我们来把它的字体改为 <em>Large Title</em>，可以看到代码部分也跟着界面一起改变了：<br>
<img src="/uploads/swiftui-serial-tutorial-1/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A72019-06-10%E4%B8%8B%E5%8D%8810.38.09.png" alt=""></p>
<p>按照这个规律，我们通过手写代码来改个字体颜色试试：<br>
<img src="/uploads/swiftui-serial-tutorial-1/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A72019-06-10%E4%B8%8B%E5%8D%8810.40.22.png" alt=""></p>
<p>这种链式调用的语法是不是跟用 OC 实现的 AutoLayout 开源库 <a href="https://github.com/SnapKit/Masonry">Masonry</a> 很像呢？苹果把这些方法叫做 <em>修饰器(modifiers)</em>，它们会在旧视图的基础上构造一个新视图返回出来，这使得上述的链式调用成为可能。</p>
<blockquote>
<p>如果我们再从刚才的 <em>Inspect…</em> 里把字体颜色改为 <em>inherited</em>，就会发现 Xcode 把我们刚加上的 <code>.color(.red)</code> 又给删掉了，这波操作让写代码有意思了不少啊。</p>
</blockquote>
<h2 id="把视图都叠起来吧">把视图都叠起来吧</h2>
<p>在前面的内容里，我们通过 SwiftUI 来描述了我们想要的视图样式，但这只是单一的视图。当视图多起来的时候，我们可以通过 <em>stacks</em> 把视图在竖直方向、水平方向或从前往后组合起来。</p>
<p>注意力继续回到我们的新朋友画布上，这次我们加快一点速度，先对刚刚的文本进行 <em>Embed in VStack</em> 的操作：<br>
<img src="/uploads/swiftui-serial-tutorial-1/32BB01AF-9406-41A2-8CA6-61F10F511D3A.png" alt=""></p>
<p>然后通过 Command + shift + L 调出视图库界面：<br>
<img src="/uploads/swiftui-serial-tutorial-1/73CBCF80-9712-48AA-9049-AD8641FC0269.png" alt=""></p>
<p>从里面拖一个 <code>Text</code> 到编辑器里（对，没错，就是编辑器，它会自动变成代码），放到我们之前操作的 <code>Text</code> 之下。现在我们的代码应该变成这个样子了：<br>
<img src="/uploads/swiftui-serial-tutorial-1/54973458-B739-467A-A6E9-B28081FEC640.png" alt=""></p>
<blockquote>
<p>从视图库拖组件出来这一步，我们有两种选择：一种是拖到代码里，另一种是拖到 Canvas 上。大家可以尝试一下拖到界面上会有什么样的效果。</p>
</blockquote>
<p>稍后我们再回过头来看这个 <code>VStack</code> 是什么。现在让我们继续快进，加入两个没见过的新组件 <code>HStack</code> 和 <code>Spacer</code>，通过给 <code>VStack</code> 加上参数来进行布局，还要再通过修饰器美化一下界面，最后 <code>ContentView</code> 的内容应该是这个样子的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span> : <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span>(alignment: .leading) &#123;</span><br><span class="line">            <span class="type">Text</span>(“<span class="type">Hello</span> <span class="type">SwiftUI</span>”)</span><br><span class="line">                .font(.largeTitle)</span><br><span class="line">                <span class="type">HStack</span> &#123;</span><br><span class="line">                    <span class="type">Text</span>(“<span class="type">First</span> <span class="type">Description</span>”)</span><br><span class="line">                        .font(.subheadline)</span><br><span class="line">                    <span class="type">Spacer</span>()</span><br><span class="line">                    <span class="type">Text</span>(“<span class="type">Second</span> <span class="type">Description</span>”)</span><br><span class="line">                        .font(.subheadline)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .padding()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相应的，我们的界面也成了这样：<br>
<img src="/uploads/swiftui-serial-tutorial-1/33A162A9-B3E2-4938-80DD-A7B752AC2098.png" alt=""></p>
<h2 id="幕后发生了什么？">幕后发生了什么？</h2>
<p>刚才的代码里，起到容器作用的是 <code>VStack</code> 和 <code>HStack</code>，顾名思义，它们分别是竖直方向上和水平方向上的层叠视图（Vertical &amp; Horizontal），用法跟我们早就认识的 <code>StackView</code> 相同。</p>
<p>到目前为止，有过前端开发经验的同学们应该能发现，这不就是 JSX 的语法吗？</p>
<p>我们知道，在实现一个新界面的时候，通常包含着“用基本组件就能实现”的常规部分和“要把奇技淫巧发挥到极致”的出彩部分。SwiftUI 的出现就是为了简化常规 UI 的开发过程，让开发者能够把精力都放在激动人心的部分。</p>
<blockquote>
<p>—— 摘自 WWDC</p>
</blockquote>
<p>为了达到这个目的，一个首要的改变就是：<strong>把命令式的视图逻辑转变为声明式的</strong>。这样做的好处在于：</p>
<ol>
<li>提高了组件的复用性</li>
<li>代码更清晰易懂，在编写的过程中也更符合直觉</li>
<li>隐藏了背后复杂的部分，让 SwiftUI 帮我们料理好一切</li>
</ol>
<p>这样转变之后，整个视图层级的代码看起来就清晰了许多（对比一下用单纯的 Swift 来实现会有多少代码），然而这种转变的背后其实都是我们熟悉的 Swift 语法。举个例子，<code>VStack</code> 本身就是一个 <code>View</code>，它的实现是这样的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">VStack</span>&lt;<span class="title">Content</span>: <span class="title">View</span>&gt; : <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">init</span>(</span></span><br><span class="line"><span class="function">        <span class="params">alignment</span>: <span class="type">HorizontalAlignment</span> <span class="operator">=</span> .center,</span></span><br><span class="line"><span class="function">        <span class="params">spacing</span>: <span class="type">Length</span>? <span class="operator">=</span> <span class="literal">nil</span>,</span></span><br><span class="line"><span class="function">        <span class="meta">@ViewBuilder</span> <span class="params">content</span>: () -&gt; <span class="type">Content</span></span></span><br><span class="line"><span class="function">    )</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>alignment</code> 和 <code>spacing</code> 是两个布局用的属性，我们在之前的例子里就设置了 <code>VStack(alignment: .leading)</code>，这可以让内部的元素左对齐；而 <code>content</code> 属性则是一个闭包，它将返回另外一个视图，里面包含了所有要显示在 <code>VStack</code> 里的子视图。</p>
<p><code>VStack</code> 和 <code>HStack</code> 在 SwiftUI 里被用到时候，其实就是调用了它的构造方法，因为前两个参数要么是有默认值的，要么是可选的，所以只需要关注最后一个闭包参数；而这个闭包参数作为参数列表里的最后一员，可以写作结尾闭包的样子，于是就有了我们上面例子中的写法。</p>
<p>剩下的 <code>Spacer()</code> 和 <code>.padding()</code> 就只不过是 SwiftUI 提供给我们的又一个常规组件和修饰器而已了。</p>
<h2 id="小结">小结</h2>
<p>写到这里，仅仅涵盖了官方教程第一章里的前3部分，外加一点来自 WWDC 视频里的内容。我还会继续补充，努力把整个教程都覆盖掉。</p>
<p>不过这就足以让我们看到它的好玩之处了，至少写了一段时间 React Native 的我，看到这似曾相识的语法，着实感觉欣喜。苹果在为开发者打造工具上下的功夫，恐怕在历史所有科技型企业上也是数一数二的了。</p>
<h2 id="参考链接">参考链接</h2>
<p><a href="https://developer.apple.com/tutorials/swiftui/creating-and-combining-views">SwiftUI | Creating and Combining Views</a><br>
<a href="https://developer.apple.com/videos/play/wwdc2019/216/">SwiftUI Essentials - WWDC 2019 - Videos - Apple Developer</a></p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"8225264e14e677544541","clientSecret":"ed2a2c6d5043e9f0b41cae78b0d5b4571099de53","repo":"HexoBlogSource","owner":"davidleee","admin":["davidleee"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>Swift</tag>
        <tag>SwiftUI</tag>
        <tag>Catalina</tag>
        <tag>VStack</tag>
        <tag>HStack</tag>
      </tags>
  </entry>
  <entry>
    <title>SwiftUI 系列教程（2）—— 与 UIKit 结合的自定义视图</title>
    <url>/2019/07/08/swiftui-serial-tutorial-2/</url>
    <content><![CDATA[<p>在<a href="/2019/06/12/swiftui-serial-tutorial-1/" title="上一篇文章">上一篇文章</a>中，我们了解了 SwiftUI 的 <code>Text</code>  组件，并通过 <code>Stack</code> 系列的组件对内容进行了一些简单的布局。在这篇文章里，我们会认识一个全新的图片组件，并且会尝试利用这两篇文章的知识，结合 MapKit 框架，来实现一个简单的地点详情界面。</p>
<span id="more"></span>
<blockquote>
<p>写完第一篇文章之后，本职的开发任务突然进入了紧张的预发布阶段，搞得早就写好的第二篇文章拖了这么久才完成润色和发布，看来“全网最早”要丢了…</p>
</blockquote>
<h2 id="自定义图片视图">自定义图片视图</h2>
<p>首先把一张地标图片放到 <em>Assets.xcassets</em> 里去，我在百度找了张广州塔的照片：<br>
<img src="/uploads/swiftui-serial-tutorial-2/BF6A8678-F10F-4633-A932-94B781BE73F9.png" alt=""></p>
<p>然后，我们要为新的图片视图创建一个新的类，就放在上一篇文章的 <em>ContentView.swift</em> 旁边好了。新建文件的时候，选择 <strong>SwiftUI View</strong>：<br>
<img src="/uploads/swiftui-serial-tutorial-2/8A140752-2AE7-40E5-B320-F9DF7ADECE5C.png" alt=""></p>
<p>取个名字叫 CircleImage，因为我们将要在这里把广州塔裁剪成一个圆。新建的代码内容跟上一章看到的一样，我们把 <code>Text</code> 改成 <code>Image</code>，然后把图片的名字传进去，直接就可以通过预览在画布上看到我们的图片了：<br>
<img src="/uploads/swiftui-serial-tutorial-2/03DBC394-DA28-4686-87CA-117FCAC32CC6.png" alt=""></p>
<p>接下来我们在代码里给它加上一个圆形的裁剪。原来的做法有很多了，最快速的做法应该是操作 <code>clipsToBounds</code> 和 <code>cornerRadius</code>，给图片加上长度等于一半宽高的圆角，这还得要求图片是正方形的才能达到满意的显示效果。</p>
<p>而在 SwiftUI 里，这就是一句话的事情：<br>
<img src="/uploads/swiftui-serial-tutorial-2/D1D63EE5-2169-40D0-ACAB-F68AE4EED5EB.png" alt=""></p>
<p><code>.clipShape()</code> 给图片加了个裁剪的形状，其中 <code>Circle</code> 类型是一个用来当作遮罩的图形，你也可以给它加上填充色或者描边来单独使用，类似于以往通过 <code>CALayer</code> 去实现的效果。</p>
<p>但这也太大了，我们的屏幕装不下，我们可以再加两行代码，把图片缩放到一个合适的大小：<br>
<img src="/uploads/swiftui-serial-tutorial-2/E0470CA5-E465-4D53-8E1A-555C180DED64.png" alt=""></p>
<blockquote>
<p>讲道理，这里设置的宽高应该是一样的，毕竟是个圆嘛…但是我懒得重新截图了，各位童鞋自己调整一下数值就可以了</p>
</blockquote>
<p>为了让图片本身在不同背景下都能凸显出来，我们再给它加个描边，这要通过 <code>overlay()</code> 方法去实现；也许再加个阴影吧，用到的是 <code>shadow()</code> 方法；最后出来的效果是这样的：<br>
<img src="/uploads/swiftui-serial-tutorial-2/1263812F-2159-4AD5-9B21-50A314CFA99C.png" alt=""></p>
<p>是不是醒目多啦？</p>
<blockquote>
<p>每当做完一个新视图，我就想对比一下用老方法实现同样的效果有什么不同…</p>
</blockquote>
<h2 id="在-SwiftUI-里使用-UIKit">在 SwiftUI 里使用 UIKit</h2>
<p>不知道大家发现了没有，我们在 SwiftUI 里用到的视图全部都是 <code>struct</code>，这意味着它们跟我们原本熟悉的 UIKit 是两套不同的机制，那难道以前开发的视图就完全用不上了吗？</p>
<p>答案是可以的。</p>
<p>要在 SwiftUI 里使用 UIView 的子类，只需要把它用一个遵循 <code>UIViewRepresentable</code> 协议的 SwiftUI 视图包裹起来即可。</p>
<blockquote>
<p>这里举的是 UIKit 的例子，但同样也适用于 AppKit 和 WatchKit。</p>
</blockquote>
<p>我们再来创建一个新的 SwiftUI View 来做我们的地图界面，但这一次，我们要改一下内容视图的协议：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"><span class="keyword">import</span> MapKit <span class="comment">// 引入 MapKit</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MapView</span> : <span class="title">UIViewRepresentable</span> </span>&#123; <span class="comment">// 把这里的协议改掉</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(“<span class="type">Hello</span> <span class="type">World</span>!”)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后你会发现 Xcode 在 <code>UIViewRepresentable</code> 这里报错了，因为这个协议下有两个必须实现的方法：</p>
<ol>
<li><code>makeUIView(context:)</code> 用来创建我们的 <code>MKMapView</code></li>
<li><code>updateUIView(_:context:)</code> 用来进行视图的配置，并响应后续可能的变化</li>
</ol>
<p>那下面我们就来实现一下。再加新代码之前，可以把已经用不上的 <code>body</code> 部分先删掉了。</p>
<p>对于 <code>makeUIView(context:)</code>，只需要声明它返回的是 <code>MKMapView</code> 然后直接通过构造方法返回一个空对象就可以了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeUIView</span>(<span class="params">context</span>: <span class="type">UIViewRepresentableContext</span>&lt;<span class="type">MapView</span>&gt;)</span> -&gt; <span class="type">MKMapView</span> &#123;</span><br><span class="line">    <span class="type">MKMapView</span>(frame: .zero)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>updateUIView(_:context:)</code> 要做的事情就比较多了，我们一步步说：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateUIView</span>(<span class="keyword">_</span> <span class="params">uiView</span>: <span class="type">MKMapView</span>, <span class="params">context</span>: <span class="type">UIViewRepresentableContext</span>&lt;<span class="type">MapView</span>&gt;)</span> &#123;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">let</span> coordinate <span class="operator">=</span> <span class="type">CLLocationCoordinate2D</span>(latitude: <span class="number">23.112223</span>, longitude: <span class="number">113.331084</span>)</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">let</span> span <span class="operator">=</span> <span class="type">MKCoordinateSpan</span>(latitudeDelta: <span class="number">0.01</span>, longitudeDelta: <span class="number">0.01</span>)</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">let</span> region <span class="operator">=</span> <span class="type">MKCoordinateRegion</span>(center: coordinate, span: span)</span><br><span class="line">    uiView.setRegion(region, animated: <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>先把表示广州塔坐标的对象给构造出来（这是我在网上查的，等会预览的时候看看准不准）</li>
<li>构造一个用来标识地图的缩放等级的对象，数值越小地图拉得越近</li>
<li>构造坐标区域，并把这个区域设置到我们的地图视图上</li>
</ol>
<p>赶紧预览一下看看效果吧！你会发现画布上空白一片…</p>
<p>那是因为预览默认是静态模式的，它只能完整渲染 SwiftUI 的视图。因为我们现在用到了 UIView 的子类，所以要把预览切换到实时模式（右下角红框里的按钮）：<br>
<img src="/uploads/swiftui-serial-tutorial-2/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A72019-06-16%E4%B8%8B%E5%8D%887.28.49.png" alt=""></p>
<p>emmmm…塔呢？这定位看起来也不是很准啊。</p>
<h2 id="把一切都组装起来吧！">把一切都组装起来吧！</h2>
<p>先看看预期实现的效果图：<br>
<img src="/uploads/swiftui-serial-tutorial-2/973ba702-85db-4852-851f-86a94cfca002.png" alt=""></p>
<p>然后花一点时间思考一下怎么弄，我们这两篇文章的知识是完全足够了的。</p>
<p>好啦！公布答案！</p>
<p>我们会在上一篇文章实现的 <code>ContentView</code> 里直接进行组装，下面来看看分解动作：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123; <span class="comment">// 1</span></span><br><span class="line">            <span class="type">MapView</span>() </span><br><span class="line">                .edgesIgnoringSafeArea(.top) <span class="comment">// 2.1</span></span><br><span class="line">                .frame(height: <span class="number">300</span>) <span class="comment">// 2.2</span></span><br><span class="line"></span><br><span class="line">            <span class="type">CircleImage</span>()</span><br><span class="line">                .offset(y: <span class="operator">-</span><span class="number">100</span>)</span><br><span class="line">                .padding(.bottom, <span class="operator">-</span><span class="number">100</span>) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">            <span class="type">VStack</span>(alignment: .leading) &#123;</span><br><span class="line">                <span class="type">Text</span>(“<span class="type">Hello</span> <span class="type">SwiftUI</span>”)</span><br><span class="line">                    .font(.title)</span><br><span class="line">                <span class="type">HStack</span>(alignment: .top) &#123;</span><br><span class="line">                    <span class="type">Text</span>(“<span class="type">First</span> <span class="type">Description</span>”)</span><br><span class="line">                        .font(.subheadline)</span><br><span class="line">                    <span class="type">Spacer</span>()</span><br><span class="line">                    <span class="type">Text</span>(“<span class="type">Second</span> <span class="type">Description</span>”)</span><br><span class="line">                        .font(.subheadline)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .padding()</span><br><span class="line"></span><br><span class="line">            <span class="type">Spacer</span>() <span class="comment">// 4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>先用一个 <code>VStack</code> 把所有内容包裹起来，默认情况下 <code>VStack</code> 的内容布局是居中的，所以我们不需要做修改</li>
<li>针对 <code>MapView</code> 我们要做两个修改
<ol>
<li><code>edgesIgnoringSafeArea</code> 可以让我们的视图把系统预留给刘海和状态栏的区域也用掉，这样看起来会更自然一点</li>
<li>对于只设置了 <code>height</code> 的视图，它的宽度会默认占满所有父视图里的可用空间</li>
</ol>
</li>
<li>我们的图片视图本身已经实现了所有效果了，现在只需要调整一下位置即可。需要注意的是，因为这里是通过 <code>offset</code> 移动的，所以为了保持与底部文字的间距，特意加上了一个负的 <code>padding</code> 来抵消掉位移导致的差距</li>
<li>做完前三步的操作后，这个 <code>VStack</code> 整体是在竖直方向上居中的，所以加上一个 <code>Spacer</code> 把整体有内容的部分顶到最上面（其实也可以通过 <code>HStack</code> 的 <code>alignment</code>来实现，不过那样代码就没有现在的简单优雅了）</li>
</ol>
<p>最终成果：<br>
<img src="/uploads/swiftui-serial-tutorial-2/EF653793-4B81-42D7-9B53-00790EE31E8F.png" alt=""></p>
<blockquote>
<p>如果你发现照着实现出来之后，中间圆形部分特别大的话，别担心，你是对的！<br>
因为文章前面的 <code>CircleImage</code> 确实是为了展示而特意设置得比较大的，所以调整一下里面的宽高即可。</p>
</blockquote>
<h2 id="小结">小结</h2>
<p>到这里大家应该对 SwiftUI 的使用比较上手了，但目前为止涉及到的组件还比较少，SwiftUI 光是各种强大的组件就已经够玩很久了。不过我打算在第四篇文章里再集中讲各种有意思的组件使用方式，因为下一篇文章我们要先解决数据来源的问题。</p>
<p>既然我们的视图组件已经是通过声明式的写法来构建的了，那我们的数据是不是也该换一种方式绑定到视图上呢？在 JS 上我们可以用 react-redux 这样的数据绑定手段，那 SwiftUI 是不是该搭配 RxSwift 来使用了？</p>
<p>这些问题都将在下一篇文章里为大家解答！</p>
<h2 id="参考链接">参考链接</h2>
<p><a href="https://developer.apple.com/tutorials/swiftui/creating-and-combining-views">SwiftUI | Creating and Combining Views</a><br>
<a href="https://developer.apple.com/videos/play/wwdc2019/216/">SwiftUI Essentials - WWDC 2019 - Videos - Apple Developer</a></p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"8225264e14e677544541","clientSecret":"ed2a2c6d5043e9f0b41cae78b0d5b4571099de53","repo":"HexoBlogSource","owner":"davidleee","admin":["davidleee"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>Swift</tag>
        <tag>SwiftUI</tag>
        <tag>Image</tag>
        <tag>UIView</tag>
        <tag>UIViewRepresentable</tag>
        <tag>MKMapView</tag>
        <tag>Spacer</tag>
      </tags>
  </entry>
  <entry>
    <title>SwiftUI 系列教程（3）—— SwiftUI 数据流</title>
    <url>/2019/07/25/swiftui-serial-tutorial-3/</url>
    <content><![CDATA[<p>通过前两篇文章（SwiftUI 系列教程 <a href="/2019/06/12/swiftui-serial-tutorial-1/" title="（1）">（1）</a> 和 <a href="/2019/07/08/swiftui-serial-tutorial-2/" title="（2）">（2）</a>），我们已经看到了 SwiftUI 是怎么运作的了，对于常规的界面元素来说，使用 SwiftUI 确实能带来不小的生产力提升。但是在前面的例子里，我们用到的数据全都是写死的，这跟复杂多变的真实需求可不大一样。这篇文章我们就来了解一下，SwiftUI 里用到的全新的数据流模型。</p>
<blockquote>
<p>相比起前两篇实操文，这篇文章可能会比较干，请大家看文章之前先访问一下饮水机。</p>
</blockquote>
<span id="more"></span>
<h2 id="先看看别人家是怎么做的">先看看别人家是怎么做的</h2>
<h3 id="老东家">老东家</h3>
<p>学习过斯坦福公开课的小伙伴们应该对下面这张图片很有印象了：<br>
<img src="/uploads/swiftui-serial-tutorial-3/mvc1.png" alt=""></p>
<p>这是 iOS 自出道以来就非常推崇的，可谓是“官方建议”的数据流模型，也就是大家都熟知的 MVC 模式。</p>
<p>从 GUI 开始兴起以来，基于职责分离的思想，工程师们慢慢把管理用户界面的 View 和管理用户数据的 Model 给区分了开来；而从 Smalltalk 的某个版本开始，为了进一步降低图形应用程序的管理难度，设计出了 MVC 模式。MVC 的出现主要是为了解决这两个问题：</p>
<ol>
<li>如何管理响应用户操作的业务逻辑</li>
<li>View 如何同步 Model 的变化</li>
</ol>
<p>解决这两个问题也是大多数为现代图形界面应用程序而诞生的设计模式们的目标，比如 MVVM、MVP。</p>
<h3 id="隔壁前端家">隔壁前端家</h3>
<p>因为有着一段不长不短的 React Native 开发经历（目前还在做着），所以从这个角度看过去，比较成熟的方案是 Redux + React Redux。</p>
<p>Redux 是专为 JavaScript 软件打造的一个可预测状态容器。听起来很厉害的样子，其实主要是做了三个事情：</p>
<ol>
<li>把 Model 层的数据统一放到一个地方</li>
<li>约定只能通过特定的手段去改变数据，除此之外，数据就是只读的</li>
<li>约定改变数据的操作必须是纯函数</li>
</ol>
<p>这样做了之后，我们就可以确定这个数据源是可以真实反应我们的应用状态的，所以叫做“可预测状态容器（Predictable State Container）”。</p>
<p>然后 React Redux 就好理解了，它的任务是建立一套机制，让上述的状态一一绑定到视图上，实现一条双向更新的通道。</p>
<blockquote>
<p>Redux 和 React Redux 都是 Redux 官方出品，所以质量还是比较有保证的。下面这两篇文章应该可以给大家技术选型的时候提供一些支持：<br>
<a href="https://redux.js.org/introduction/motivation">Motivation · Redux</a><br>
<a href="https://react-redux.js.org/introduction/why-use-react-redux">Why Use React Redux? · React Redux</a></p>
</blockquote>
<h2 id="Swift-的实现">Swift 的实现</h2>
<p>如果你觉得 SwiftUI 在构造界面时用到的声明式语法跟 JSX 的相似度很高的话，那在介绍完它的数据绑定逻辑之后，你肯定会再一次把它拿来跟 JavaScript 做比较了。</p>
<p>SwiftUI 中引入了一个关键字 <code>@State</code> 来作为数据绑定的标识。当一个被绑定的数据被改变时，相关联的视图会重新计算它自己的 <code>body</code> 内容；反过来，当视图主动去改变绑定在数据上的属性时，这个数据也会随之变化。这种双向绑定的机制就像 JSX + Redux + React Redux 的组合拳，只不过 SwiftUI 自己就把这些事情给做了。</p>
<p>但是，凭什么 SwiftUI 用几个关键字就实现了别人整整两个开源库的功能？其实这得益于 Swift 5.1 的新功能——属性包装（Property Wrappers）。</p>
<h3 id="深挖一点点">深挖一点点</h3>
<p>在 2019 年3月份的时候，Swift 核心团队里的成员已经透露出了一个作用类似于 <code>lazy</code> 关键字的新功能，那个时候它被称为“属性代理”（Property Delegates）。</p>
<p>举个例子，延迟初始化可谓是编程里的一种美德，在 Swift 的世界里，除了直接用 <code>lazy</code>，我们也可以用一个私有属性加上一个作为访问器的 Computed Property 来实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> _lazyProp: <span class="type">Prop</span>?</span><br><span class="line"><span class="keyword">var</span> lazyProp: <span class="type">Prop</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> value <span class="operator">=</span> _lazyProp &#123; <span class="keyword">return</span> value &#125;</span><br><span class="line">        <span class="keyword">let</span> initialValue <span class="operator">=</span> <span class="operator">...</span> <span class="comment">// 初始化数据</span></span><br><span class="line">        _lazyProp <span class="operator">=</span> initialValue</span><br><span class="line">        <span class="keyword">return</span> initialValue</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> &#123;</span><br><span class="line">        _lazyProp <span class="operator">=</span> newValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如今，Property Wrappers 为我们提供了第三条路可走，不仅如此，它还承诺会为开发者们提供了一种实现类似 <code>lazy</code> 关键字用法的途径。</p>
<p>在 SwiftUI 的功能提议 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0258-property-wrappers.md">SE-0258</a> 里可以看到，Property Wrappers 的主要目的就是为了避免开发者重复写出上面那种固定模式的代码。既然这种写法是比较固定的，那么就应该定义出一种机制，来把各种固定写法定义成一个个的工具库。</p>
<h3 id="官方的解决方案">官方的解决方案</h3>
<p>还是用 <code>lazy</code> 的例子，怎么用 Property Wrappers 来实现一个同样的功能呢？比如实现一个作用相同的 <code>@Lazy</code> 属性？</p>
<p>官方给出的解决方案是这样的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@propertyWrapper</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Lazy</span>&lt;<span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> uninitialized(() -&gt; <span class="type">Value</span>)</span><br><span class="line">  <span class="keyword">case</span> initialized(<span class="type">Value</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">init</span>(<span class="params">wrappedValue</span>: <span class="keyword">@autoclosure</span> <span class="keyword">@escaping</span> () -&gt; <span class="type">Value</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">self</span> <span class="operator">=</span> .uninitialized(wrappedValue)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> wrappedValue: <span class="type">Value</span> &#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">get</span> &#123;</span><br><span class="line">      <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> .uninitialized(<span class="keyword">let</span> initializer):</span><br><span class="line">        <span class="keyword">let</span> value <span class="operator">=</span> initializer()</span><br><span class="line">        <span class="keyword">self</span> <span class="operator">=</span> .initialized(value)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">      <span class="keyword">case</span> .initialized(<span class="keyword">let</span> value):</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> &#123;</span><br><span class="line">      <span class="keyword">self</span> <span class="operator">=</span> .initialized(newValue)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此一来，下面这种变量声明</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Lazy</span> <span class="keyword">var</span> foo <span class="operator">=</span> <span class="number">123</span></span><br></pre></td></tr></table></figure>
<p>就会被展开成这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> _foo: <span class="type">Lazy</span>&lt;<span class="type">Int</span>&gt; <span class="operator">=</span> <span class="type">Lazy</span>&lt;<span class="type">Int</span>&gt;(wrappedValue: <span class="number">123</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">var</span> foo: <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">get</span> &#123; <span class="keyword">return</span> _foo.wrappedValue &#125;</span><br><span class="line">  <span class="keyword">set</span> &#123; _foo.wrappedValue <span class="operator">=</span> newValue &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>调用了 <code>Lazy</code> 的 <code>init</code> 方法来进行初始化一个私有变量，它的类型是 <code>Lazy&lt;Int&gt;</code></li>
<li>通过把原变量包装成一个 Computed Value 的方式来对接 <code>wrappedValue</code> 里提供的真正的逻辑实现</li>
</ol>
<p>不仅如此，既然 <code>@Lazy</code> 是一个 <code>enum</code> ，那它本身就可以定义五花八门的公开方法，而每一个被 <code>@propertyWrapper</code> 标记的类型都可以通过定义一个 <code>projectedValue</code> 属性来实现一些骚操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@propertyWrapper</span><br><span class="line">enum Lazy&lt;Value&gt; &#123;</span><br><span class="line">    // ... 内容跟前面一样 ...</span><br><span class="line"></span><br><span class="line">    // 定义一个重置的方法，把 @Lazy 标记的变量还原为一个不同的初始值</span><br><span class="line">    public mutating func reset(_ newValue:  @autoclosure @escaping () -&gt; Value) &#123;</span><br><span class="line">        self = .uninitialized(newValue)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public var projectedValue: Self &#123;</span><br><span class="line">        get &#123; self &#125;</span><br><span class="line">        set &#123; self = newValue &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>声明了 <code>projectedValue</code> 之后 ，我们就自动获得了一个带 <code>$</code> 符号的分身用来访问我们 <code>projectedValue</code> 的 getter，从而调用到里面的方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Lazy</span> <span class="keyword">var</span> foo <span class="operator">=</span> <span class="number">123</span></span><br><span class="line"><span class="variable">$foo</span>.reset(<span class="number">456</span>)</span><br></pre></td></tr></table></figure>
<p>上面那句声明变量的语句，会展开成这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> _foo: <span class="type">Lazy</span>&lt;<span class="type">Int</span>&gt; <span class="operator">=</span> <span class="type">Lazy</span>&lt;<span class="type">Int</span>&gt;(wrappedValue: <span class="number">123</span>)</span><br><span class="line"><span class="keyword">var</span> foo: <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">get</span> &#123; <span class="keyword">return</span> _foo.wrappedValue &#125;</span><br><span class="line">  <span class="keyword">set</span> &#123; _foo.wrappedValue <span class="operator">=</span> newValue &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 上面跟原来一样，下面是添加了 projectedValue 之后新增的 ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="variable">$foo</span>: <span class="type">Lazy</span>&lt;<span class="type">Int</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">get</span> &#123; _foo.projectedValue &#125;</span><br><span class="line">  <span class="keyword">set</span> &#123; _foo.projectedValue <span class="operator">=</span> newValue &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其实给 <code>Lazy</code> 添加 <code>extension</code> 也可以达到类似的目的，不过这时候的方法调用就要通过 <code>_foo</code> 来进行，而不是 <code>$foo</code> 了</p>
</blockquote>
<h2 id="说回-SwiftUI">说回 SwiftUI</h2>
<p>SwiftUI 的数据流模型是基于下面两点原则来构建的：</p>
<ol>
<li>Data Access as a Dependency</li>
<li>Source of Truth</li>
</ol>
<p>我们展开来看：</p>
<h3 id="Data-Access-as-a-Dependency">Data Access as a Dependency</h3>
<p>在多数情况下，我们的视图是需要根据某些状态来动态变化显示样式的，比如对于 <code>Switch</code> 来说，改变它的 <code>on</code> 属性可以让它显示当前的开关状态。</p>
<p>对于这种情况，<code>on</code> 属性就应该作为 <code>Switch</code> 的依赖而存在，否则这个控件除了长得好看就一无是处了。所以在 SwiftUI 里，属性会被描述为视图的依赖，这意味着我们的注意力可以从属性和视图的关联里抽身出来，集中在建立更好的用户体验上。</p>
<h3 id="Source-of-Truth">Source of Truth</h3>
<p>同一组视图里的数据都是来自于同一个数据源的（甚至整个应用的数据都来自于同一个数据源，Redux 就是这么做的）。</p>
<p>对于开发者来说，数据源的不唯一意味着视图状态的不唯一。可以想象，位于同一视图层级的两个视图要共用某些参数时，数据来源的不唯一会为编程带来多大的麻烦。<br>
<img src="/uploads/swiftui-serial-tutorial-3/D1B04594-7FAA-4391-AC05-CBC2BF839DD8.png" alt=""></p>
<p>SwiftUI 对这种情况的处理是，让父视图作为子视图的唯一数据源：<br>
<img src="/uploads/swiftui-serial-tutorial-3/4CDDC5EC-0093-46EE-A17A-F38972875AF8.png" alt=""></p>
<blockquote>
<p>做过前端 UI 开发的童鞋们应该很熟悉这套操作了，这就是把 State 上提成 Props 嘛，目的是让子视图尽可能的简单，最好的情况下子视图本身应该是无状态的。</p>
</blockquote>
<p>于是我们可以得出，基于这两个原则来实现的数据流模型已经完全不同于我们以往的理解，我们需要重新定义我们所认识的视图：<strong>视图要体现的是一个个独立的状态，而不是一系列连续的事件</strong> 。</p>
<h2 id="实践出真知">实践出真知</h2>
<p>说了这么多，我们来实际改造一段代码试试。</p>
<p>假设我们要实现一个播放器的播放按钮，需求是它要能反应播放状态：</p>
<ol>
<li>没有音频播放时，它表现为播放按钮</li>
<li>在有音频播放时，它表现为暂停按钮</li>
</ol>
<p>我们通过给按钮设置不同的图片来区分这两个状态，按照之前的知识，我们能轻松写下这样的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PlayerView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> isPlaying: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Button</span>(action: &#123;</span><br><span class="line">            <span class="keyword">self</span>.isPlaying <span class="operator">=</span> <span class="operator">!</span><span class="keyword">self</span>.isPlaying</span><br><span class="line">        &#125;) &#123;</span><br><span class="line">            <span class="keyword">self</span>.isPlaying <span class="operator">?</span> <span class="type">Text</span>(<span class="string">&quot;Pause&quot;</span>) : <span class="type">Text</span>(<span class="string">&quot;Play&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等等，我们这个 <code>PlayerControl</code> 是 <code>struct</code> 类型的，不能这样直接改变属性的值：<br>
<img src="/uploads/swiftui-serial-tutorial-3/29C7C479-1EBA-47FD-B9C5-1037A6FC8E17.png" alt=""></p>
<p>其中一个安抚编译器的方法是，用一个临时变量来替代 <code>self</code>，我们顺便把布尔值取反的操作也简化一下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PlayerView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> isPlaying: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Button</span>(action: &#123;</span><br><span class="line">            <span class="keyword">var</span> tempSelf <span class="operator">=</span> <span class="keyword">self</span> <span class="comment">// 安抚编译器</span></span><br><span class="line">            tempSelf.isPlaying.toggle() <span class="comment">// Implemented in Swift 4.2</span></span><br><span class="line">        &#125;) &#123;</span><br><span class="line">            <span class="keyword">self</span>.isPlaying <span class="operator">?</span> <span class="type">Text</span>(<span class="string">&quot;Pause&quot;</span>) : <span class="type">Text</span>(<span class="string">&quot;Play&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>好了，这样一改，那句临时变量赋值语句就成为了夜空中最亮的星，怎么看怎么别扭…</p>
<p>那接下来就轮到 SwiftUI 里定义的 Property Wrappers 出场了，这段代码可以改写成这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PlayerView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> isPlaying: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span> <span class="comment">// 加上 `@State` 标记</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Button</span>(action: &#123;</span><br><span class="line">            <span class="keyword">self</span>.isPlaying.toggle() <span class="comment">// 可以直接改动 `self` 里的变量了</span></span><br><span class="line">        &#125;) &#123;</span><br><span class="line">            <span class="keyword">self</span>.isPlaying <span class="operator">?</span> <span class="type">Text</span>(<span class="string">&quot;Pause&quot;</span>) : <span class="type">Text</span>(<span class="string">&quot;Play&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>似乎…也没太大变化啊，代码量也不见少，只不过是省掉了临时变量了？<br>
这是因为，这样的写法还是根据我们的惯常思维来走，回忆一下上面讲到的 SwiftUI 数据模型原则：</p>
<ol>
<li>以依赖的形式访问数据</li>
<li>单一数据源</li>
</ol>
<p>例子里的写法貌似符合了“单一数据源”，但是却把“以依赖的形式访问数据”晾在了一边。我们来进一步改造这个例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PlayerView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> isPlaying: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">PlayButton</span>(isPlaying: <span class="variable">$isPlaying</span>) <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PlayButton</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Binding</span> <span class="keyword">var</span> isPlaying: <span class="type">Bool</span> <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Button</span>(action: &#123;</span><br><span class="line">            <span class="keyword">self</span>.isPlaying.toggle()</span><br><span class="line">        &#125;) &#123;</span><br><span class="line">            <span class="type">Text</span>(isPlaying <span class="operator">?</span> <span class="string">&quot;Pause&quot;</span> : <span class="string">&quot;Play&quot;</span>) <span class="comment">// 3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li>使用 <code>@State</code> 标记的变量会自动生成一个以 <code>$</code> 作为前缀的新变量，这个新变量本质上是一个 Computed Value，实现了双向绑定的机制，也就是说当 <code>PlayButton</code> 内部改变了这个变量之后，<code>PlayerView</code> 里的 <code>isPlaying</code> 也会发生相同的变化</li>
<li>通过声明变量为 <code>@Binding</code>，我们就告诉了编译器这个变量是从外部传入的可以被绑定的参数，相当于 React 里的 <code>Props</code> 声明</li>
<li>我们将 <code>isPlaying</code> 作为 <code>Text</code> 的依赖来使用，对于 <code>PlayButton</code> 来说，变量的声明和使用都是在一个结构体里面完成的，这就意味着这个视图与 <code>PlayerView</code> 是解偶的</li>
</ol>
<blockquote>
<p><code>@Binding</code> 具有以下两种特性：</p>
<ol>
<li>在不持有变量的前提下进行变量的读写</li>
<li>可以从 <code>@State</code> 变量中推导出来</li>
</ol>
</blockquote>
<p>现在回忆一下，在 SwiftUI 之前我们是怎么实现类似逻辑的？在不知不觉中，我们已经舍弃了 ViewController，让视图直接成为了数据的载体。甚至可以说，在 SwiftUI 里，视图就是为数据服务的。</p>
<blockquote>
<p><code>@State</code> 标记的属性一旦变化，会引起依赖它的视图、这个视图的父视图和它的同级视图一起做<strong>必要的</strong>变化。为什么要强调<strong>必要的</strong>？因为相较于繁重的渲染工作来说，对声明式语法描述出来的数据结构进行比较并不消耗什么性能，SwiftUI 会在重新渲染前对视图状态进行比较，尽可能地去避免无谓的绘制，所以不需要担心性能的问题。<br>
类似于 <code>React.PureComponent</code> 提供的逻辑。</p>
</blockquote>
<h2 id="小结">小结</h2>
<p>基于这套数据模型实现出来的数据流可以用下面这张图片来表示：<br>
<img src="/uploads/swiftui-serial-tutorial-3/870E1C27-D2D8-41AD-BBF2-66AABA4BD04A.png" alt=""><br>
要知道，Action 不只可以来自于用户交互，它还可以来自我们自己实现的触发器、消息推送等等，而不管来源是什么，我们实现的逻辑都可以理解并做出同样的处理。</p>
<p>这样的数据流模式确保了数据的流动永远是单向的，而 State 在这里充当了视图变化的唯一数据源，让视图的更新是可预测和易懂的。</p>
<blockquote>
<p>当然，<code>@State</code> 也有它的局限性，比如它无法正确处理我们自己定义的对象类型的属性变化，所以我们还需要 BindableObject 协议来从旁辅助，这里就不继续展开了。</p>
</blockquote>
<p>了解了视图基础和数据流模型，相信大家都已经看到了 SwiftUI 的魅力，余下的细节就需要各位开发者在实际应用中发掘了。下一讲就让我们来把这个魅力继续扩大，一起来实际看看 SwiftUI 还给我们的开发带来了哪些好处。</p>
<h2 id="参考文章">参考文章</h2>
<ul>
<li><a href="https://www.linuxidc.com/Linux/2015-10/124622.htm">界面之下：还原真实的 MVC、MVP、MVVM 模式</a></li>
<li><a href="https://redux.js.org/introduction/motivation">Motivation · Redux</a></li>
<li><a href="https://react-redux.js.org/introduction/why-use-react-redux">Why Use React Redux? · React Redux</a></li>
<li><a href="https://developer.apple.com/documentation/swiftui/state_and_data_flow">State and Data Flow | Apple Developer Documentation</a></li>
<li><a href="https://nshipster.com/propertywrapper/">Swift Property Wrappers - NSHipster</a></li>
<li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0258-property-wrappers.md">swift-evolution/0258-property-wrappers.md at master · apple/swift-evolution · GitHub</a></li>
<li><a href="https://developer.apple.com/videos/play/wwdc2019/226/">Data Flow Through SwiftUI - WWDC 2019 - Videos - Apple Developer</a></li>
</ul>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"8225264e14e677544541","clientSecret":"ed2a2c6d5043e9f0b41cae78b0d5b4571099de53","repo":"HexoBlogSource","owner":"davidleee","admin":["davidleee"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>Redux</tag>
        <tag>Swift</tag>
        <tag>SwiftUI</tag>
        <tag>MVC</tag>
        <tag>React</tag>
        <tag>Property Wrappers</tag>
        <tag>State</tag>
        <tag>Binding</tag>
      </tags>
  </entry>
  <entry>
    <title>聊聊用 Git 协同合作的事儿</title>
    <url>/2016/08/27/team-working-with-git/</url>
    <content><![CDATA[<p>说起来在来到公司之前一直没有好好用 Git 来管理分支。之前做一些课程设计和玩具项目的时候虽然有用到 Git，但是也仅限于本地仓库的提交而已。这样做更多的只是留下一个可供追寻的路径（ History ），没有太多的“管理”职能。在多人协同合作的项目中，Git 终于发挥出它强大的优势。</p>
<span id="more"></span>
<p>所以我猜想，是不是有不少像之前的我那样子的学生/个人开发者，一直只是把 Git 当做一个跟踪工具来用（偶尔出现懒得修改的问题，直接回滚，真是好厉害好方便的样子）。<br>
这篇文章会分享一些我们团队目前接触到的 Git 配置和使用方式（希望正在看文章的你已经对 Git 的指令有一些基础认识了），内容会比较分散，但基本上是围绕着我们现在的开发过程来描述的。对于真•程序员来说，这些方法应该是烂熟于胸了（虽然有的方法我是最近才知道…），不过也希望可以起到一定的参考作用。因为团队还比较小，很多东西还在探索阶段，所以难免会有疏漏和考虑不周的地方，欢迎能看到各位一起交流探讨~</p>
<h2 id="配置工作环境">配置工作环境</h2>
<h3 id="需求">需求</h3>
<p>现有的工作环境&amp;流程大概是这样的：</p>
<ol>
<li><strong>upstream</strong> 指向服务器上的公共代码区，里面一般分为发布分支 <em>master</em> 和开发分支 <em>develop</em>。</li>
<li><strong>origin</strong> 是从 <strong>upstream</strong> 上 <code>fork</code> 出来的，为了跟 <strong>upstream</strong> 上的 <em>develop</em> 作区分，一般会从 <em>origin/develop</em> 上 <code>checkout</code> 一个<em>姓名-develop</em>分支出来作为自己的开发分支。</li>
<li>每次推代码之前都要从 <em>upstream/develop</em> 上 <code>fetch</code> 最新的代码，并在本地进行合并和冲突的解决。解决完之后先 <code>push</code> 到自己的 <em>origin/姓名-develop</em> 分支上，然后向主仓库的对应分支提交 Merge Request。</li>
</ol>
<p>为了满足上面的需求，配好之后本地上看到的大概是这个样子：<br>
<img src="/uploads/team-working-with-git/demand.png" alt="demand">￼</p>
<h3 id="动手">动手</h3>
<p>公司的代码托管服务用的是 GitLab，操作起来跟 Github 基本一致，想要了解的可以上它<a href="https://about.gitlab.com/">官网</a>看看。</p>
<p><code>fork</code> 那一步可以直接在 GitLab 上面操作，点几下鼠标就好了。主要是在本地配置 <strong>upstream</strong> 这一步。<br>
把 <code>fork</code> 过来的自己的项目 <code>clone</code> 下来之后，就相当于有了一整个 <strong>origin</strong> 的代码，切分支什么的都好办了，问题是要这样子拉最新代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git fetch upstream</span><br></pre></td></tr></table></figure>
<p>这就需要先执行以下的指令，把远程分支的信息拉到本地：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote add upstream &lt;分支URL&gt;</span><br></pre></td></tr></table></figure>
<h2 id="好用的-stash">好用的 stash</h2>
<p>在改了一大堆零碎的东西，却又还没有改完的情况下，如果需要回滚到这次修改之前有两种做法：</p>
<ol>
<li>commit 当前所有修改，然后 reset 到上一个 commit</li>
<li>stash 当前所有修改，用完再 stash pop 回来</li>
</ol>
<p>个人比较喜欢用第二种，虽然也有用第一种方法，然后 commit 的 comment 是 “Just a save before huge change” 的时候。</p>
<blockquote>
<p>更好的做法应该是：把要做的任务切分得更小一些，多进行提交。这样不但可以更好的从 log 中看到开发的进程，也可以更好地管理每一个小任务所对应的代码。<br>
也可以更好地应对产品经理各种功能调整的需求了 :）</p>
</blockquote>
<h3 id="选择性-stash">选择性 stash</h3>
<p><code>git stash --patch</code> 和 <code>git stash -p</code> 让你可以选择需要 stash 的条目/文件，执行这条指令之后，命令行会逐一过一遍所有修改块。</p>
<p>注意是<strong>所有修改块</strong>，用 y/n 可以选择是否要 stash 当前的代码块，如果想要过掉当前的文件的话，也可以用 a/d 来选择是否要 stash 当前文件。</p>
<blockquote>
<p>每一次 stash 之后，Git 都会把 stash 掉的东西保存为一次记录，有点类似于一次没有描述的提交。不同的是，stash 不会出现在历史记录里面，在提供了灵活性的同时，也有一定的风险（鬼知道代码经历了什么）</p>
</blockquote>
<h2 id="远程分支的一些事">远程分支的一些事</h2>
<p>配好了环境，也在本地鼓捣了一番，也该看看怎么对远程分支搞破坏了。</p>
<h3 id="远程分支追踪">远程分支追踪</h3>
<p>在本地分支与远程分支不同步时，有时候会想要干掉本地分支，再重新把远程分支拉一个下来。</p>
<blockquote>
<p>这个例子比较硬…难道不应该看看为什么不同步吗…？</p>
</blockquote>
<p>做这个操作之前，首先要确保本地已经具备远程的所有信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git fetch</span><br></pre></td></tr></table></figure>
<p>然后直接用 <code>checkout</code> 创建分支，并指向远程分支就好了，比如把远程 develop 分支拉下来，对应上本地的 develop 分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout -b develop origin/develop</span><br></pre></td></tr></table></figure>
<p>接着你可以这样查看到分支的关系：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch -vv</span><br></pre></td></tr></table></figure>
<p>会看到这样的东西：<br>
<img src="/uploads/team-working-with-git/branchvv.png" alt="branchvv">￼</p>
<p>或者这样看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote show origin</span><br></pre></td></tr></table></figure>
<p>结果长这个样子：<br>
<img src="/uploads/team-working-with-git/remote_show.png" alt="remote_show">￼</p>
<h3 id="如果远程不认识我…">如果远程不认识我…</h3>
<p>进行了一系列分支调整之后，通过 <code>git remote show origin</code> 的指令可能会发现缺少了某些分支，这时候就需要手动去配置一下分支的关系。</p>
<p>分支的相关配置都保存在 <code>.git/config</code> 这个目录下，直接 <code>cat</code> 一下可以看到所有分支的参数设置，其中一条的参数大概长这个样子：<br>
<img src="/uploads/team-working-with-git/branch_info.png" alt="branch_info">￼</p>
<p>这个地方是在告诉 Git，本地的 liyiran-develop 分支对应的是 origin 上的 liyiran-develop 分支，也就是说<strong>本地</strong> liyiran-develop 的所有 <em>不加参数</em> 的 push 和 pull 操作都应该对应在<strong>远程</strong> liyiran-develop。如果没有想要配置的那个分支，直接按照这个格式手动加上去就好了。</p>
<p>或者，你可以通过 git 指令来操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config branch.master.remote origin  // 将 remote 参数的内容设置为 origin</span><br><span class="line">$ git config branch.master.merge refs/heads/master // 将 merge 参数的内容设置为 refs/heads/master</span><br></pre></td></tr></table></figure>
<h2 id="结语">结语</h2>
<p>这边其实也只是用到了一些皮毛，还有像 <code>cherry-pick</code>、<code>rebase</code> 这类大杀器都没有涉及到，希望能起到一个抛砖引玉的作用。</p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"8225264e14e677544541","clientSecret":"ed2a2c6d5043e9f0b41cae78b0d5b4571099de53","repo":"HexoBlogSource","owner":"davidleee","admin":["davidleee"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>Git</tag>
        <tag>Teamwork</tag>
      </tags>
  </entry>
  <entry>
    <title>见闻历技术支持</title>
    <url>/2021/06/07/techsupport-calendar/</url>
    <content><![CDATA[<p><img src="/uploads/techsupport-calendar/presentation.png" alt=""></p>
<span id="more"></span>
<p>给平平无奇的日历加点内容，让简简单单的生活充满趣味！</p>
<ul>
<li>每天知道点新知识：经济学、心理学…</li>
<li>往年今日发生过什么特别的事情吗：历史上的今天</li>
<li>今天适合做点啥呢：公历农历、属相、每日宜忌…</li>
</ul>
<p>将手边的电子设备利用起来，妈妈再也不用担心我没有台历，不记得日子了！</p>
<p>获取技术支持：</p>
<ul>
<li>邮件：onetap@foxmail.com</li>
<li>或直接在下方评论区流言</li>
</ul>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"8225264e14e677544541","clientSecret":"ed2a2c6d5043e9f0b41cae78b0d5b4571099de53","repo":"HexoBlogSource","owner":"davidleee","admin":["davidleee"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>技术支持</tag>
        <tag>见闻历</tag>
      </tags>
  </entry>
  <entry>
    <title>多喝水技术支持</title>
    <url>/2021/03/05/techsupport-drinkmore/</url>
    <content><![CDATA[<p><img src="/uploads/techsupport-drinkmore/drinkmore-presentation.png" alt=""></p>
<span id="more"></span>
<p>你是否曾经有过这样的困扰：<br>
白天水喝少了或者吃咸了导致晚上睡前总口渴，<br>
但是睡前水喝多了又会导致睡着之后老起夜？</p>
<p>多喝水 就是来帮你解决身体水平衡问题的，让你的身体从此水分满满没烦恼！</p>
<p>== 功能 ==</p>
<ul>
<li>科学计算你所需的喝水量</li>
<li>在合适的时机提醒你喝水</li>
<li>方便快捷地记录每次水分摄入</li>
<li>让你一目了然自己过去的表现</li>
</ul>
<p>获取技术支持：</p>
<ul>
<li>邮件：onetap@foxmail.com</li>
<li>或直接在下方评论区流言</li>
</ul>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"8225264e14e677544541","clientSecret":"ed2a2c6d5043e9f0b41cae78b0d5b4571099de53","repo":"HexoBlogSource","owner":"davidleee","admin":["davidleee"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>技术支持</tag>
        <tag>多喝水</tag>
      </tags>
  </entry>
  <entry>
    <title>关于 macOS 输入框你需要了解的一些基础</title>
    <url>/2018/09/11/the-basic-of-macos-text-view-system/</url>
    <content><![CDATA[<blockquote>
<p>这是 macOS 开发系列的第三篇文章 —— 文本输入系统基础。</p>
<p>电脑的文字编辑功能比手机上的强大（难搞）真不是吹！</p>
</blockquote>
<span id="more"></span>
<h2 id="认识输入框">认识输入框</h2>
<blockquote>
<p>The Macintosh operating system has provided sophisticated text handling and typesetting capabilities from its beginning. In fact, these features sparked the desktop publishing revolution. —— Apple</p>
</blockquote>
<p>在 macOS 的世界里，要显示或者编辑文字主要会用到两个控件，一个是 <a href="https://developer.apple.com/documentation/appkit/nstextview">NSTextView</a>，另一个是 <a href="https://developer.apple.com/documentation/appkit/nstextfield">NSTextField</a>。</p>
<blockquote>
<p>虽然控件库里面有个叫 Label 的东西，但是拖出来之后就会发现，它其实也是一个  <a href="https://developer.apple.com/documentation/appkit/nstextfield">NSTextField</a></p>
</blockquote>
<p>它们的继承关系是这样的：<br>
<img src="/uploads/the-basic-of-macos-text-view-system/7004648D-1B33-476E-8788-8D894D8B08E9.png" alt=""></p>
<p>NSTextView 是苹果花了大心血打造的一个“满足几乎所有显示和管理文字需求”的一个控件，也是 macOS 引以为傲的文字编辑系统的主心骨；NSTextField 则相当于一个简化版的 NSTextView，在大多数情况下它可以满足字数较少的输入需求。</p>
<p>正如我们在 iOS 开发里常做的那样，在需要用户输入的地方，通常是直接展示一个 Text 相关的控件，然后通过 delegate 方法来控制输入的内容；又或者继承一个官方的控件，然后在内部直接实现想要的内容控制逻辑。</p>
<p>在 macOS 上，这个流程也是大致相同的。</p>
<blockquote>
<p>以前写过一篇简单介绍 NSTextView 用法的文章（ <a href="/2017/09/11/Windows-in-macOS/" title="20分钟手把手教你写 macOS 文本编辑器">20分钟手把手教你写 macOS 文本编辑器</a>），等不及的童鞋们可以在这篇文章里过过瘾。</p>
</blockquote>
<h2 id="文本输入的幕后玩家">文本输入的幕后玩家</h2>
<p>虽然从使用上来看，跟开发者直接打交道的就是 NSTextView 和 NSTextField 这两个类，最多再加上它们带着的一些协议/代理，但是继续往深了看，会发现有一个未知的世界在支撑这这一切。</p>
<h3 id="Field-Editor">Field Editor</h3>
<p>macOS 上有一个叫 Field Editor 的概念。</p>
<p>在输入框获得焦点的时候，系统会实例化一个 NSTextView 作为 Field Editor，并把它作为 first responder 插入到这个输入框的事件响应链当中。如此一来，Field Editor 会负责处理所有的用户输入事件，在这个过程中，获得焦点的输入框会作为 Field Editor 的代理，以便对文本的内容进行控制处理。</p>
<p><img src="/uploads/the-basic-of-macos-text-view-system/field_editor_2x.png" alt=""></p>
<blockquote>
<p>这就是为什么 NSWindow 的 <code>firstResponder</code> 返回的是一个不可见的对象，而不是我们获取了焦点的输入框，因为这个对象就是上面说的 Field Editor。</p>
</blockquote>
<p>Field Editor 是同一个窗口里所有输入框共用的，所以在我们用 Tab 键切换输入框的时候，Field Editor 就会切换事件响应的对象。另一方面，这个机制也确保了同一个窗口中只能有一个控件去响应用户输入事件。不过，我们也可以实现自定义的 Field Editor 来推翻上面说的这些功能。</p>
<blockquote>
<p>虽然 Field Editor 一般会是一个 NSTextView 的实例，但是它们对 Tab 和 Return 的事件处理是不同的。对于 Field Editor 来说，这两个键盘事件是“结束编辑”的意思。</p>
</blockquote>
<h3 id="NSTextInputContext">NSTextInputContext</h3>
<p>这是外界和文本输入系统之间沟通的桥梁。</p>
<p>在用户进行输入的时候，<code>keyDown</code> 消息会被传递到获取了焦点的输入框里，输入框接下来会调用 <a href="https://developer.apple.com/documentation/appkit/nstextinputcontext">NSTextInputContext</a> 的 <code>handleEvent</code> 方法，以便让 NSTextInputContext 告诉自己需要怎么处理这个用户事件。而作为响应，NSTextInputContext 会把处理结果通过 <a href="https://developer.apple.com/documentation/appkit/nstextinputclient">NSTextInputClient</a> 这个协议告知输入框。</p>
<p><img src="/uploads/the-basic-of-macos-text-view-system/F200783C-8569-4396-BC36-4DAD92E810DF.png" alt=""></p>
<p>从上图可以看到，NSTextInputContext 会跟一个叫 Key-bindings dictionary 的字典保持密切联系。这个字典默认来自于 AppKit 内部的一个文件（<em>/System/Library/Frameworks/AppKit.framework/Resources/StandardKeyBinding.dict</em>），里面保存了系统默认定义好的所有快捷键，只有当用户输入的值在这个字典里找不到匹配的键值对时，这次输入才会作为普通字符回调给输入框，否则 NSTextInputContext 就会在这里把这次输入拦截下来，并让输入框执行相应的特殊操作。</p>
<blockquote>
<p>我们可以通过修改 <em>~/Library/KeyBindings/DefaultKeyBinding.dict</em> 里的值来覆盖默认的快捷键</p>
</blockquote>
<h2 id="小结">小结</h2>
<p>到此为止，macOS 文本编辑系统的一些内在机理已经了解地差不多了。在往后使用 NSTextView 和 NSTextField 的过程中，碰到一些不明觉厉的问题也能有个大概的问题排查方向了。（不过也仅限于“大概方向”了）</p>
<p>好吧，我知道这篇文章偏理论了一些，大多数情况下也不会用到。更多详细的说明可以在文章里提供的各种链接上找到。</p>
<p>在后续的文章里，还会讲到 NSTextField 实际应用上的一些内容。NSTextView 因为暂时没有用上，所以可能会等有机会研究清楚些再讲咯。</p>
<h2 id="参考文章">参考文章</h2>
<p><a href="https://developer.apple.com/library/archive/documentation/TextFonts/Conceptual/CocoaTextArchitecture/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009459-CH1-SW1">About the Cocoa Text System</a></p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"8225264e14e677544541","clientSecret":"ed2a2c6d5043e9f0b41cae78b0d5b4571099de53","repo":"HexoBlogSource","owner":"davidleee","admin":["davidleee"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>macOS</tag>
        <tag>AppKit</tag>
        <tag>NSTextField</tag>
        <tag>Cocoa</tag>
        <tag>NSTextView</tag>
        <tag>Text System</tag>
        <tag>Field Editor</tag>
      </tags>
  </entry>
  <entry>
    <title>Universal Link（iOS）踩坑</title>
    <url>/2017/01/04/universal-link-problems/</url>
    <content><![CDATA[<blockquote>
<p>这篇文章讲的都是集成 Universal Link 的时候可能会踩的坑，并不会讲具体如何使用</p>
</blockquote>
<span id="more"></span>
<h2 id="官方关联文件测试">官方关联文件测试</h2>
<p>一般来说，把关联文件（apple-app-site-association）布置好之后，都要使用苹果提供的<a href="https://search.developer.apple.com/appsearch-validation-tool/">官方测试工具</a>测试一下，然而结果很可能是这样的：<br>
<img src="/uploads/universal-link-problems/action_required.png" alt="action_required">￼</p>
<p>这个提示大多数与关联文件无关。<br>
据了解，测试工具会先去爬输入的网站的信息，找到关联文件，检查关联文件格式，然后执行最关键、最有可能导致这个问题的一步：去 App Store 检查 appID 所对应的应用是否存在。</p>
<p>所以说，如果官方测试通过，那是极好的；但是如果不通过，那就直接测试一下功能。我们现在就是处在官方检测不通过、功能却可以正常使用的状态。</p>
<h2 id="跨域问题">跨域问题</h2>
<p><img src="/uploads/universal-link-problems/aha.png" alt="aha">￼<br>
没想到吧！做移动端的人也有碰到跨域问题的一天！</p>
<p>在苹果多次迭代 Universal Link 之后，直接将连接丢到浏览器地址栏里面打开已经是不可行的了。更有甚者，通过点击按钮跳转的网页链接 <strong>有时候</strong> 也不能拉起应用。</p>
<p>这个 <strong>有时候</strong> 应该就是碰到跨域问题。这种情况下，将链接粘贴到备忘录或者短信里面，发现可以点击拉起应用，那就是跨域问题无疑。</p>
<blockquote>
<p>跨域问题：假设当前网页的地址为 <a href="http://a.com">a.com</a>，如果要跳转的链接也是 <a href="http://a.com">a.com</a> 这个域下的，系统将不会进行拉起应用的操作，必须要跳转不同的子域，例如 <a href="http://b.com">b.com</a> 时，系统才会根据关联文件去判断是否要拉起应用。</p>
</blockquote>
<p>虽然不知道苹果这样设计的道理，但是解决方法也是很简单直接，就是让跳转链接跨域。</p>
<h2 id="选择性跳转">选择性跳转</h2>
<p>通过 Universal Link 拉起应用之后，你会发现状态栏的右边有个跳转到 Safari 的小按钮，如果你好奇心满满地点了下去，那么恭喜你，这个链接以后就“再也”不会拉起 App，而是直接用 Safari 打开了。</p>
<p>问题就在于，系统会尝试理解用户的意图，当你点了那个跳转按钮，系统会认为你想要打开网页而不是 App，于是以后就会按照“它认为的”你的意思去执行跳转。<br>
在浏览器打开了一个本可以拉起应用的 Universal Link 时，通过下拉网页，可以拉出一个打开对应应用 banner，算是对拉起应用的一点补偿吧？</p>
<blockquote>
<p>如果用户点击了网页顶部 banner 中的“打开”拉起了应用，下一次用户再次点击链接的时候，系统就会首先去拉起应用。</p>
<p>简单来说，系统会记住 Universal Link 最后到达的位置，并将这个位置作为下次的默认打开选项。</p>
</blockquote>
<p>在这个<a href="http://stackoverflow.com/a/32751734/4177374">回答</a>里，可以看到更详细一些的分析。</p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"8225264e14e677544541","clientSecret":"ed2a2c6d5043e9f0b41cae78b0d5b4571099de53","repo":"HexoBlogSource","owner":"davidleee","admin":["davidleee"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Universal Link</tag>
      </tags>
  </entry>
  <entry>
    <title>react-navigation-redux-helpers 从 v1 到 v2</title>
    <url>/2018/09/10/upgrade-react-navigation-redux-helpers-to-v2/</url>
    <content><![CDATA[<p>在使用 <a href="https://reactnavigation.org">React Navigation</a> 的项目中，想要集成 redux 就必须要引入 <a href="https://github.com/react-navigation/react-navigation-redux-helpers">react-navigation-redux-helpers</a> 这个库。最近整理第三方库的时候，发现这两个库的版本都比较旧了，在尝试更新的时候踩了一些坑，于是就有了这篇文章。</p>
<span id="more"></span>
<h2 id="Navigator">Navigator</h2>
<p>升级之后，配置上唯一的不同在于 v2 版本中干掉了 <code>createReduxBoundAddListener(Key)</code> 方法，取而代之的是 <code>reduxifyNavigator(Navigator, Key)</code>。</p>
<p>在 v1 版本中，我们需要把前者构造出来的 <code>addListener</code> 作为参数传给 AppNavigator：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  StackNavigator,</span><br><span class="line">  addNavigationHelpers,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;react-navigation&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  createReduxBoundAddListener</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;react-navigation-redux-helpers&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> AppNavigator = StackNavigator(AppRouteConfigs)</span><br><span class="line"><span class="keyword">const</span> addListener = createReduxBoundAddListener(<span class="string">&quot;root&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">AppNavigator</span> <span class="attr">navigation</span>=<span class="string">&#123;addNavigationHelpers(&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">dispatch:</span> <span class="attr">this.props.dispatch</span>,</span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">state:</span> <span class="attr">this.props.nav</span>,</span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">addListener</span>, // <span class="attr">--</span>&gt;</span> 就是这里</span></span><br><span class="line"><span class="xml">      &#125;)&#125; /&gt;</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在 v2 版本中，使用新方法可以简化上述步骤：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  createStackNavigator, <span class="comment">// new creator of StackNavigator</span></span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;react-navigation&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  reduxifyNavigator</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;react-navigation-redux-helpers&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> AppNavigator = createStackNavigator(AppRouteConfigs)</span><br><span class="line"><span class="keyword">const</span> App = reduxifyNavigator(AppNavigator, <span class="string">&quot;root&quot;</span>) <span class="comment">// --&gt; 干净清爽！</span></span><br></pre></td></tr></table></figure>
<h2 id="mapStateToProps">mapStateToProps</h2>
<p>原来 <code>state.nav</code> 对应的 <code>props</code> 键叫 “nav”，现在改为 “state” 了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v1</span></span><br><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state</span>) =&gt;</span> (&#123;</span><br><span class="line">  <span class="attr">nav</span>: state.nav</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// v2</span></span><br><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state</span>) =&gt;</span> (&#123;</span><br><span class="line">  <span class="attr">state</span>: state.nav, <span class="comment">// nav -&gt; state</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>另外，之前为了处理 Android 返回按钮的问题，可能会自定义一个类包裹着上面构造出来的 AppNavigator，然后通过 react-redux 的 <code>connect</code> 方法把 <code>mapStateToProps</code> 给作用到这个自定义的类上去，比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReduxNavigation</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* additional setup for back button handling */</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">/* more setup code here! this is not a runnable snippet */</span>*</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">AppNavigator</span> <span class="attr">navigation</span>=<span class="string">&#123;navigation&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps)(ReduxNavigation)</span><br></pre></td></tr></table></figure>
<p>经测试发现，在 v2 版本里，这种操作会报 “undefined is not an object(evaluating ‘state.routes’)” 的错误，猜测可能跟 Props 的键值变化有关。把 <code>connect</code> 的调用提前，让它先作用到 AppNavigator 再包裹到自定义类里面即可：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ConnectedNavigator = connect(mapStateToProps)(AppNavigator)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReduxNavigation</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* additional setup for back button handling */</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">/* more setup code here! this is not a runnable snippet */</span>*</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ConnectedNavigator</span> <span class="attr">navigation</span>=<span class="string">&#123;navigation&#125;/</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ReduxNavigation</span><br></pre></td></tr></table></figure>
<h2 id="Full-Example">Full Example</h2>
<p>对于同一个 Navigator， <code>reduxifyNavigator</code> 如果在 <code>connect</code> 之后调用，会报重复定义<code>navigation</code> 属性的错误。所以加上前面的配置过程，完整的例子应该长这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* importing the whole world */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> AppNavigator = createStackNavigator(AppRouteConfigs)</span><br><span class="line"><span class="comment">// 下面两句顺序不能变</span></span><br><span class="line"><span class="keyword">const</span> App = reduxifyNavigator(AppNavigator, <span class="string">&quot;root&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> ConnectedNavigator = connect(mapStateToProps)(App)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReduxNavigation</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* additional setup for back button handling */</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">/* more setup code here! this is not a runnable snippet */</span>*</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ConnectedNavigator</span>/&gt;</span></span> <span class="comment">// 不需要 `navigation` 参数了</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ReduxNavigation</span><br></pre></td></tr></table></figure>
<h2 id="参考文章">参考文章</h2>
<p><a href="https://reactnavigation.org/docs/en/redux-integration.html">Redux integration · React Navigation</a><br>
<a href="https://v1.reactnavigation.org/docs/redux-integration.html">Redux integration · React Navigation (v1)</a></p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"8225264e14e677544541","clientSecret":"ed2a2c6d5043e9f0b41cae78b0d5b4571099de53","repo":"HexoBlogSource","owner":"davidleee","admin":["davidleee"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>react-native</tag>
        <tag>react-navigation</tag>
        <tag>redux</tag>
        <tag>react-navigation-redux-helpers</tag>
      </tags>
  </entry>
  <entry>
    <title>老生常谈的自适应高度UITableViewCell</title>
    <url>/2016/04/29/using-autolayout-in-uitableviewcells/</url>
    <content><![CDATA[<p>UITableViewCell 自适应内容高度已经是一个老生常谈的问题了，网络上也随处可以找到相关的资料。从 iOS 8 开始，强大的 AutoLayout 甚至已经可以直接接管 Cell 高度的计算，于是这一话题也就慢慢淡出了人们的视野，包括我…<br>
最近整理笔记的时候发现了这篇文章，想了想还是把它弄到新博客上来了。这篇文章是做毕业设计的时候（2014）总结下来的，当时因为要兼容到 iOS 7 ，所以用的都是比较原始的方法，不过在那个时候用起来还是比较顺手的（只是对比起 iOS 8 的用法，那真叫一个酸爽）。随着 iOS 后面的版本号越来越大，兼容 iOS 7 的应用应该也不多了，现在把它搬到这上面来，主要是为了记录以往走过的路，这些知识或许再也用不上，但积累它们的过程还是非常值得保留的。<s>另一个原因是为了扩充新博客的文章数目。</s>（喂！）</p>
<span id="more"></span>
<h2 id="告诉我需求！">告诉我需求！</h2>
<p>文中的界面制作使用的是 Storyboard，也会略微对比使用 xib 和纯代码的情况。</p>
<p>首先假设这么一种情况，我们的 UITableViewCell 里面只使用到一种布局：<br>
<img src="/uploads/using-autolayout-in-uitableviewcells/cell-ui.png" alt="cell-UI"><br>
其中， State 只显示一行； Name 最多只能显示3行，字体大小不改变； Additional 可以显示任意多行，字体大小不改变。<br>
如果 cell 的布局变化比较大，比如说文字下面可能还有图片，4张图片和9张图片的布局要不同，那么还是建议把相去甚远的几种布局分别设计成几个不同的 cell，用 Cell Identifier 来区分彼此，然后再分别对每一个 cell 进行自适应内容高度的处理。</p>
<h2 id="最喜欢IB了-约束设置">最喜欢IB了 - 约束设置</h2>
<p>既然使用的是 Storyboard，那么一切的约束当然都是在 Storyboard 里面手动进行。<br>
想要让 cell 根据内容自动调整高度，一个极其重要也似乎是唯一的原则是：约束自上而下贯通整个 contentView。</p>
<p>还是拿上面的截图做例子：</p>
<ol>
<li>State 必须要有一个 Top Space to: Superview，这个 Superview 应该是 cell 的 contentView 而不是 cell 本身。</li>
<li>Name 要有一个 Top Space to: State，而这个 constant 是多少就可以随意了，它的作用主要是把二者的垂直空间连起来，怎么连、连多长都是看心情的事。</li>
<li>Additional 除了要有一个 Top Space To: Name 之外，还需要有一个 Bottom Space To: Superview（这个也是 contentView）。</li>
</ol>
<p>其实，如果将旁边的数字 1 连到了 contentView 的 top 上，再把 State 跟数字 1 的 center Y 等同一下，也可以达到同样的效果。只是如果使用上面的构建方法，数字 1 就可以自己一边玩儿去了，因为三个 UILabel 已经完成了“确定 cell 所需高度”的关键任务。</p>
<h2 id="Write-the-code-change-the-world">Write the code, change the world!</h2>
<p>下面将分别针对 UITableView 中需要进行修改的不同几处分开来进行说明。</p>
<h3 id="主角-CustomCell-m">主角 - CustomCell.m</h3>
<p>相对来说最忙的应该是 CustomCell 这个自定义类了，所以放到最前面来说。<br>
在这个地方，需要关注的其实也只有两件事：</p>
<ol>
<li>为 cell 填充内容。</li>
<li>layoutSubviews。</li>
</ol>
<h4 id="填充内容">填充内容</h4>
<p>其实就是属性的设置而已，但是需要注意的是，对于 UILabel 来说，我们想要看到的是，当显示的内容很多的时候，它可以有一个确定的宽度，然后多出来的内容自动往下接着排列下去。比较好的办法是，继承 UILabel，然后在子类中自己实现。这种做法也不麻烦，放到后面再说，现在我们这里就只是简单的设置几个 text 。</p>
<blockquote>
<p>代码呢？</p>
</blockquote>
<p>这么简单的赋值代码，我不贴！我不贴！</p>
<h4 id="layoutSubviews">layoutSubviews</h4>
<p>如果没有用继承 UILabel 的那套方案，那么这一步就是必须的，否则就是多余的。这里还是用到了继承的方案。<br>
我们需要重写 cell 的 layoutSubviews 方法，并让它为我们的 UILabel 设定一些规矩：<br>
<img src="/uploads/using-autolayout-in-uitableviewcells/layoutSubviews-code.png" alt="layoutSubviews-code"><br>
代码非常简单，因为当运行到这里的时候，AutoLayout 已经帮我们处理好了一大堆布局的问题，我们只需要告诉 UILabel ，我想要你显示多宽就可以了。</p>
<h3 id="主角诞生的地方-cellForRowAtIndexPath">主角诞生的地方 - cellForRowAtIndexPath</h3>
<p>除了常规的获取和配置 cell 之外，我们最好在最后面补上两句简短的代码：<br>
<img src="/uploads/using-autolayout-in-uitableviewcells/cellForRowAtIndexPath-code.png" alt="cellForRowAtIndexPath-code"><br>
这两句的作用是告诉我们能者多劳的 cell，如果你发现自己的约束改变了，那么就马上更新一下自己。不写这两句问题也不大，只是为了防止某些特殊情况下 cell 的显示异常。</p>
<h3 id="到底要我长多高你才满意？！-heightForRowAtIndexPath">到底要我长多高你才满意？！ - heightForRowAtIndexPath</h3>
<p>最关键的地方来了，告诉 tableView 每个 cell 到底该是多高。这里有三个关键步骤：</p>
<ol>
<li>创建一个offscreen cell。</li>
<li>模拟真实的cell填充数据。</li>
<li>计算出这个offscreen cell的高度。</li>
</ol>
<p>实际上，我们要做的就是制作一个和当前位置需要显示的 cell 一模一样但却不会显示出来的 cell （好拗口），然后告诉 delegate 这个 cell 的高度即可。</p>
<h4 id="Offscreen-Cell">Offscreen Cell</h4>
<p>实验发现，“创建一个 offscreen cell ”是非常讲究的：</p>
<ul>
<li>如果使用 <code>[tableView dequeueReusableCellWithIdentifier:CellIdentifier atIndexPath:indexPath]</code> 来获得一个 cell ，会造成内存的泄漏，因为上面这个方法在调用之前会先调用 heightForRowAtIndexPath 这个方法本身，有点像循环引用的概念。</li>
<li>直接用 <code>[[CustomCell alloc] init]</code> 来创建一个 cell 呢？如果使用的是 xib 或者纯代码的方式来创建布局的，那么当然没问题，不过千万不要忘了，在 VC 的某个地方调用一个 tableView 的 <code>registerClass:forCellReuseIdentifier:</code> 方法，把这个 CustomCell 给注册一下，否则会拿不到 cell 对应的属性。</li>
<li>对于 Storyboard 来说，因为 CustomCell 是直接放在 tableView 里面的，IB 已经帮你完成了这一切，所以不需要 registerClass 。如果你执意要注册一下的话，不仅没有任何好处，反而会破坏了 IB 的和谐，导致 <code>tableView:cellForRowAtIndexPath:</code> 里面的 dequeue 方法无法返回一个正确的 cell。</li>
</ul>
<p>综上所述，用 Storyboard 就没有办法完成“创建一个 offscreen cell ”这一步了么？非也。<br>
TableView 还有一个方法叫 <code>[dequeueReusableCellWithIdentifier:]</code> ，注意到它没有了 indexPath 这个参数，所以它不会去调用 <code>tableView:heightForRowAtIndexPath:</code> ，这给我们提供了一线希望。于是，完整的代码是这样的：<br>
<img src="/uploads/using-autolayout-in-uitableviewcells/offscreen-cell-code.png" alt="offscreen-cell-code"></p>
<p>这里用到了 static 和 dispatch_once 来使得这个 offscreen cell 只需要被创建一次，然后就可以循环利用了，环保？</p>
<h4 id="填充数据">填充数据</h4>
<p>这里又是常规的填充数据，再啰嗦一次：如果使用了子类化 UILabel，那么这一步做的事会比看起来强大得多。不过，目前为止，这里看起来也只是填充一下数据而已。</p>
<h4 id="计算高度">计算高度</h4>
<p>这里我们要用到 cell.contentView 里一个很强大的方法：<code>[systemLayoutSizeFittingSize:]</code>，后面跟的参数有两个可选项： <code>UILayoutFittingCompressedSize</code> 和 <code>UILayoutFittingExpandSize</code> ，前者会得到满足所有约束的最小 size ，后者得到的是最大 size 。</p>
<p>这个方法看似方便，但也是因为我们前面做了许许多多的铺路：我们设置了贯通上下的约束，让 cell 能知道自己的内容总共有多高；我们设置了 UILabel 的 preferredMaxLayoutWidth ，让它们知道内容太多的时候要往下排列，等等等等。</p>
<p>在调用这个方法之前，为了保险起见，还是要让 cell 自己适当排列一下自己的 subviews ，完整代码如下：<br>
<img src="/uploads/using-autolayout-in-uitableviewcells/return-height-code.png" alt="return-height-code"><br>
最后的<code>+1</code>只是为了让 cell 之间有 1pt 的空间容纳 separator。</p>
<h2 id="写在最后">写在最后</h2>
<p>到这里，一个可以自适应内容高度的 cell 就已经做好了。虽然整篇文章看起来挺长，但是实际写起来代码量也并不大。</p>
<p>其实如果还是觉得麻烦的话，让应用直接支持 iOS 8 以上不就好了:)</p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"8225264e14e677544541","clientSecret":"ed2a2c6d5043e9f0b41cae78b0d5b4571099de53","repo":"HexoBlogSource","owner":"davidleee","admin":["davidleee"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>AutoLayout</tag>
        <tag>UITableViewCell</tag>
      </tags>
  </entry>
  <entry>
    <title>又一篇 iOS Extension 入门（3/3）— Today 小组件</title>
    <url>/2018/11/15/yet-another-ios-extension-article-3/</url>
    <content><![CDATA[<p>昨天通过两篇文章介绍了 iOS Extension 的基础，并尝试制作了一个分享扩展，让我们的应用可以接收到从其他应用分享过来的数据，还实现了跨沙盒的应用扩展与载体间的通信。</p>
<p>看上面这段话就觉得内容挺多的吧…所以专门把 Extension 界的当红选手 —— Today 小组件单独放在这一篇文章里面讲，作为这个 iOS Extension 入门系列的收尾～</p>
<p>让我们马上进入正题！</p>
<span id="more"></span>
<h2 id="啥是-Today-小组件">啥是 Today 小组件</h2>
<p>展示在 Today 界面（手机主页最左屏）里的应用扩展统称为“小组件”（Widget）。小组件存在的目的是向用户快速展示<strong>当下</strong>最重要的信息，并提供一些简易的任务处理功能，比如“把任务标记为完成”之类的。</p>
<blockquote>
<p>官方建议： Today 小组件负责的任务最好在单次操作内就能完成，如果你发现这个任务需要多个步骤，那 Today 小组件也许不是最适合的扩展点。具体扩展点参见 <a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/index.html#//apple_ref/doc/uid/TP40014214-CH20-SW3">官方扩展点列表</a> 或者这个系列文章的第一篇（<a href="/2018/11/14/yet-another-ios-extension-article/" title="又一篇 iOS Extension 入门（1&#x2F;3）— 基础 &amp; 分享扩展">又一篇 iOS Extension 入门（1&#x2F;3）— 基础 &amp; 分享扩展</a>）里的翻译版。</p>
</blockquote>
<h3 id="划重点">划重点</h3>
<p>iOS 和 macOS 平台上都有 Today 小组件，在开发过程中需要注意的地方是相同的：</p>
<ul>
<li>确保内容是最新的</li>
<li>谨慎地对待用户交互</li>
<li>性能调优</li>
</ul>
<blockquote>
<p>从交互上来说，务必避免在小组件里放滚动列表，因为用户很难区分小组件内部的滚动和整个小组件列表的滚动</p>
</blockquote>
<p><strong>在 iOS 上</strong>：小组件不允许键盘输入，所以一切针对小组件的设置都应该在载体应用内完成。以“股市”为例，用户可以直接在小组件上切换显示的单位，但是股票列表的编辑需要在载体应用里进行。<br>
<strong>在 macOS 上</strong>：载体应用可以不做任何功能，小组件可以提供一个配置入口。还是以“股市”为例，小组件里可以直接搜索、添加和删除特定股票。</p>
<h2 id="来做一个-Today-小组件吧">来做一个 Today 小组件吧</h2>
<p>就像创建分享扩展那样，首先要在项目配置里添加一个 Target（复习<a href="/2018/11/14/yet-another-ios-extension-article/" title="系列文章第一篇">系列文章第一篇</a>），如果想要共享数据的话，还需要配置一下 Capabilities -&gt; App Groups（复习<a href="/2018/11/14/yet-another-ios-extension-article-2/" title="系列文章第二篇">系列文章第二篇</a>）。</p>
<p>Xcode 依旧贴心地为我们创建了一个目录，随便点开看看，可以发现 <em>Info.plist</em> 里关于 <code>NSExtension</code> 的内容有所不同，其中的 <code>NSExtensionActivationRule</code> 字段已经没有了，因为 Today 小组件的开关是用户自己选择操作的，不需要我们开发者去判断。</p>
<h3 id="界面">界面</h3>
<blockquote>
<p>为了实现最好的效果，建议使用 AutoLayout 去做界面的布局。</p>
</blockquote>
<p>Today 小组件的宽度是固定的，高度上有延伸的空间以显示更多的内容。Xcode 创建的 IB 模版里已经用上了 AutoLayout，并用上了标准的四周间隔，我们可以通过 <code>widgetMarginInsetsForProposedMarginInsets:</code> 方法来获取到这些间隔以便计算。</p>
<blockquote>
<p>模版里的 VC 已经实现了 <code>NSWidgetProviding</code> 协议，上述方法就是在这个协议里定义的。</p>
</blockquote>
<p>界面部分最值得一提的就是右上角的“展开/折叠”了。这个按钮默认情况下并不会显示，需要我们添加一些代码来实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">	  <span class="comment">// 1</span></span><br><span class="line">    extensionContext<span class="operator">?</span>.widgetLargestAvailableDisplayMode <span class="operator">=</span> .expanded</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">widgetActiveDisplayModeDidChange</span>(<span class="keyword">_</span> <span class="params">activeDisplayMode</span>: <span class="type">NCWidgetDisplayMode</span>, <span class="params">withMaximumSize</span> <span class="params">maxSize</span>: <span class="type">CGSize</span>)</span> &#123;</span><br><span class="line">	  <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">if</span> activeDisplayMode <span class="operator">==</span> .expanded &#123;</span><br><span class="line">        preferredContentSize <span class="operator">=</span> <span class="type">CGSize</span>(width: maxSize.width, height: <span class="number">200</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        preferredContentSize <span class="operator">=</span> maxSize</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>告诉 <code>extensionContext</code> 我们的小组件是支持展开的，这个属性的默认值是 <code>.compact</code></li>
<li>用户点击“展开/折叠”的回调，如果不进行处理，小组件的高度不会发生变化</li>
<li>修改小组件的高度，这里的 <code>maxSize</code> 是系统限制的当前模式下的最大尺寸，使用 iPhone XR 模拟器测试时，<code>.compact</code> 模式下是 <code>(398, 110)</code>，<code>.expanded</code> 模式下是 <code>(398, 748)</code>。可见，苹果限制了折叠状态下最大高度为 110，超出部分会直接截掉；而展开状态下，最大高度为设备的高度。</li>
</ol>
<p>界面部分就没什么了，剩下的该是具体问题具体分析。接下来轮到功能逻辑的部分。</p>
<h3 id="跳转到载体应用">跳转到载体应用</h3>
<p>实际上，小组件还是通过 Universal Link 的机制来唤起载体应用的，与应用间跳转没有什么区别，只不过需要通过 <code>extensionContext</code> 来调用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 唤起 URL Schemes 为 davidleee 的应用</span></span><br><span class="line">extensionContext<span class="operator">?</span>.open(<span class="type">URL</span>(string: <span class="string">&quot;davidleee://&quot;</span>)<span class="operator">!</span>, completionHandler: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>需要注意的是，如果你的小组件要打开第三方的应用，在提交 App Store 审核的时候需要特别说明一下，否则会被打回。</p>
<blockquote>
<p>关于 Universal Link 的官方文档在这里：<a href="https://developer.apple.com/ios/universal-links/">Universal Links - Apple Developer</a>，我也写过一篇文章记录了可能存在的一些坑，感兴趣的可以瞅瞅：<a href="/2017/01/04/universal-link-problems/" title="Universal Link（iOS）踩坑">Universal Link（iOS）踩坑</a></p>
</blockquote>
<h3 id="数据更新">数据更新</h3>
<p>既然 Today 小组件的目的就是为用户提供最新鲜的数据，那么数据更新的部分就一定不能马虎。</p>
<p>在 Xcode 帮我们创建的 <code>TodayViewController</code> 里面，我们可以看到一个叫  <code>widgetPerformUpdate(completionHandler:)</code> 的方法，在它的描述里能看到这么一句话：</p>
<p><em>This method is called to give a widget an opportunity to update its contents and redraw its view prior to an operation such as a snapshot.</em></p>
<p>苹果设计这个 API 是为了把数据的更新统一放到一个地方去。如果我们实现了这个方法，系统就会在合适的时候调用这个方法（比如系统想要给你的小组件进行 snapshot 之前），给我们一次更新数据的机会，并且这个机会不一定出现在小组件显示出来的时候，在后台的情况下也有可能触发这个回调。</p>
<p>于是我们就有两个拉数据的机会：</p>
<ul>
<li>在 <code>viewDidLoad</code> 里面</li>
<li>在 <code>widgetPerformUpdate(completionHandler:)</code> 里面</li>
</ul>
<blockquote>
<p>实验发现，小组件只要不可见的时间稍微长一点点，比如滚动出了屏幕，或离开 Today 视图一小会，它就会被重新初始化，也就是说 <code>viewDidLoad</code> 的调用会比想象中更频繁。但这并不意味着我们可以完全依赖 <code>viewDidLoad</code> 来做数据更新。</p>
</blockquote>
<p>在 SO 上的<a href="https://stackoverflow.com/questions/25168950/what-is-the-purpose-of-widgetperformupdatewithcompletionhandler-in-ios-8-today-w">这个讨论</a>里，对数据更新的时机进行了更多的讨论，总结起来就是两点：</p>
<ol>
<li>苹果希望你在整个生命周期里尽可能早的地方进行数据更新，所以 <code>viewDidLoad</code> 要用</li>
<li><code>viewDidLoad</code> 还不够，那就用上 <code>widgetPerformUpdate(completionHandler:)</code>，毕竟前者并不会在后台情况下被调用</li>
</ol>
<h2 id="总结一下">总结一下</h2>
<p>Today 小组件就是一个用来展示<strong>小块</strong>数据和处理<strong>简单</strong>任务的地方。</p>
<p>注意上面那句话加粗的两个词，这给小组件定下了一个主基调：敏捷，所以凡是逻辑越写越复杂的时候，都该停下来想一想：这些逻辑是不是应该挪到载体应用里面去做？</p>
<blockquote>
<p>用这个理由去怼产品经理吧，就说是那个估值超万亿的苹果的产品经理说的～</p>
</blockquote>
<h2 id="参考文章">参考文章</h2>
<ul>
<li><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/Today.html#//apple_ref/doc/uid/TP40014214-CH11-SW1">App Extension Programming Guide: Today</a></li>
<li><a href="https://medium.com/nine9devtw/ios-today-extension-swift-%E6%95%99%E5%AD%B8%E7%AD%86%E8%A8%98-5361446d1950">iOS today extension (swift) 教學筆記 – 碼農勤耕田 – Medium</a></li>
<li><a href="https://stackoverflow.com/questions/25168950/what-is-the-purpose-of-widgetperformupdatewithcompletionhandler-in-ios-8-today-w">ios8 - What is the purpose of widgetPerformUpdateWithCompletionHandler in iOS 8 Today Widget? - Stack Overflow</a></li>
</ul>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"8225264e14e677544541","clientSecret":"ed2a2c6d5043e9f0b41cae78b0d5b4571099de53","repo":"HexoBlogSource","owner":"davidleee","admin":["davidleee"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>Universal Link</tag>
        <tag>ios</tag>
        <tag>Today Extension</tag>
        <tag>Widget</tag>
      </tags>
  </entry>
  <entry>
    <title>又一篇 iOS Extension 入门（1/3）— 基础 &amp; 分享扩展</title>
    <url>/2018/11/14/yet-another-ios-extension-article/</url>
    <content><![CDATA[<p>应用扩展（App Extension）让你应用的功能和内容都得到了更大的延伸，这让用户在使用其他应用的时候有机会与你的应用发生交互。在这个大家都极力争夺注意力的时代，应用扩展无疑为我们打开了一扇新的大门。</p>
<span id="more"></span>
<h2 id="什么是应用扩展？">什么是应用扩展？</h2>
<p>应用扩展与应用本身是有不同的。尽管在上架应用扩展的时候，你必须以一个普通的应用为载体（Containing App），但是它实际上是一个独立的二进制文件，而且并不依赖于载体应用来运行。</p>
<p>具体来说，应用扩展分为了十多个类别，你可以通过它们来实现各种各样的功能。下面是官方文档里介绍扩展点（Extension Point）的表格，我调整了一下格式：<br>
<img src="/uploads/yet-another-ios-extension-article/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-13%20%E4%B8%8B%E5%8D%8812.05.50.png" alt=""></p>
<p>我们创建的每一个应用扩展都必须与上表的其中一个扩展点相对应，不允许出现一个应用扩展对应多个扩展点的情况。换句话说，每个应用扩展的职责都应该是单一的，我们应该给用户提供快速、线性、聚焦的体验。</p>
<h2 id="应用扩展是怎么工作的？">应用扩展是怎么工作的？</h2>
<h3 id="生命周期">生命周期</h3>
<p>应用扩展的生命周期有别于一般的应用。应用扩展通常会在另一个应用的使用过程中被唤起，这个应用被称为宿主应用（Host App），宿主应用定义了与应用扩展交流的上下文，并通过发送请求的方式把应用扩展给启动起来。一般来说，应用扩展在完成宿主应用请求的任务之后，生命周期就结束了。<br>
<img src="/uploads/yet-another-ios-extension-article/app_extensions_lifecycle_2x.png" alt=""></p>
<blockquote>
<p>注意区分“载体应用”和“宿主应用”。载体应用是这个应用扩展的容器，在我们实现应用扩展的时候一并开发出来的；“宿主应用”指的是实际使用过程中调起我们的应用扩展的那个应用。</p>
</blockquote>
<p>在上图第2步里，系统在启动了我们的应用扩展之后，会在应用扩展和宿主应用之间建立一条通信通道，用于传递宿主应用定义好的上下文和相关信息。</p>
<p>应用扩展根据宿主应用发来的请求，执行相应的任务，这些任务可能是立即返回的，也可能通过一个后台进程去完成。但无论是哪种方式，在应用扩展跑完自己的代码逻辑之后，系统就会立马把它结束掉。</p>
<h3 id="通信">通信</h3>
<p>上面提到应用扩展和宿主应用之间的通信方式，一个完整的通信关系是这样的：<br>
<img src="/uploads/yet-another-ios-extension-article/simple_communication_2x.png" alt=""></p>
<p>应用扩展不会直接跟载体应用打交道，因为大多数情况下，应用扩展在工作的时候，载体应用甚至都还没有被启动。</p>
<p>在特殊情况下，比如 Today 小组件，扩展可以向系统提出启动载体应用的申请（通过调用 <code>NSExtensionContext</code> 的 <code>openURL:completionHandler:</code> 方法）。这时，应用扩展与载体应用就可以通过一个私有的共享容器来传递数据了，如下图所示：<br>
<img src="/uploads/yet-another-ios-extension-article/detailed_communication_2x.png" alt=""></p>
<blockquote>
<p>从系统层面上看，这已经涉及到进程间通信了，但苹果提供的高级 API 很好地屏蔽了这一点，所以我们完全不用考虑这些事情。</p>
</blockquote>
<h3 id="应用扩展的“禁忌”">应用扩展的“禁忌”</h3>
<p>因为应用扩展与一般应用的设计是不同的，所以虽然开发起来差不多，但有些 API 是应用扩展无法使用的：</p>
<ul>
<li>不能访问 <code>sharedApplication</code></li>
<li>不能使用头文件里宏定义了 <code>NS_EXTENSION_UNAVAILABLE</code> 的框架，比如 HealthKit 和 EventKit UI 框架</li>
<li>不能访问摄像头和麦克风，除非它是 iMessage 应用</li>
<li>不能执行耗时过长的任务，具体限制与平台相关，但是它可以通过 <code>NSURLSession</code> 对象来实现数据上传和下载，最终的结果会给到载体应用</li>
<li>不能接收 AirDrop 数据，但是它可以发送</li>
</ul>
<h2 id="创建应用扩展">创建应用扩展</h2>
<p>因为每一个扩展点都对应了一个特定的应用场景，所以创建应用扩展的第一步是选择正确的扩展点（可以回到文章开头部分查看扩展点表格）。</p>
<p>在 File -&gt; New -&gt; Target 里面，找到 Application Extension 模块，在里面选择想要实现的扩展点。这里我选了分享扩展作为例子：<br>
<img src="/uploads/yet-another-ios-extension-article/7AA6705E-C543-4011-A638-E171E66F8E54.png" alt=""></p>
<p>给你的应用扩展起个美美的名字之后，它就会出现在项目配置的侧边栏里了，同时，Xcode 还为我们新建的应用扩展添加了一个 Scheme，让我们可以直接调式扩展而不用启动载体应用：<br>
<img src="/uploads/yet-another-ios-extension-article/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-13%20%E4%B8%8B%E5%8D%885.45.59.png" alt=""></p>
<p>直接运行应用扩展，Xcode 会让你选一个应用来作为应用扩展的宿主：<br>
<img src="/uploads/yet-another-ios-extension-article/A1A7864C-EA2B-4823-A33D-91656F91569A.png" alt=""></p>
<p>分享扩展的兼容性很好，我们选 Safari 来尝试分享一个网页好了：<br>
<img src="/uploads/yet-another-ios-extension-article/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-13%20%E4%B8%8B%E5%8D%885.48.58.png" alt=""><br>
随便打开一个网页，点击下面的分享按钮，可以看到我们的应用扩展已经出现在分享列表里面了！</p>
<blockquote>
<p>应用扩展的图标会跟载体应用的图标一致</p>
</blockquote>
<h2 id="Talk-is-Cheap">Talk is Cheap!</h2>
<p>创建了应用扩展之后，会发现项目结构里多了一个属于应用扩展的位置：<br>
<img src="/uploads/yet-another-ios-extension-article/65CB2068-CB5B-4443-A46B-3D8DC3DD5F30.png" alt=""></p>
<p>看起来就像一个普通的应用项目的结构，但 <em>Info.plist</em> 里有一个不同点，就是这里的 <code>NSExtension</code> 字典：<br>
<img src="/uploads/yet-another-ios-extension-article/125ED1F7-CCA8-4D23-9218-5D8212E2D5D8.png" alt=""><br>
看名字都挺好懂的，其中的 <code>NSExtensionAttributes</code> 用来配置一些通用参数，比如支持的媒体类型等等。默认情况下，<code>NSExtensionActivationRule</code> 是一个 <code>String</code> 类型，这个值就是让系统在所有分享场景里都显示我们的应用扩展（我全都要！）。更真实的场景应该是只支持特定的文件类型，这时可以把它改成 <code>Dictionary</code> 类型：<br>
<img src="/uploads/yet-another-ios-extension-article/D7E348AB-33CD-4DC6-9F54-2005AE2BA66E.png" alt=""></p>
<p>上图的设置表示：我们支持分享图片、视频、文件和网页链接，后面的数字表示：一次分享中支持带上多少个这种类型的附件。</p>
<blockquote>
<p>除图片和视频外的文件类型，都包括在 File 的范围里面，所以上面的配置几乎涵盖了所有的文件分享场景了</p>
</blockquote>
<h3 id="响应请求">响应请求</h3>
<p>在 Xcode 创建好的 <code>ShareViewController</code> 里，我们可以通过 <code>extensionContext</code> 来拿到宿主应用想要传达给我们的信息：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> items <span class="operator">=</span> <span class="keyword">self</span>.extensionContext<span class="operator">?</span>.inputItems</span><br></pre></td></tr></table></figure>
<p>这是一个 <a href="https://developer.apple.com/documentation/foundation/nsextensionitem">NSExtensionItem</a> 数组，每一个 <code>NSExtensionItem</code> 都带有一系列属性，例如标题、内容、附件、用户信息。</p>
<p>系统会回调 <code>didSelectPost</code> 或 <code>didSelectCancel</code> 以通知我们用户操作的结果，在这两个回调方法里，我们需要调用 <code>completeRequest(returningItems:completionHandler:)</code> 返回一系列 <code>NSExtensionItem</code> 对象给宿主应用，或者调用 <code>cancelRequest(withError:)</code> 返回一个错误。</p>
<h3 id="获取附件">获取附件</h3>
<p>从 <code>NSExtensionItems</code> 里能直接获取到的信息是远远不够的，真正的大部头都在 <code>attachments</code> 这个属性里。这是一个 <a href="https://developer.apple.com/documentation/foundation/nsitemprovider">NSItemProvider</a> 类型的数组，自此我们就基本看到了整个 <code>NSExtensionContext</code> 的构成了，借用一张其他博客的图片：<br>
<img src="/uploads/yet-another-ios-extension-article/221150_8LYD_222120.png" alt=""></p>
<p>好，回到正题。拿到 <code>NSItemProvider</code> 之后，会发现要从这个类里面拿东西并不简单。</p>
<p>继续上面的例子，我们打算在用户点击 “Post” 按钮之后，获取从 Safari 分享过来的 URL，完整的代码是这样的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didSelectPost</span>()</span> &#123;</span><br><span class="line">    <span class="comment">// This is called after the user selects Post. Do the upload of contentText and/or NSExtensionContext attachments.</span></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> items <span class="operator">=</span> extensionContext<span class="operator">?</span>.inputItems <span class="keyword">as?</span> [<span class="type">NSExtensionItem</span>] <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items &#123;</span><br><span class="line">        <span class="keyword">for</span> attachment <span class="keyword">in</span> item.attachments <span class="operator">??</span> [] &#123;</span><br><span class="line">            <span class="comment">// 3</span></span><br><span class="line">            <span class="keyword">if</span> attachment.hasItemConformingToTypeIdentifier(kUTTypeURL <span class="keyword">as</span> <span class="type">String</span>) &#123;</span><br><span class="line">                <span class="comment">// 4</span></span><br><span class="line">                attachment.loadItem(forTypeIdentifier: kUTTypeURL <span class="keyword">as</span> <span class="type">String</span>, options: <span class="literal">nil</span>) &#123; (item, error) <span class="keyword">in</span></span><br><span class="line">                                                                                            <span class="keyword">if</span> error <span class="operator">==</span> <span class="literal">nil</span> &#123;</span><br><span class="line">                                                                                                <span class="built_in">print</span>(<span class="string">&quot;found an url: <span class="subst">\(item)</span>&quot;</span>)</span><br><span class="line">                                                                                            &#125;</span><br><span class="line">                                                                                           &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inform the host that we&#x27;re done, so it un-blocks its UI. Note: Alternatively you could call super&#x27;s -didSelectPost, which will similarly complete the extension context.</span></span><br><span class="line">    <span class="keyword">self</span>.extensionContext<span class="operator">!</span>.completeRequest(returningItems: [], completionHandler: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>inputItems</code> 是一个 <code>[Any]</code> 类型的数组，所以在使用之前需要转换一下</li>
<li>如果允许用户分享的时候多选的话，需要逐层遍历 <code>items</code> 和 <code>attachments</code></li>
<li>判断附件的类型，附件类型使用 <a href="https://developer.apple.com/library/archive/documentation/Miscellaneous/Reference/UTIRef/Articles/System-DeclaredUniformTypeIdentifiers.html#//apple_ref/doc/uid/TP40009259-SW1">UTI（Uniform Type Identifier）</a> 来表示，在 iOS 平台使用的时候需要先执行 <code>import MobileCoreService</code></li>
<li>读取指定类型的附件内容，回调过来的 <code>item</code> 是 <code>NSSecureCoding?</code> 类型的，这里只简单打印了一下，真正使用的时候还需要补充一些额外处理</li>
</ol>
<h2 id="性能要求">性能要求</h2>
<p>应用扩展对于用户来说应该是敏捷而且轻量的小工具，所以它的启动速度务必要保持在1秒以内，系统会自动关闭启动耗时太长的应用扩展。</p>
<p>对于 Widget 来说，界面上通常会一次显示多个，所以 Widget 的内存使用要求是最严格的（大概是16 MB），一旦超出了限制，会显示 “Unable to Load” 的字样：<br>
<img src="/uploads/yet-another-ios-extension-article/TodayWidgetUnableToLoad.jpg" alt=""></p>
<p>其他类型的应用扩展对内存的要求会松一点，但还是比一般应用要严格，比如自定义键盘要求 48 MB 以下，分享扩展要求 120 MB 以下，实际情况可能跟设备相关。</p>
<p>另外，应用扩展是公用同一个主线程的，所以不要在应用扩展的逻辑里做可能会阻塞主线程的操作。同理，GPU 也是这样一个共享资源，如果一个应用扩展需要执行大量绘图逻辑，系统会倾向于把它结束掉。</p>
<p>总而言之，开销大的操作都应该在载体应用里做，而不是让应用扩展去负责。</p>
<h2 id="总结一下">总结一下</h2>
<p>本文介绍了什么是应用扩展，并介绍了一个简单的分享扩展是怎么实现的。文章大体是来源于官方的文档，虽然文档已经被苹果归档了，但是文中的代码都是我写完用模拟器验证后得来的（2018年11月14日），大家可以直接拿走按需服用 :)</p>
<blockquote>
<p>没想到只是介绍了一些基础就写了这么多。其实我还打算讲讲分享之后怎么跟载体应用交互，还想要看看今日小组件（Today Widget）怎么整…只好放到后面的文章里去了。  我发誓在这周之内把这两部分内容都给补上来！</p>
<p>你们看，我写完了：</p>
<ul>
<li>
<a href="/2018/11/14/yet-another-ios-extension-article-2/" title="又一篇 iOS Extension 入门（2&#x2F;3）— 与容器沟通">又一篇 iOS Extension 入门（2&#x2F;3）— 与容器沟通</a>
</li>
<li>
<a href="/2018/11/15/yet-another-ios-extension-article-3/" title="又一篇 iOS Extension 入门（3&#x2F;3）— Today 小组件">又一篇 iOS Extension 入门（3&#x2F;3）— Today 小组件</a>
</li>
</ul>
</blockquote>
<h2 id="参考文章">参考文章</h2>
<ul>
<li><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/index.html#//apple_ref/doc/uid/TP40014214-CH20-SW1">App Extension Programming Guide: App Extensions Increase Your Impact</a></li>
<li><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/Share.html#//apple_ref/doc/uid/TP40014214-CH12-SW1">App Extension Programming Guide: Share</a></li>
<li><a href="https://my.oschina.net/vimfung/blog/707448">iOS扩展开发攻略(一) - Share Extension - vimfung的开源部落 - 开源中国</a></li>
</ul>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"8225264e14e677544541","clientSecret":"ed2a2c6d5043e9f0b41cae78b0d5b4571099de53","repo":"HexoBlogSource","owner":"davidleee","admin":["davidleee"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>ios</tag>
        <tag>App Groups</tag>
        <tag>Extension</tag>
        <tag>Share</tag>
        <tag>NSExtensionItem</tag>
        <tag>NSItemProvider</tag>
      </tags>
  </entry>
  <entry>
    <title>又一篇 iOS Extension 入门（2/3）— 与容器沟通</title>
    <url>/2018/11/14/yet-another-ios-extension-article-2/</url>
    <content><![CDATA[<p>在<a href="/2018/11/14/yet-another-ios-extension-article/" title="上一篇文章">上一篇文章</a>里，我们了解到了 iOS Extension 的基础和怎么制作一个简单的分享扩展，然而，限于篇幅原因，这个分享操作止于用户点下 “Post” 的那一刻了。<br>
接下来，就让我们一起看看怎么把用户分享的数据给到载体应用，让这次分享溜得飞起。</p>
<span id="more"></span>
<h2 id="App-Groups">App Groups</h2>
<p>我们都知道 iOS 的应用是跑在一个属于自己的沙盒里面的，为了实现应用间的数据共享，苹果提供了一个叫 App Groups 的概念。只有当应用属于同一个 App Groups 的时候，才能访问到共享的数据存储区域。</p>
<p>我们可以在载体应用的项目配置 Capabilities -&gt; App Groups 里创建一个应用分组：<br>
<img src="/uploads/yet-another-ios-extension-article-2/77534A33-46E6-4381-B6EC-4AA09E726A6A.png" alt=""></p>
<p>然后在应用扩展的项目配置 Capabilities -&gt; App Groups 里会出现我们刚刚新建的应用分组，直接钩上就可以了。</p>
<p>这样我们就等于分配了一个共享空间给这哥俩，为我们接下来的数据共享做好准备了。</p>
<h2 id="共享空间">共享空间</h2>
<p>做完上面的准备之后，我们就可以通过三种方式去访问共享空间，它们分别是 <code>UserDefaults</code>、<code>FileManager</code> 和 <code>CoreData</code>。</p>
<h3 id="UserDefaults">UserDefaults</h3>
<p><code>UserDefaults</code> 有一个带参数的初始化方法，通过这个方法我们可以访问到一个共享的用户配置空间。在上一篇文章里，我们成功把 Safari 分享出来的一个 URL 打印了出来，现在我们把它放到共享空间去，让载体应用也可以获取到这个链接：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">...</span></span><br><span class="line"></span><br><span class="line">attachment.loadItem(forTypeIdentifier: kUTTypeURL <span class="keyword">as</span> <span class="type">String</span>, options: <span class="literal">nil</span>) &#123; (item, error) <span class="keyword">in</span></span><br><span class="line">                        <span class="keyword">if</span> error <span class="operator">==</span> <span class="literal">nil</span> &#123;</span><br><span class="line">                            <span class="keyword">let</span> userDefaults <span class="operator">=</span> <span class="type">UserDefaults</span>(suiteName: <span class="string">&quot;group.com.davidleee.SharePlayground&quot;</span>)</span><br><span class="line">                            userDefaults<span class="operator">?</span>.set(item, forKey: <span class="string">&quot;share-url&quot;</span>)</span><br><span class="line">							   <span class="built_in">print</span>(<span class="string">&quot;url from userdefault: <span class="subst">\(userDefaults<span class="operator">?</span>.value(forKey: <span class="string">&quot;share-url&quot;</span>))</span>&quot;</span>)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>
<p>通过传入之前设置好的应用分组 ID，我们告诉 <code>UserDefault</code> 接下来要访问一个特定的共享空间，接着就像平常那样使用它即可。</p>
<blockquote>
<p>上面的打印输出的是一堆 data，以为 <code>URL</code> 在保存到 <code>UserDefaults</code> 的时候会被序列化，想看到原来的 <code>URL</code> 对象的话还要再反序列化一下才行。</p>
</blockquote>
<h3 id="FileManager">FileManager</h3>
<p>与 <code>UserDefaults</code> 类似，<code>FileManager</code> 也有一个特殊的获取方法，我们看看把刚刚的 URL 写到一个文本文件里应该是什么样子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> groupPath <span class="operator">=</span> <span class="type">FileManager</span>.default.containerURL(forSecurityApplicationGroupIdentifier: <span class="string">&quot;group.com.davidleee.SharePlayground&quot;</span>)</span><br><span class="line">                            <span class="keyword">if</span> <span class="keyword">let</span> url <span class="operator">=</span> item <span class="keyword">as?</span> <span class="type">URL</span>, <span class="keyword">let</span> filePath <span class="operator">=</span> groupPath<span class="operator">?</span>.appendingPathComponent(<span class="string">&quot;url.txt&quot;</span>)  &#123;</span><br><span class="line">                                <span class="keyword">try?</span> url.absoluteString.write(to: filePath, atomically: <span class="literal">true</span>, encoding: .utf8)</span><br><span class="line">                            &#125;</span><br><span class="line">                            </span><br><span class="line">                            <span class="keyword">if</span> <span class="keyword">let</span> filePath <span class="operator">=</span> groupPath<span class="operator">?</span>.appendingPathComponent(<span class="string">&quot;url.txt&quot;</span>) &#123;</span><br><span class="line">                                <span class="keyword">try?</span> <span class="built_in">print</span>(<span class="string">&quot;content of file: <span class="subst">\(String(contentsOf: filePath, encoding: .utf8))</span>&quot;</span>)</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>
<h3 id="CoreData">CoreData</h3>
<p>好吧，CoreData 的共享空间其实跟 <code>FileManager</code> 是同一个，只是从写文件变成写数据库，再把数据库的文件放到共享空间而已。这个就不贴代码了，CoreData 里的类名是真的长…</p>
<h2 id="总结一下">总结一下</h2>
<p>感觉这篇文章跟应用扩展都没什么关系了…毕竟 App Goups 是 iOS 平台上一个比较通用的数据共享技术。</p>
<p>App Groups 的引入让 iOS 应用间数据共享成为可能，这不仅可以用在应用扩展和载体应用之间，还可以用在自家的多个独立应用之间，真可谓是沙盒墙上透过来的一道亮光。</p>
<h2 id="参考文章">参考文章</h2>
<ul>
<li><a href="https://my.oschina.net/vimfung/blog/707448">iOS扩展开发攻略(一) - Share Extension - vimfung的开源部落 - 开源中国</a></li>
</ul>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"8225264e14e677544541","clientSecret":"ed2a2c6d5043e9f0b41cae78b0d5b4571099de53","repo":"HexoBlogSource","owner":"davidleee","admin":["davidleee"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>ios</tag>
        <tag>App Groups</tag>
        <tag>Extension</tag>
        <tag>UserDefaults</tag>
        <tag>FileManager</tag>
        <tag>CoreData</tag>
      </tags>
  </entry>
  <entry>
    <title>20分钟手把手教你写 macOS 文本编辑器</title>
    <url>/2017/09/11/Windows-in-macOS/</url>
    <content><![CDATA[<p>相较于 iOS 上火热的开发势头，macOS 开发简直就是一片蓝海。让人不禁有些好奇，本是同根生的 macOS 开发究竟是一番怎样的光景？在略微接触之后发现，除了 UIKit 被 AppKit 替换之外，最明显的是 macOS 对待 Window 的态度转变，想想也是，毕竟桌面端应用的效率优势很大一部分就是体现在窗口多开上。然而找了找现有的资料，关于 macOS 开发的实在不多，于是就在学习的过程中翻译一篇国外教程，为社区做点贡献。</p>
<p>本文是 <a href="https://www.raywenderlich.com/">RayWenderlich</a> 上的一篇翻译文，里面带着读者从无到有地构建了一个简单的文本编辑器，内容会涉及到 macOS 上 Window 相关的一些使用基础。翻译里加入了一点个人理解，但是技术部分是忠于原文的，不放心的可以直接到官网上看：</p>
<p>原文链接：<a href="https://www.raywenderlich.com/159287/windows-windowcontroller-tutorial-macos">Windows and WindowController Tutorial for macOS</a></p>
<p>说太多了，来看正文啦！</p>
<span id="more"></span>
<p>Window 是一切 macOS 应用的界面载体，它定义了一个专属于某个应用的区域，并作为多任务处理的标识展现给用户。</p>
<p>一切 macOS Apps 都不外乎是下面三种类型之一：</p>
<ul>
<li>单一窗口工具型应用（一个界面就完成所有功能），比如<strong>计算器</strong></li>
<li>单一窗口图书馆式应用（一个窗口完成所有功能，但这个窗口里的界面可能有许多个），比如<strong>照片</strong></li>
<li>多窗口的基于文档的应用，比如<strong>文本编辑</strong></li>
</ul>
<p>这篇教程将会涵盖下列知识：</p>
<ul>
<li>Windows 和 windowControllers</li>
<li>文档（Document）架构</li>
<li>NSTextView</li>
<li>模态窗口</li>
<li>菜单栏和菜单项</li>
</ul>
<p>而看这篇文章的读者们可能需要提前掌握这些知识：</p>
<ul>
<li>Swift 3 或更高版本的 Swift 语法</li>
<li>Xcode 和 Storyboards 的基本操作</li>
<li>在 Mac App 上实现一个 Hello world</li>
<li>控件的响应链</li>
</ul>
<h2 id="那么就开始吧">那么就开始吧</h2>
<p>同创建一个计算器 App 不同的是，我们将要创建的是一个基于文档的应用，在创建工程项目的时候，Xcode 会给出提示让你选择应用的类型：</p>
<img src="/uploads/Windows-in-macOS/create-project.png" class="center" title="Create Project">
<p>上面的内容可以自由发挥，唯独红框的部分要注意一下：</p>
<ul>
<li>Create Document-Based Application 要勾上，此时 Xcode 会为你生成基于文档型应用的示例代码，能省去我们不少工作量</li>
<li>Document Extension 是告诉 Xcode 我们这个应用要操作的文档的后缀，我这个 Demo 的名字叫 “MyTextEditor”，所以我就取首字母 “mte” 作为后缀了</li>
<li>下面是关于数据库和测试的部分，同样是勾了就会有示例代码，但我们这里不需要，所以不勾选它们以排除一些干扰</li>
</ul>
<p>项目创建好后马上就可以运行了，原始的 MyTextEditor 应该是这个样子的：</p>
<img src="/uploads/Windows-in-macOS/raw-window.png" class="center" title="Empty Window">
<p>而且它已经具有一些基本功能了，比如你已经可以新建很多个窗口（不过这些窗口是重叠在一起的，你可能要拖动一下才能看到后来的窗口）：</p>
<img src="/uploads/Windows-in-macOS/Open-Many.png" class="center" title="New Windows">
<h2 id="文档（Documents）">文档（Documents）</h2>
<p>在继续之前，我们要先来了解一下文档类型应用是怎么工作的。</p>
<h3 id="文档（Document）架构">文档（Document）架构</h3>
<p>一个文档对应的是一个 <code>NSDocument</code> 类型的对象，它相当于这个文档的控制器。通过它，我们可以读取文件的内容或往里面写东西，而且它既可以是本地硬盘上的文件，也可以是存在 iCloud 上的。</p>
<p>NSDocument 是一个抽象类，也就是说你需要用一个子类去实现具体功能。在文档架构中还有两个很主要的类：<code>NSWindowController</code> 和 <code>NSDocumentController</code>，它们作用分别是：</p>
<ul>
<li><code>NSDocument</code>：创建和保管文档数据</li>
<li><code>NSWindowController</code>：管理用来展示文档的窗口</li>
<li><code>NSDocumentController</code>：管理一个应用中的所有文档对象</li>
</ul>
<img src="/uploads/Windows-in-macOS/DocArchitecture.png" class="center" title="Document Architecture">
<h3 id="文档操作">文档操作</h3>
<p>还记得创建工程的时候，我们告诉了 Xcode 这个 App 是一个文档型应用吗？聪明的 Xcode 知道了这一点之后，会给我们的应用內建许多文档操作，但一些具体的逻辑还是需要我们继承 <code>NSDocument</code> 去实现。（Xcode 其实已经给了我们一个叫 <code>Document</code> 的子类作为例子了）</p>
<p>打开 <strong>Document.swift</strong>，可以看到已经有用于文件读写的空方法了（<code>data(ofType:)</code> 和 <code>read(from:ofType:)</code>）。运行这个 App 时，你可能已经发现顶部菜单栏里很多功能都是已经实现了的，比如新建、打开、保存等等，不过我们这个 Demo 里面不涉及“保存”，所以我们需要删除相关的逻辑，也借此看看 Xcode 帮我们做了些什么。</p>
<p>打开项目里唯一的 Storyboard，然后像下图这样取消菜单项和实际逻辑之间的关联：</p>
<img src="/uploads/Windows-in-macOS/TargetAction.png" class="center" title="Target-Action">
<p>把 <strong>Open</strong>、<strong>Save</strong>、<strong>Save As</strong>、<strong>Revert to Saved</strong> 的关联都干掉，因为这些我们都不会用到。</p>
<p>接下来打开 <strong>Document.swift</strong>，添加以下代码，我们要在用户尝试保存的时候弹一个提示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">save</span>(<span class="params">withDelegate</span> <span class="params">delegate</span>: <span class="keyword">Any</span><span class="operator">?</span>, <span class="params">didSave</span> <span class="params">didSaveSelector</span>: <span class="type">Selector</span>?, <span class="params">contextInfo</span>: <span class="type">UnsafeMutableRawPointer</span>?)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> userInfo <span class="operator">=</span> [<span class="type">NSLocalizedDescriptionKey</span>: <span class="string">&quot;Sorry, no saving for you, sir! Click <span class="subst">\&quot;</span>Don&#x27;t save<span class="subst">\&quot;</span> to quit.&quot;</span>]</span><br><span class="line">        <span class="keyword">let</span> error <span class="operator">=</span> <span class="type">NSError</span>(domain: <span class="type">NSOSStatusErrorDomain</span>, code: unimpErr, userInfo: userInfo)</span><br><span class="line">        <span class="type">NSAlert</span>(error: error).runModal()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<img src="/uploads/Windows-in-macOS/no-saving-for-you.jpg" class="center" title="No saving for you">
<p>现在重新运行项目，你会发现菜单栏里我们刚才取消关联的选项已经无法选中了：</p>
<img src="/uploads/Windows-in-macOS/menuDisabled.png" class="center" title="Menu Disabled">
<p>好了，清除掉了障碍，现在要开始真正的开工了！</p>
<h2 id="窗口位置">窗口位置</h2>
<p>首先我们要修复的一个问题是：新建的窗口都是死死盖在原来的窗口上面的。我们会通过继承一个窗口控制器来实现这部分逻辑。</p>
<h3 id="继承一个-NSWindowController">继承一个 <code>NSWindowController</code></h3>
<p>新建一个 <code>NSWindowController</code> 的子类，确保语言选了 Swift，并且不要勾选创建 xib 的那个选项：</p>
<img src="/uploads/Windows-in-macOS/WindowController.png" class="center" title="New WindowController">
<p>然后打开 Storyboard ，将里面的 Window Controller 的 Custom Class 配置为我们刚刚新建的 <code>WindowController</code>：</p>
<img src="/uploads/Windows-in-macOS/windowcontroller-class.png" class="center" title="Set Custom Class">
<p>然后开始解 Bug！在我们的 WindowController.swift 里面，重写父类的一个初始化方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">required</span> <span class="function"><span class="keyword">init?</span>(<span class="params">coder</span>: <span class="type">NSCoder</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">super</span>.<span class="keyword">init</span>(coder: coder)</span><br><span class="line">  shouldCascadeWindows <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行！</p>
<img src="/uploads/Windows-in-macOS/new-window.png" class="center" title="New Windows">
<p>除了第二个窗口不是很听话，后续的窗口都已经会排好队了。</p>
<h3 id="用-Tabs-绕过这个问题">用 Tabs 绕过这个问题</h3>
<p>这第二个窗口是怎么回事呢？我们后面将初始化窗口位置的时候再回答，现在我们先用另一种新建窗口的方式去绕过这个问题~（正式开发中千万不能绕开问题啊！）</p>
<p>其实将新建窗口变为新建 Tabs 超级简单，只需要在 Storyboard 里面配置一下就好了：</p>
<img src="/uploads/Windows-in-macOS/tabbing-mode-preferred.png" class="center" title="Tabbing Mode">
<p>重新运行，这次当你新建窗口时，这些窗口就会以一个个 Tab 的形式出现了：</p>
<img src="/uploads/Windows-in-macOS/raw-windows-with-tabs.png" class="center" title="New Windows in Tabbing Mode">
<h3 id="在-IB-中设置窗口的位置">在 IB 中设置窗口的位置</h3>
<p>回到我们绕过的问题本身：窗口的位置。</p>
<p>在 Storyboard 里，当 Window Controller 里的 Window 被选中时，可以在右侧的 Size Inspector 中看到对窗口位置和大小的配置，其中 “Initial Position” 里设置的就是窗口的初始化位置：</p>
<img src="/uploads/Windows-in-macOS/windowposition.png" class="center" title="Initial Position">
<blockquote>
<p>在 macOS 中，坐标轴的原点在左下角，横轴是 X 轴，纵轴是 Y 轴，跟 iPhone 上的坐标系要区别开来。</p>
</blockquote>
<p>你也可以直接拖动那个小界面里的灰色窗口来设置初始位置。注意小界面下面的两个下拉框的内容变化：</p>
<ul>
<li>Proportional Horizontal/Vertical：初始化位置会根据屏幕的大小按比例来设置</li>
<li>Fixed From Left/Right/Top/Bottom：写死一个固定的初始化位置</li>
</ul>
<p>在这个 Demo 里，我们会让窗口固定在左下角 (200,200) 的位置出现：</p>
<ul>
<li>设置下拉框内容为 Fixed From Left 和 Fixed From Bottom</li>
<li>将初始值设置为 X:200 和 Y:200</li>
</ul>
<blockquote>
<p>macOS 会记录每次应用启动后的窗口位置，所以为了看到这里的设置引起的变化，你要先把所有的窗口的关掉，再编译运行项目。</p>
</blockquote>
<h3 id="用代码设置窗口的位置">用代码设置窗口的位置</h3>
<p>这一小节其实就是把上一节做的事情用代码重新做一遍，以防你们以为 Swift 程序员不会写代码。</p>
<p>用代码设置还是有它的好处的，比如你可以在应用运行的过程中决定窗口要在哪里出现。</p>
<p>打开 <strong>WindowController.swift</strong>，把里面的 <code>windowDidLoad</code> 方法的实现改成下面这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">windowDidLoad</span>()</span> &#123;</span><br><span class="line">  <span class="keyword">super</span>.windowDidLoad()</span><br><span class="line">  <span class="comment">//1.</span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> window <span class="operator">=</span> window, <span class="keyword">let</span> screen <span class="operator">=</span> window.screen &#123;</span><br><span class="line">    <span class="keyword">let</span> offsetFromLeftOfScreen: <span class="type">CGFloat</span> <span class="operator">=</span> <span class="number">100</span></span><br><span class="line">    <span class="keyword">let</span> offsetFromTopOfScreen: <span class="type">CGFloat</span> <span class="operator">=</span> <span class="number">100</span></span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    <span class="keyword">let</span> screenRect <span class="operator">=</span> screen.visibleFrame</span><br><span class="line">    <span class="comment">//3.</span></span><br><span class="line">    <span class="keyword">let</span> newOriginY <span class="operator">=</span> screenRect.maxY <span class="operator">-</span> window.frame.height <span class="operator">-</span> offsetFromTopOfScreen</span><br><span class="line">    <span class="comment">//4.</span></span><br><span class="line">    window.setFrameOrigin(<span class="type">NSPoint</span>(x: offsetFromLeftOfScreen, y: newOriginY))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>取到窗口和屏幕对象（还记得 Swift 是怎么安全的获取 Optional 对象的值吗？就是这样~）</li>
<li>取得屏幕的可视范围</li>
<li>计算 Y 坐标的值（别忘了坐标轴原点是左下角，这里计算的是底边的高度）</li>
<li>更新窗口的坐标</li>
</ol>
<p><code>visibleFrame</code> 这个属性不包含 Dock 和菜单栏的范围，如果不用这个参数来计算的话，可能会出现窗口被这两个控件挡住的情况。</p>
<p>重新编译运行，窗口应该就会出现在距离屏幕（不算菜单栏高度）左上角 (100,100) 的位置了。</p>
<h2 id="打造一个迷你文字编辑器">打造一个迷你文字编辑器</h2>
<p>Cocoa 自带了一些很神奇的 UI 和功能，就等着你把它们用起来了。接下来我们会接触到多才多艺的 <code>NSTextView</code>，但首先我们要先了解一下 <code>NSWindow</code> 自带的 content view。</p>
<h3 id="The-Content-View">The Content View</h3>
<p><code>contentView</code> 是一个窗口中所有视图层级中的根视图，<code>NSWindow</code> 里的 content view 由它带着的 <code>ViewController</code> 来体现。</p>
<img src="/uploads/Windows-in-macOS/contentVIew.png" class="center" title="Content View">
<p>喏，那个蓝的发亮的就是 <code>contentView</code></p>
<h3 id="添加-Text-View">添加 Text View</h3>
<p>打开 <strong>Main.storyboard</strong>，从右边栏拖一个 <code>NSTextView</code> 到上面说到的 <code>contentView</code> 里面去，把它调节到一个舒服的大小，然后点击右下角的小三角形，选择 <strong>Reset to Suggested Constraints</strong>。</p>
<img src="/uploads/Windows-in-macOS/autolayout.png" class="center" title="AutoLayout">
<p>这里我们让系统自动帮我们布局这个视图，省点事儿。</p>
<p>编译运行，你应该能看到我们简陋的文字编辑器了。尝试拉伸一下窗口，Text View 会跟着窗口一起变大变小，这是 AutoLayout 的功劳，这个 Demo 里面不会讲咯。</p>
<img src="/uploads/Windows-in-macOS/mini_text_editor.png" class="center" title="Mini Text Editor">
<p>好好探索一下我们的第一个文字编辑器吧，你会发现 Format - Font - Show Font 功能并不可用，我们接下来就解决这个问题。</p>
<h3 id="打开字体设置框">打开字体设置框</h3>
<p>在 <strong>Main.storyboard</strong> 里的 Main Menu 上找到 Show Font 这个菜单项，按住 Ctrl 把 Show Font 拖到 First Responder 上，然后在随之出现的弹框中找到 <code>orderFrontFontPanel:</code> 并选择它：</p>
<img src="/uploads/Windows-in-macOS/font-to-first-responder.png" class="center" title="Show Fonts">
<p>然后重新编译运行项目，Show Font 功能就被打开啦！</p>
<p>在不写一行代码的前提下，你实现了改变字体的功能，这是怎么做到的呢？其实是 <code>NSFontManager</code> 和 <code>NSTextView</code> 把所有的脏活累活都给干掉了。</p>
<ul>
<li><code>NSFontManager</code> 是一个管理字体变化系统的类，它就是刚刚弹框中 <code>orderFrontFontPanel:</code> 方法的实际实现的地方，我们刚才的操作是把响应链上的信息发送（forward）给了它，然后它负责展示系统默认的字体设置框</li>
<li>当我们在字体设置框中对字体进行操作，<code>NSFontManager</code> 会发送一个 <code>changeFont</code> 消息给当前的第一响应对象（First Responder）</li>
<li><code>NSTextView</code> 实现了 <code>changeFont</code> 方法，当我们操作它里面的文字时（比如选中某个单词），它就自动成为了第一响应对象，然后一切就联系起来了</li>
</ul>
<h3 id="富文本">富文本</h3>
<p>要看到 <code>NSTextView</code> 的真正实力，你可以先从<a href="https://koenig-media.raywenderlich.com/uploads/2017/04/BabyScript.rtfd_.zip">这里</a>下载一段富文本，然后把它设置为 <code>NSTextView</code> 的默认文字，编译运行！</p>
<img src="/uploads/Windows-in-macOS/rich_text.png" class="center" title="RichText">
<p>嗯？文本里的图片哪里去了呢？</p>
<p>因为 IB 里面的设置默认文字的地方不能保存图片，所以图片就被丢弃掉了。不过我们还是可以通过复制粘贴或者拖拽的方式，把图片添加到 Text View 里面去。</p>
<p>玩耍过后，在你想要关闭这个窗口的时候，你会发现我们在文章开头设置的弹窗生效了！（我们在前面禁用了保存功能）</p>
<h3 id="把帅气的刻度尺显示出来">把帅气的刻度尺显示出来</h3>
<p>打开 <strong>ViewController.swift</strong>，把 <code>viewDidLoad</code> 附近的代码替换成下面这段：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@IBOutlet</span> <span class="keyword">var</span> text: <span class="type">NSTextView</span>!</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span>()</span> &#123;</span><br><span class="line">  <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">  text.toggleRuler(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后回到 <strong>Main.storyboard</strong>，把我们手写的 <code>text</code> 和 IB 里的 Text View 关联起来：按住 Ctrl，把代表 ViewController 的蓝色小圆圈拖向 Text View，选择 text。</p>
<img src="/uploads/Windows-in-macOS/connect_outlet.png" class="center" title="Connect Outlets">
<p>再跑一遍，看起来是不是高大上了一些：</p>
<img src="/uploads/Windows-in-macOS/RulerShowing.png" class="center" title="Show Ruler">
<h2 id="模态窗口">模态窗口</h2>
<p>模态窗口是 Window 世界中最霸道的存在，一旦出现，它会吃掉所有的事件，知道它们被主动 dismiss 掉。保存和打开文件的弹窗就是模态窗口的范例，总的来说，有三种方式展示模态窗口：</p>
<ol>
<li>当做一个常规窗口使用，通过调用 <code>NSApplication.runModal(for:)</code> 显示</li>
<li>当做一个表单（Sheet）用，通过调用 <code>NSWindow.beginSheet(_:completionHandler:)</code> 显示</li>
<li>通过一个模态会话来展示，这是一个高级用法，这里不讲</li>
</ol>
<p>前面尝试关闭窗口时弹出的保存提醒框就是一个表单型的模态窗口：</p>
<img src="/uploads/Windows-in-macOS/sheet-modal.png" class="center" title="Save Window">
<p>嘛，这玩意儿就这样，我们在这里也不会接着深入了。但是我们会看看一个分离式的模态窗口怎么出现的。</p>
<h3 id="添加一个新-Window">添加一个新 Window</h3>
<p>打开 <strong>Main.storyboard</strong>，从右边栏拖一个 Window Controller 到画面上，这会生成两个东西，一个 Window Controller Scene 和一个 View Controller Scene：</p>
<img src="/uploads/Windows-in-macOS/newwindowcontroller.png" class="center" title="New Window with IB">
<p>选中 Window Controller Scene 下面的 Window，把它的 Content Size 改为宽300高150，顺带也把 View Controller Scene 下面的 view 也做这样的修改：</p>
<img src="/uploads/Windows-in-macOS/wc-window-frame.png" class="center" title="Set Content Size">
<img src="/uploads/Windows-in-macOS/wc-view-frame.png" class="center" title="Set View Size">
<p>然后我们要禁用这个窗口左上角的那些控制按钮，让用户必须沿着我们设定的交互走：</p>
<img src="/uploads/Windows-in-macOS/wordcount-props.png" class="center" title="Window Controls">
<h3 id="新窗口里的界面布局">新窗口里的界面布局</h3>
<p>就像上文对 Text View 的布局那样，把我们的新窗口也进行一番鼓捣，留给大家自由发挥啦。Demo 里使用了4个 Label 和一个 Button，最终长这个样子：</p>
<img src="/uploads/Windows-in-macOS/word_count_ui.png" class="center" title="WordCountWindow UI">
<h3 id="创建对应的-View-Controller-类">创建对应的 View Controller 类</h3>
<p>为了控制这个窗口的内容，我们要从 <code>NSViewController</code> 继承一个子类：</p>
<img src="/uploads/Windows-in-macOS/new_word_count_vc.png" class="center" title="New WordCountViewController">
<p>接着在 IB 里关联一下界面和这个子类：</p>
<img src="/uploads/Windows-in-macOS/wc-configure-custom-class-368x320.png" class="center" title="Set Custom Class for WordCountViewController">
<h3 id="界面与数据绑定">界面与数据绑定</h3>
<p>接下来，我们用 macOS 上的一个神奇功能，实现界面与数据的直接绑定。</p>
<p>打开 <strong>WordCountViewController.swift</strong>，给这个类添加两个属性：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">dynamic</span> <span class="keyword">var</span> wordCount <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">dynamic</span> <span class="keyword">var</span> paragraphCount <span class="operator">=</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><code>dynamic</code> 关键字使得这两个属性可以被用作 <strong>Cocoa Bindings</strong> 的绑定对象。</p>
<p>回到我们的 <strong>Main.storyboard</strong>，选中上面添加的 “Word Count” 后面的那个 “0”，然后在右边栏进行设置，将这个 Text View 的内容跟 <code>wordCount</code> 属性的值进行绑定：</p>
<img src="/uploads/Windows-in-macOS/bind-wordcount.png" class="center" title="Cocoa Bindings">
<p>对 <strong>Paragraph Count</strong> 后面跟着的 Text View 也进行相同的操作，但是这次要绑定到 <code>paragrahCount</code> 属性上去。</p>
<blockquote>
<p><strong>Cocoa Bindings</strong> 是一个很有用的 UI 技巧，在文章<a href="https://www.raywenderlich.com/141297/cocoa-bindings-macos">《Cocoa Bindings on macOS》</a>中会有更详细的介绍。（如果有机会，这里也会尝试翻译一下这篇文章）</p>
</blockquote>
<p>最后，给我们的 WordCountViewController 所属的 Window 加上一个 Storyboard ID，方便我们后续在代码里面找到它：</p>
<img src="/uploads/Windows-in-macOS/WCControllerStoryboardId.png" class="center" title="Setting Storyboard ID">
<blockquote>
<p>这个 ID 是可以带有空格的，但是个人习惯不喜欢有空格，这张图是原文章里的。</p>
</blockquote>
<h2 id="模态窗口的显示与隐藏">模态窗口的显示与隐藏</h2>
<p>有了前面的准备工作，这个可以显示字数和段落数的窗口已经是可用的了。接下来我们就找个合适的地方把它显示出来。</p>
<h3 id="显示">显示</h3>
<p>打开 <strong>ViewController.swift</strong>，添加一个按钮事件：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">showWordCountWindow</span>(<span class="keyword">_</span> <span class="params">sender</span>: <span class="type">AnyObject</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">let</span> storyboard <span class="operator">=</span> <span class="type">NSStoryboard</span>(name: <span class="string">&quot;Main&quot;</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line">  <span class="keyword">let</span> wordCountWindowController <span class="operator">=</span> storyboard.instantiateController(withIdentifier: <span class="string">&quot;Word Count Window Controller&quot;</span>) <span class="keyword">as!</span> <span class="type">NSWindowController</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> wordCountWindow <span class="operator">=</span> wordCountWindowController.window, <span class="keyword">let</span> textStorage <span class="operator">=</span> text.textStorage &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">let</span> wordCountViewController <span class="operator">=</span> wordCountWindow.contentViewController <span class="keyword">as!</span> <span class="type">WordCountViewController</span></span><br><span class="line">    wordCountViewController.wordCount <span class="operator">=</span> textStorage.words.count</span><br><span class="line">    wordCountViewController.paragraphCount <span class="operator">=</span> textStorage.paragraphs.count</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">let</span> application <span class="operator">=</span> <span class="type">NSApplication</span>.shared()</span><br><span class="line">    application.runModal(for: wordCountWindow)</span><br><span class="line">    <span class="comment">// 4</span></span><br><span class="line">    wordCountWindow.close()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分解动作：</p>
<ol>
<li>通过刚刚设置的 Storyboard ID 初始化一个 WordCountWindowController（注意是 <strong>WindowController</strong>，不是我们自己创建的 <strong>ViewController</strong>）</li>
<li>从我们的内容里取得字数和段落数，设置到 <strong>WordCountViewController</strong> 的属性里</li>
<li>显示一个模态窗口</li>
<li>关闭一个模态窗口</li>
</ol>
<p>你可能会觉得奇怪，我们在显示之后立马就把它给关闭了，那还看什么？</p>
<p>事实上，当一个窗口以 <code>runModel(for:)</code> 的方式显示出来之后，应用会进入一个<strong>模态过程</strong>。这个动作相当于启动了一个阻塞的线程，启动方法调用之后的所有代码都会被阻塞住，只有在调用了 <code>stopModel</code> 停止 <strong>模态过程</strong> 后，代码才会继续执行。</p>
<h3 id="隐藏">隐藏</h3>
<p>关闭模态窗口的代码需要由模态窗口本身去调用，因为其他地方都被阻塞住了呀。在 <strong>WordCountViewController.swift</strong> 里加上这段代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">dismissWordCountWindow</span>(<span class="keyword">_</span> <span class="params">sender</span>: <span class="type">NSButton</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> application <span class="operator">=</span> <span class="type">NSApplication</span>.shared()</span><br><span class="line">  application.stopModal()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里只是让应用退出了 <strong>模态过程</strong>，真正关闭窗口的代码我们已经在上面写好了（就是 <code>close</code> 那个方法）</p>
<p>好咯，这个按钮事件怎么关联到那个 “OK” 按钮呢？留给你们自己去发现~</p>
<h3 id="触发窗口的显示">触发窗口的显示</h3>
<p>显示的代码写好了，但是在哪里地方调用它好呢？不如在菜单里加一个选项吧。</p>
<p>增加菜单项跟之前添加视图没有扫描区别，菜单项的名字叫 “Menu Item”，直接拖到菜单里面去就好了，然后在右边栏里进行一下设置：</p>
<img src="/uploads/Windows-in-macOS/add-word-count-window.png" class="center" title="Add Menu Item">
<blockquote>
<p>Key Equivalent 设置的是快捷键</p>
</blockquote>
<p>然后 Ctrl + 拖动，把这个菜单项跟我们写的方法联系起来：</p>
<img src="/uploads/Windows-in-macOS/connect-menu.png" class="center" title="Menu Action">
<p>完成了！编译运行！我们的统计功能就上线了！</p>
<h2 id="接下来呢？">接下来呢？</h2>
<p>不知不觉，你其实已经学到了蛮多东西了：</p>
<ul>
<li>MVC 设计模式的一点应用</li>
<li>创建一个多窗口 app</li>
<li>macOS app 的常见结构</li>
<li>通过 IB 和代码改变窗口的布局</li>
<li>将 UI 中的事件传递到响应链上</li>
<li>用模态窗口来展示附加信息</li>
<li>…</li>
</ul>
<p>不过这都只是 macOS app 的冰山一角。<br>
如果你对窗口感兴趣，可以看看苹果的官方文章 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/WinPanel/Introduction.html">Window Programming Guide</a>。如果想要继续深入研究 Mac 应用开发，则推荐 <a href="https://developer.apple.com/library/content/documentation/General/Conceptual/MOSXAppProgrammingGuide/Introduction/Introduction.html">Mac App Programming Guide</a>。</p>
<p>这个 Demo 完整的代码在<a href="https://koenig-media.raywenderlich.com/uploads/2017/05/BabyScriptWithSave.zip">这里</a>。这是原文里的链接，连保存的功能也实现好了，虽然没什么注释，但是代码很好懂。</p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"8225264e14e677544541","clientSecret":"ed2a2c6d5043e9f0b41cae78b0d5b4571099de53","repo":"HexoBlogSource","owner":"davidleee","admin":["davidleee"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>macOS</tag>
        <tag>Window</tag>
        <tag>Controller</tag>
        <tag>TextView</tag>
        <tag>Modal</tag>
        <tag>Document</tag>
        <tag>Menu</tag>
      </tags>
  </entry>
  <entry>
    <title>在 macOS 中如何使用 XPC 实现跨进程通讯？</title>
    <url>/2020/07/20/ipc-for-macOS/</url>
    <content><![CDATA[<p>最近需要在 Electron 项目上引入一个比较吃性能的大头功能，因为已经用 Objective-C 实现过一套稳定且性能也可接受的带 UI 方案了，所以计划看看能不能将这套现成的方案直接用到 Electron 里。但想要这么做就必须解决原生 UI 与 Electron 通讯的问题，再进一步，能不能让 Electron 以多进程的方式调起这个大头功能的 Demo 以节省掉绝大部分的重复工作呢？</p>
<blockquote>
<p>本文只研究了原生 XPC 通讯的部分，关于集成到 Electron 里还有哪些坑会在下一篇文章里讲讲</p>
</blockquote>
<span id="more"></span>
<h2 id="什么是-XPC">什么是 XPC</h2>
<blockquote>
<p>选型的过程不是这次要讨论的重点，就当作我们经过一番挣扎然后选择了原生的 XPC 实现吧：）</p>
</blockquote>
<p>XPC 是苹果官方提供的一种进程间通讯的手段，是一种苹果特有的 IPC 技术。</p>
<p>在 NSHipster 的<a href="https://nshipster.com/inter-process-communication/">一篇文章</a>里，作者说 XPC 是官方 SDK 内跨进程通讯的最优解决方案（2014）。从 2011 年被提出的时候，XPC 就持续在“体制内”发光发热，比如 macOS 的沙盒、iOS 的 Remote View Controller 和两个平台上都有的应用扩展（App Extensions）里都用到了 XPC 的技术。</p>
<p>对于开发者来说，使用 XPC 技术我们就能做到像这样的事情：</p>
<ol>
<li>模块 A 负责 UI 展示，它<strong>不需要申请任何系统权限</strong>，用到网络图片时就向模块 B 获取</li>
<li>模块 B 拥有<strong>网络权限</strong>，能从网络或缓存中获取图片，但操作文件系统的工作由模块 C 负责</li>
<li>模块 C 拥有<strong>文件读写权限</strong>，负责将数据写成文件或读取文件数据</li>
<li>这三个模块都在同一个应用中，它们所需要的权限相互独立，功能单一，而且即使崩溃了也不会相互影响，只需要重启相应的模块就又可以恢复正常使用</li>
</ol>
<p>看完是不是已经迫不及待了呢？别着急，在使用这个强大工具前，我们还需要了解两个关键技术。</p>
<h3 id="题外话1-launchd">题外话1 - launchd</h3>
<p><code>launchd</code> 负责管理 macOS 上的守护进程，在构建 XPC 方案的过程中，我们会用它来配置一个我们自己的守护进程。</p>
<p>这个守护进程会一直潜伏在系统里（只占用非常少的资源），当我们的应用需要它的时候就可以被随时唤醒。</p>
<p>更多 <code>launchd</code> 的信息和用法可以在它的<a href="x-man-page://5/launchd.plist">man 页面</a>找到。</p>
<h3 id="题外话2-SMJobBless">题外话2 - SMJobBless</h3>
<p>字面意思是“给任务加上祝福”，任何应用都不能跟一个没有被系统祝福的任务愉快地玩耍。</p>
<p>这是一组协助开发者安全地安装守护进程的 API，长这个样子：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">Boolean SMJobBless(<span class="built_in">CFStringRef</span> domain, <span class="built_in">CFStringRef</span> executableLabel, AuthorizationRef auth, <span class="built_in">CFErrorRef</span> *outError);</span><br></pre></td></tr></table></figure>
<p>苹果似乎也认为这组 API 的用法只可意会不可言传，所以在<a href="https://developer.apple.com/documentation/servicemanagement/1431078-smjobbless?language=objc">SMJobBless 的方法说明</a>里写了很多，还给出了一个很完整的<a href="http://developer.apple.com/library/mac/#samplecode/SMJobBless/">示例工程</a>并通过一个 <a href="https://developer.apple.com/library/archive/samplecode/SMJobBless/Listings/SMJobBlessUtil_py.html#//apple_ref/doc/uid/DTS40010071-SMJobBlessUtil_py-DontLinkElementID_8">Python 脚本</a>把安装守护进程的前置条件给配置好了。</p>
<blockquote>
<p>脚本这个动作，虽然让整个流程变得更加完善，但却将原本只要几句命令就能解决的事情复杂化了，少了一些苹果味。</p>
</blockquote>
<h2 id="架起通讯的桥梁">架起通讯的桥梁</h2>
<p>写了这么多，其实都还在 <strong>Prerequisites</strong> 阶段打转转。接下来才要正式开始跨应用通讯的实现！</p>
<p>不过在此之前，我们还是先把上文题外话里提到的前置条件准备好，让后面的过程更顺畅一些。</p>
<h3 id="前置准备">前置准备</h3>
<p>通过 <code>launchd</code> 安装守护进程是个需要很高安全性的动作，所以应用签名是必不可少的。而对于一个跨应用通讯的系统来说，安全性主要涉及到两个部分：</p>
<ul>
<li>通讯发起方</li>
<li>XPC 应用</li>
</ul>
<blockquote>
<p>在这篇文章中，通讯的接收方不负责 XPC 应用的安装，所以它只要管好自己的签名就够了</p>
</blockquote>
<p>这里我们就要用上前面提到的 Python 脚本里的一句关键命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">codesign -d -r - /path/to/file.app</span><br></pre></td></tr></table></figure>
<blockquote>
<p>虽然官方 Demo 里的这个脚本还做了许多其他的检验来确保信息的完整和正确，但对于我们这样成熟的（嘿嘿）开发者来说，当然要直接薅最珍贵的羊毛啦。</p>
</blockquote>
<p>把这个命令的路径参数改为我们已经签好名的应用，会得到像这样子的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Executable=/path/to/file.app</span><br><span class="line">designated =&gt; anchor apple generic and identifier &quot;com.example.apple-samplecode.EBAS.App&quot; and (certificate leaf[field.1.2.840.113635.100.6.1.9] /* exists */ or certificate 1[field.1.2.840.113635.100.6.2.6] /* exists */ and certificate leaf[field.1.2.840.113635.100.6.1.13] /* exists */ and certificate leaf[subject.OU] = SKMME9E2Y8)</span><br></pre></td></tr></table></figure>
<p>其中，<code>designated =&gt;</code> 后面的部分（例子里是从 “anchor” 开始，我们自己签名的话开头可能是“identifier”，这个顺序并不要紧）就是我们需要的“签名需求”（Code Signing Requirement）。</p>
<p>把签名需求放到我们自己的 XPC 应用的 Info.plist 里，如此一来这个 XPC 应用就只能被拥有这个签名的应用启动了：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>SMAuthorizedClients<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>anchor apple generic and identifier &quot;com.example.apple-samplecode.EBAS.App&quot; and (certificate leaf[field.1.2.840.113635.100.6.1.9] /* exists */ or certificate 1[field.1.2.840.113635.100.6.2.6] /* exists */ and certificate leaf[field.1.2.840.113635.100.6.1.13] /* exists */ and certificate leaf[subject.OU] = SKMME9E2Y8)<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里的 value 是数组格式的，意味着如果想允许多个 App 启动这个 XPC 应用的话，就需要把这些 App 的签名需求都写上。</p>
<p>同理，还要取到 XPC 应用的签名需求并配到我们客户端的 Info.plist 里：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>SMPrivilegedExecutables<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>com.example.apple-samplecode.EBAS.HelperTool<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>anchor apple generic and identifier &quot;com.example.apple-samplecode.EBAS.HelperTool&quot; and (certificate leaf[field.1.2.840.113635.100.6.1.9] /* exists */ or certificate 1[field.1.2.840.113635.100.6.2.6] /* exists */ and certificate leaf[field.1.2.840.113635.100.6.1.13] /* exists */ and certificate leaf[subject.OU] = SKMME9E2Y8)<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意这个 “dict” 里的 “key” 要填的是我们的 XPC 应用的 label，不过因为 label 通常会定成跟 Bundle Identifier 一致，所以写上它的 Bundle Identifier 也就可以了。</p>
<blockquote>
<p>上一段啰嗦了一下是因为 label 其实可以跟 Bundle Identifier 不同的，但这会给开发的过程带来许多麻烦，所以建议还是统一。这个 label 具体是什么鬼会在下一个小节里讲到。</p>
</blockquote>
<h3 id="创建-安装-XPC-应用">创建 &amp; 安装 XPC 应用</h3>
<p>首先来添加一个 Target 并选择 XPC Service，让 Xcode 帮我们生成一些默认代码：<br>
<img src="/uploads/ipc-for-macOS/create_target.png" alt=""></p>
<p>然后为我们的 XPC 应用再创建一个 plist，这个文件会在 XPC 应用被安装的时候自动拷贝到 <em>/Library/LaunchDaemons</em> 目录下，这是统一存放守护进程配置文件的地方。</p>
<p>为了与默认的 Info.plist 区分开来，在文件的名字里加上个 “Launchd”，文件内容是这样的：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">plist</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//Apple//DTD PLIST 1.0//EN&quot;</span> <span class="meta-string">&quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plist</span> <span class="attr">version</span>=<span class="string">&quot;1.0&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>Label<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">string</span>&gt;</span>com.example.apple-samplecode.EBAS.HelperTool<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>MachServices<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">key</span>&gt;</span>com.example.apple-samplecode.EBAS.HelperTool<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plist</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>看，前面埋的坑—— <strong>Label</strong> 出现了！这是系统用来唯一标识守护进程的值，下面 MachServices 中的 key 是我们 XPC 应用的 Bundle Identifier。在建立连接的时候，系统就会根据这张配置表去寻找正确的 XPC 应用。</p>
<p>完成后我们的目录结构是这样的：（例子来自官方的 <a href="https://developer.apple.com/library/archive/samplecode/EvenBetterAuthorizationSample/Introduction/Intro.html#//apple_ref/doc/uid/DTS40013768-Intro-DontLinkElementID_2">EvenBetterAuthorizationSample</a>）<br>
<img src="/uploads/ipc-for-macOS/9B514455-AC1D-454F-8681-34076024982E.png" alt=""></p>
<blockquote>
<p>如图，官方例子中还给 plist 加上了项目名前缀，但名字不重要，重要的是别忘了把签名需求写对。</p>
</blockquote>
<p>最后，因为我们要用到的产物是 .xpc 包里的二进制文件，所以必须把这两个 plist 也打进二进制文件里去，这就要在 Build Settings 的 Other Linker Flags 里配置一下：<br>
<img src="/uploads/ipc-for-macOS/29AEBF92-9331-41E1-8EAB-04718FEFDB6C.png" alt=""></p>
<p>配置内容如下，把最后的路径改成自己的 plist 就可以了（这也是为什么前面说文件名不重要）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-sectcreate __TEXT __info_plist HelperTool/HelperTool-Info.plist</span><br><span class="line">-sectcreate __TEXT __launchd_plist HelperTool/HelperTool-Launchd.plist</span><br></pre></td></tr></table></figure>
<p>完成了这些配置后打出来的包会是一个完整的 .xpc 文件了，但我们需要的只是它里面的二进制文件。在用上它之前，让我们把安装 XPC 应用的代码写好，这里的代码是在官方例子的基础上改的，个人感觉比例子里的更易懂一些：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">AuthorizationItem authItem = &#123; kSMRightBlessPrivilegedHelper, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span> &#125;;</span><br><span class="line">AuthorizationRights authRights = &#123; <span class="number">1</span>, &amp;authItem &#125;;</span><br><span class="line">AuthorizationFlags flags = kAuthorizationFlagDefaults | kAuthorizationFlagInteractionAllowed | kAuthorizationFlagPreAuthorize | kAuthorizationFlagExtendRights;</span><br><span class="line"></span><br><span class="line">AuthorizationRef authRef = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">OSStatus status = AuthorizationCreate(&amp;authRights, kAuthorizationEmptyEnvironment, flags, &amp;authRef);</span><br><span class="line"><span class="keyword">if</span> (status != errAuthorizationSuccess) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Failed to create AuthorizationRef, return code %i&quot;</span>, status);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">CFErrorRef</span> error;</span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="built_in">BOOL</span> success = SMJobBless(kSMDomainSystemLaunchd, (__bridge <span class="built_in">CFStringRef</span>)<span class="string">@&quot;com.example.apple-samplecode.EBAS.HelperTool&quot;</span>, authRef, &amp;error);</span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;job bless success&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;job bless error: %@&quot;</span>, (__bridge <span class="built_in">NSError</span> *)error);</span><br><span class="line">        <span class="built_in">CFRelease</span>(error);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>构造申请权限所需要的参数，官方例子中没有这一步</li>
<li>申请权限，如果这一步失败了，那我们的应用就不能做任何需要用户授权的操作了；官方例子中因为少了构造参数的步骤，所以这里会变成 <code>AuthorizationCreate(NULL, NULL, 0, &amp;authRef)</code></li>
<li>使用题外话里讲到的 API 来安装我们的 XPC 应用，其中，<code>kSMDomainSystemLaunchd</code> 表示我们要使用 launchd 服务（这也是目前仅有的可选项），第二个参数是我们之前设置的 XPC 应用的 label</li>
</ol>
<p>当执行到上面的逻辑时，我们从两个角度来看看会发生什么：</p>
<ul>
<li>用户角度：界面上弹出一个授权框，提示用户输入解锁密码</li>
<li>系统角度：系统会进入申请授权的应用内部寻找这个待安装的 XPC 应用二进制包，如果找到了会将它 <em>存起来</em> 以便下一次可以直接唤起，并把其中的 launchd 配置拷贝的统一的位置</li>
</ul>
<blockquote>
<p>通过 SMJobBless 安装的 XPC 应用会存在 /Library/PrivilegedHelperTools 下面，一旦授权完成过一次，后续只要配置文件和这里的二进制文件还对得上就不会再弹授权框了</p>
</blockquote>
<p>为了让系统方便地找到 XPC 应用，要把它的<strong>二进制文件</strong>放到应用的 /Contents/Library/LaunchServices 路径下，我们可以在客户端的 Build Phases 里面加一个步骤来做这件事：<br>
<img src="/uploads/ipc-for-macOS/03FE8C66-DDBB-4A23-9D0B-5C0FE1535F30.png" alt=""></p>
<blockquote>
<p>千万记得这里要放的是 .xpc 包里的二进制文件，在 xxx.xpc/Contents/MacOS 目录下</p>
</blockquote>
<p>OK，万事具备，接下来我们真的要写代码了。</p>
<h3 id="与-XPC-应用通讯">与 XPC 应用通讯</h3>
<p>首先我们来实现 XPC 应用的连接监听逻辑，在创建 Target 之后的 .m 文件里已经有连接处理的模版和丰富的注释了：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.listener = [[<span class="built_in">NSXPCListener</span> alloc] initWithMachServiceName:<span class="string">@&quot;这里改成上面设置的 Label&quot;</span>];</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)listener:(<span class="built_in">NSXPCListener</span> *)listener shouldAcceptNewConnection:(<span class="built_in">NSXPCConnection</span> *)newConnection &#123;</span><br><span class="line">    <span class="comment">// This method is where the NSXPCListener configures, accepts, and resumes a new incoming NSXPCConnection.</span></span><br><span class="line">    assert(listener == <span class="keyword">self</span>.listener);</span><br><span class="line">    assert(newConnection != <span class="literal">nil</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Configure the connection.</span></span><br><span class="line">    <span class="comment">// First, set the interface that the exported object implements.</span></span><br><span class="line">    newConnection.exportedInterface = [<span class="built_in">NSXPCInterface</span> interfaceWithProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">HelperToolProtocol</span>)];</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Next, set the object that the connection exports. All messages sent on the connection to this service will be sent to the exported object to handle. The connection retains the exported object.</span></span><br><span class="line">    newConnection.exportedObject = <span class="keyword">self</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Resuming the connection allows the system to deliver more incoming messages.</span></span><br><span class="line">    [newConnection resume];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Returning YES from this method tells the system that you have accepted this connection. If you want to reject the connection for some reason, call -invalidate on the connection and return NO.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要特别说明的一点是，XPC 连接建立起来之后，连接发起方就能获取到上面的逻辑里的 <code>exportedObject</code>，而再上一行的 <code>exportedInterface</code> 是声明这个对象在这次 XPC 通讯中会遵循的协议。</p>
<p>换句话说，连接的发起方会把连接上的 XPC 应用直接当作一个对象来操作。这个对象的消息传递是异步的，所以在调用的时候要小心避免卡主线程。</p>
<blockquote>
<p>因为协议需要连接双方自行约定统一，所以上面 <code>HelperToolProtocol</code> 的定义建议放到一个公共的文件里，让我们的应用项目和 XPC 应用项目都能访问到</p>
</blockquote>
<p>XPC 应用这边先说这么多，大多数情况下模版代码就够了，只需要自己定义一下 <code>exportedInterface</code> 就能实现例如心跳机制这样的功能。</p>
<p>接下来实现客户端发起连接的逻辑，我们直接参考官方例子里的代码：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)connectToHelperTool</span><br><span class="line">    <span class="comment">// Ensures that we&#x27;re connected to our helper tool.</span></span><br><span class="line">&#123;</span><br><span class="line">    assert([<span class="built_in">NSThread</span> isMainThread]);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.helperToolConnection == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">self</span>.helperToolConnection = [[<span class="built_in">NSXPCConnection</span> alloc] initWithMachServiceName:kHelperToolMachServiceName options:<span class="built_in">NSXPCConnectionPrivileged</span>];</span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">self</span>.helperToolConnection.remoteObjectInterface = [<span class="built_in">NSXPCInterface</span> interfaceWithProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">HelperToolProtocol</span>)];</span></span><br><span class="line">        <span class="comment">// 3</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic push</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">&quot;-Warc-retain-cycles&quot;</span></span></span><br><span class="line">        <span class="comment">// We can ignore the retain cycle warning because a) the retain taken by the</span></span><br><span class="line">        <span class="comment">// invalidation handler block is released by us setting it to nil when the block </span></span><br><span class="line">        <span class="comment">// actually runs, and b) the retain taken by the block passed to -addOperationWithBlock: </span></span><br><span class="line">        <span class="comment">// will be released when that operation completes and the operation itself is deallocated </span></span><br><span class="line">        <span class="comment">// (notably self does not have a reference to the NSBlockOperation).</span></span><br><span class="line">        <span class="keyword">self</span>.helperToolConnection.invalidationHandler = ^&#123;</span><br><span class="line">            <span class="comment">// If the connection gets invalidated then, on the main thread, nil out our</span></span><br><span class="line">            <span class="comment">// reference to it.  This ensures that we attempt to rebuild it the next time around.</span></span><br><span class="line">            <span class="keyword">self</span>.helperToolConnection.invalidationHandler = <span class="literal">nil</span>;</span><br><span class="line">            [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">                <span class="keyword">self</span>.helperToolConnection = <span class="literal">nil</span>;</span><br><span class="line">                [<span class="keyword">self</span> logText:<span class="string">@&quot;connection invalidated\n&quot;</span>];</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic pop</span></span><br><span class="line">        <span class="comment">// 4</span></span><br><span class="line">        [<span class="keyword">self</span>.helperToolConnection resume];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>通过 label 找到特定 XPC 应用并建立连接，建议把这个连接实例保存起来，避免重复创建带来别的问题</li>
<li>这一步参数里的协议就是我们在 XPC 应用中声明的协议，两边的协议要对得上才能拿到 XPC 应用中暴露出来的正确对象</li>
<li>大段注释是在解释为什么这里不需要担心循环引用的问题；要注意的是如果我们把连接实例存了起来，最好是像这样在 <code>invalidationHandler</code> 里置空，在其他地方通过 <code>[connection invalidate]</code>来实现断连</li>
<li>手动调用 <code>resume</code> 来建立连接，调用后 XPC 应用那边才会收到 <code>-[listener:shouldAcceptNewConnection:]</code> 回调</li>
</ol>
<p>Done！如果前面的一系列配置都正确的话，这个方法就能搭起客户端与 XPC 应用之间连接桥梁了！</p>
<h3 id="与其他进程通讯">与其他进程通讯</h3>
<p>除了与 XPC 应用建立连接之外，NSXPCConnection 还提供了另一组 API 用于直接跟其他客户端建立连接：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithListenerEndpoint:(<span class="built_in">NSXPCListenerEndpoint</span> *)endpoint;</span><br></pre></td></tr></table></figure>
<p>一次完整的连接建立流程是这样的：</p>
<ol>
<li>客户端 A 与 XPC 应用建立连接</li>
<li>客户端 A 生成一个 NSXPCListenerEndpoint 并存放到 XPC 应用里</li>
<li>客户端 B 与 XPC 应用建立连接并取到这个 NSXPCListenerEndpoint</li>
<li>客户端 B 通过 NSXPCListenerEndpoint 与客户端 A 建立连接</li>
</ol>
<p>在上个小节中我们完成了第一步，而第四步跟第一步其实挺像的，所以第二三步就是我们现在要处理的了。</p>
<p>之前我们声明了一个空的 <code>HelperToolProtocol</code>，现在就给它加一些内容，向外界提供对象读写的能力：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">HelperToolProtocol</span></span></span><br><span class="line">- (<span class="keyword">void</span>)setEndpoint:(<span class="built_in">NSXPCListenerEndpoint</span> *)endpoint withReply:(<span class="keyword">void</span> (^)(<span class="built_in">BOOL</span>))reply;</span><br><span class="line">- (<span class="keyword">void</span>)getEndpointWithReply:(<span class="keyword">void</span> (^)(<span class="built_in">NSXPCListenerEndpoint</span> *))reply;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为 <code>exportedObject</code> 的消息传递是异步的，所以在需要返回值的时候要改用回调的方式实现。</p>
</blockquote>
<p>然后在 XPC 应用里声明一个成员变量并实现上面的两个方法就完成了：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSXPCListenerEndpoint</span> *endpoint;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setEndpoint:(<span class="built_in">NSXPCListenerEndpoint</span> *)endpoint withReply:(<span class="keyword">void</span> (^)(<span class="built_in">BOOL</span>))reply &#123;</span><br><span class="line">    <span class="keyword">self</span>.endpoint = endpoint;</span><br><span class="line">    reply(<span class="literal">YES</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)getEndpointWithReply:(<span class="keyword">void</span> (^)(<span class="built_in">NSXPCListenerEndpoint</span> *))reply &#123;</span><br><span class="line">    reply(<span class="keyword">self</span>.endpoint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来回到客户端的代码里（现在还没实现客户端 B，所以这里讲的都是客户端 A）：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">[<span class="keyword">self</span> connectToHelperTool];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">self</span>.listener = [<span class="built_in">NSXPCListener</span> anonymousListener];</span><br><span class="line"><span class="keyword">self</span>.listener.delegate = <span class="keyword">self</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">id</span>&lt;HelperToolProtocol&gt; service = [<span class="keyword">self</span>.connection remoteObjectProxyWithErrorHandler:^(<span class="built_in">NSError</span> * _Nonnull error) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;get remote object proxy error: %@&quot;</span>, error);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line">[service setEndpoint:<span class="keyword">self</span>.listener.endpoint withReply:^(<span class="built_in">BOOL</span> result) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;set endpoint result: %@&quot;</span>, result ? <span class="string">@&quot;success&quot;</span> : <span class="string">@&quot;failed&quot;</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<ol>
<li>先 XPC 应用建立连接</li>
<li>准备一个监听器来处理其他客户端的连接</li>
<li>获取到 XPC 应用的 <code>exportedObject</code>，因为方法返回的是实现了这个协议的对象，所以协议的匹配很关键</li>
<li>调用协议中的方法把匿名监听器的端点设置过去，因为我们在 XPC 应用里写死了返回 <code>YES</code>，所以这里肯定会成功，实际使用的过程中可能要加上安全性的处理</li>
</ol>
<p>监听器有了，就差监听到连接后的回调了：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)listener:(<span class="built_in">NSXPCListener</span> *)listener shouldAcceptNewConnection:(<span class="built_in">NSXPCConnection</span> *)newConnection &#123;</span><br><span class="line">    assert(listener == <span class="keyword">self</span>.listener);</span><br><span class="line">    assert(newConnection != <span class="literal">nil</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">self</span>.clientConnection.invalidationHandler = ^&#123;</span><br><span class="line">        weakSelf.clientConnection.invalidationHandler = <span class="literal">nil</span>;</span><br><span class="line">        [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">            weakSelf.clientConnection = <span class="literal">nil</span>;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">self</span>.clientConnection.remoteObjectInterface = [<span class="built_in">NSXPCInterface</span> interfaceWithProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">ClientBProtocol</span>)];</span></span><br><span class="line">    <span class="keyword">self</span>.clientConnection.exportedInterface = [<span class="built_in">NSXPCInterface</span> interfaceWithProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">ClientAProtocol</span>)];</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.clientConnection.exportedObject = <span class="keyword">self</span>;</span><br><span class="line">    [<span class="keyword">self</span>.clientConnection resume];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>这个熟悉的回调方法其实跟 XPC 应用里的那个一样，客户端 A 已经具备了一个 XPC 应用的基本功能了</li>
<li>官方例子的另一种写法，逻辑上是一样的（可能这种还亲切一些呢😬）</li>
<li>除了 <code>exportedInterface</code> 之外，还要设置 <code>remoteObjectInterface</code>，因为这是一条双向通讯的连接，所以要让其他客户端知道我们期望它们能遵循什么协议</li>
</ol>
<p>好的，流程走完一半了，第三四步需要在客户端 B 里面实现：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">[<span class="keyword">self</span> connectToHelperTool];</span><br><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">[[<span class="keyword">self</span>.connection remoteObjectProxyWithErrorHandler:<span class="literal">nil</span>] getEndpointWithReply:^(<span class="built_in">NSXPCListenerEndpoint</span> *endpoint) &#123;</span><br><span class="line">    [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">        <span class="keyword">if</span> (endpoint) &#123;</span><br><span class="line">            [weakSelf connectWithEndpoint:endpoint];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;]</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)connectWithEndpoint:(<span class="built_in">NSXPCListenerEndpoint</span> *)endpoint &#123;</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">self</span>.serverConnection = [[<span class="built_in">NSXPCConnection</span> alloc] initWithListenerEndpoint:endpoint];</span><br><span class="line">    <span class="keyword">self</span>.serverConnection.remoteObjectInterface = [<span class="built_in">NSXPCInterface</span> interfaceWithProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">ServerCommunicationProtocol</span>)];</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">self</span>.serverConnection.exportedInterface = [<span class="built_in">NSXPCInterface</span> interfaceWithProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">ClientCommunicationProtocol</span>)];</span></span><br><span class="line">    <span class="keyword">self</span>.serverConnection.exportedObject = <span class="keyword">self</span>;</span><br><span class="line">    </span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">self</span>.serverConnection.invalidationHandler = ^&#123;</span><br><span class="line">        weakSelf.serverConnection.invalidationHandler = <span class="literal">nil</span>;</span><br><span class="line">        [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">            weakSelf.serverConnection = <span class="literal">nil</span>;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span>.serverConnection resume];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4</span></span><br><span class="line">    <span class="comment">// self.serverConnectionEndpoint = endpoint;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>客户端 B 从 XPC 应用中拿到客户端 A 设置的端点，这跟设置端点的代码差不多</li>
<li>通过端点来构造 <code>NSXPCConnection</code>，这样在调用 <code>resume</code> 之后对方会收到 <code>-[listener:shouldAcceptNewConnection:]</code> 的回调</li>
<li>与上文的回调处理类似，因为我们要做的是双向通讯，所以客户端 B 在发起连接时也要把 <code>exportedInterface</code> 和 <code>exportedObject</code> 设置好，之后的代码就跟其他地方看到的差不多了</li>
<li>有必要的话可以把这个端点存起来用于一些判断或重连的逻辑</li>
</ol>
<h2 id="常见错误">常见错误</h2>
<blockquote>
<p>这一段总结了我在实现过程中踩的坑，也许我们的情况不太一样，但希望能给大家一个排查的思路</p>
</blockquote>
<p>涉及到多端通讯的逻辑调试起来比较绕，错误通常会发生在以下两个部分：</p>
<ol>
<li>客户端部分：确认代码逻辑没漏的话，可以把各种 <code>handler</code> 的结果都打印一下，一般都会带有比较明确的错误域和错误码</li>
<li>连接部分：这类错误信息不会出现在客户端日志里，也分两类
<ol>
<li>没有任何反应但就是连不上：可以用自带的控制台工具去捞日志</li>
<li>调用 API 导致崩溃：也是控制台捞，macOS 的系统崩溃上报弹窗里可能会有更多信息</li>
</ol>
</li>
</ol>
<p>下面是我碰过的一些错误和处理方式：</p>
<h3 id="CFErrorDomainLaunchd-Code-2">CFErrorDomainLaunchd Code=2</h3>
<p>安装 XPC 应用时在客户端内找不到 XPC 应用的二进制文件，检查一下二进制包是不是放到了正确的路径下，格式是否正确（记得要取 .xpc 后缀的文件里的二进制文件）。</p>
<h3 id="CFErrorDomainLaunchd-Code-4-or-8">CFErrorDomainLaunchd Code=4 or 8</h3>
<p>签名匹配不上。大概率是 Info.plist 里配置的签名需求不正确，回头看看 <em>前置准备</em> 那个小节，检查内容是否跟 <code>codesign -d -r - /path/to/app</code>  和 <code>codesign -d -r - /path/to/xpc</code>  的一致。</p>
<h3 id="Error-Domain-NSCocoaErrorDomain-Code-4097">Error Domain=NSCocoaErrorDomain Code=4097</h3>
<blockquote>
<p>出自 FoundationErrors.h - NSXPCConnectionInterrupted</p>
</blockquote>
<p>连接被打断（interrupted），约等于 connection.interruptionHandler 被触发了。<br>
如果发生在连接建立的过程中，那意味着它发现连接已经被占用了，多见于调试过程中重启了其中一端，但是另一端没有把连接释放掉。</p>
<p>在正常运行的过程中发生的话，可能是系统 XPC 服务发现我们的连接长时间没有使用而挂起了它，这种情况一般不需要处理，系统会在我们下次使用这条连接的时候自动帮我们处理好。</p>
<h3 id="Error-Domain-NSCocoaErrorDomain-Code-4099">Error Domain=NSCocoaErrorDomain Code=4099</h3>
<blockquote>
<p>出自 FoundationErrors.h - NSXPCConnectionInvalid</p>
</blockquote>
<p>同样分两种情况，一连接就出事的话，可能是 XPC 应用没有安装成功，排查方式是看 plist 和二进制文件有没有出现在它们该出现的路径里。<br>
另一种情况，可能是客户端因为沙盒的原因而无法建立这条连接，控制台日志里会看到类似 <em>deny mach-lookup</em> 的信息，可以选择把 App Sandbox 关上（会没法上 Mac App Store 但不影响其他渠道的分发），真要打开沙盒的话有两条可以尝试的路径：</p>
<ol>
<li>想办法搞定 entitlements 的配置，可以参考<a href="https://christiantietze.de/posts/2015/01/xpc-helper-sandboxing-mac/">这篇文章</a></li>
<li>应用内置另一个不在沙盒内的 XPC 应用，通过它去跟安装到系统里的 XPC 应用建立连接，具体的方式在官方的 <a href="https://developer.apple.com/library/archive/samplecode/EvenBetterAuthorizationSample/Introduction/Intro.html#//apple_ref/doc/uid/DTS40013768-Intro-DontLinkElementID_2">EvenBetterAuthorizationSample</a>中有实现</li>
</ol>
<h2 id="总结">总结</h2>
<p>XPC 是 macOS 跨应用通讯中不得不面对的一种方案，可能出于各种原因最终的选择并不是它，但它确实是目前最简单可靠的实现了。</p>
<p>尽管我在网上已经查了非常多的资料，也还是在动手的过程中频频踩坑。写下这篇长文也是希望能把这条路尽可能填平，只是这个文章长度就有些一发不可收拾了😅。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="http://www.tanhao.me/pieces/1623.html/">通过ServiceManagement注册LaunchdDaemon | 老谭笔记</a></li>
<li><a href="https://nshipster.com/inter-process-communication/">Inter-Process Communication - NSHipster</a></li>
<li><a href="https://developer.apple.com/library/archive/samplecode/EvenBetterAuthorizationSample/Listings/Read_Me_About_EvenBetterAuthorizationSample_txt.html#//apple_ref/doc/uid/DTS40013768-Read_Me_About_EvenBetterAuthorizationSample_txt-DontLinkElementID_17">Read Me About EvenBetterAuthorizationSample.txt</a></li>
<li><a href="http://www.objc.io/issue-14/xpc.html">XPC · objc.io</a></li>
<li><a href="https://rderik.com/blog/creating-a-launch-agent-that-provides-an-xpc-service-on-macos/">Creating a Launch Agent that provides an XPC service on macOS using Swift</a></li>
<li><a href="https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingLaunchdJobs.html#//apple_ref/doc/uid/10000172i-SW7-BCIEDDBJ">Creating Launch Daemons and Agents</a></li>
</ul>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"8225264e14e677544541","clientSecret":"ed2a2c6d5043e9f0b41cae78b0d5b4571099de53","repo":"HexoBlogSource","owner":"davidleee","admin":["davidleee"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>macOS</tag>
        <tag>XPC</tag>
        <tag>launchd</tag>
        <tag>SMJobBless</tag>
      </tags>
  </entry>
  <entry>
    <title>SwiftUI 系列教程（4）—— UIKit 老相好在 SwiftUI 下的实现</title>
    <url>/2019/08/15/swiftui-serial-tutorial-4/</url>
    <content><![CDATA[<p>咱们最有意思的第四篇 SwiftUI 教程来啦！为什么说是“最有意思”的呢？因为按照约定，在这篇文章里我们会一起来看看用 SwiftUI 开发界面的快捷便利体现在什么地方。相信这会让许多苹果开发者们耳目一新。</p>
<blockquote>
<p>信了苹果教之后，每次有什么更新，我最期待的都是隐藏在大功能下的小细节，不知道有多少人跟我一样？</p>
</blockquote>
<span id="more"></span>
<h2 id="UITableView-UITableViewCell">UITableView &amp; UITableViewCell</h2>
<p>首先要说的是 UI 中最常见的列表：在萌新们刚开始学习 iOS 开发的时候，列表的实现也许就是其中一个劝退点。虽然 UIKit 的 API 已经做了比较友好的封装，但在这个前提下，开发者还必须要了解 UITableViewDelegate、UITableViewDataSource、Cell 与列表的关系，如果想要构造一个高性能的列表，还需要了解 Cell 的重用等等等等。</p>
<p>那么在 SwiftUI 里构造一个列表的操作是怎样的呢？我们分三步走：</p>
<ol>
<li>单个列表项的布局</li>
<li>准备数据</li>
<li>全部塞到一个列表里显示出来</li>
</ol>
<h3 id="列表项布局">列表项布局</h3>
<p>假设我们就构造一个最基础的列表项布局好了，一种 UIKit 直接就支持的显示模式：图片 + 标题 + 详情描述。</p>
<p>经过前面几篇文章的训练，我们对这种类型的 UI 构造应该熟门熟路了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">HStack</span>() &#123;</span><br><span class="line">	<span class="type">Image</span>(systemName: <span class="string">&quot;photo&quot;</span>) <span class="comment">// 1</span></span><br><span class="line">	<span class="type">VStack</span>(alignment: .leading) &#123;</span><br><span class="line">		<span class="type">Text</span>(<span class="string">&quot;Title&quot;</span>)</span><br><span class="line">		<span class="type">Text</span>(<span class="string">&quot;Detail description&quot;</span>)</span><br><span class="line">			.font(.subheadline)</span><br><span class="line">			.foregroundColor(.secondary) <span class="comment">// 2</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>我们这里用了一张名为“photo”的图片，这个图片是 iOS 13 送给我们的，就是那个常见的图片占位符图标</li>
<li>UIKit 默认的详情描述用的是一种灰色的偏小一点的字体，我们直接用系统提供的属性就能模仿出来</li>
</ol>
<p>完成这一步之后，预览会是这个样子的：<br>
<img src="/uploads/swiftui-serial-tutorial-4/B1BE86B5-7B16-46DF-8DE8-C6AD6B23565D.png" alt=""></p>
<p>OK，学习完前面三篇文章之后，这里并没有什么新鲜的知识。下一步是准备数据。</p>
<h3 id="准备数据">准备数据</h3>
<p>这一步跟直接用 Swift 来实现没有太多区别，我就直接用 WWDC 视频里的数据结构了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Room</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id <span class="operator">=</span> <span class="type">UUID</span>()</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> capacity: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> hasVideo: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> imageName: <span class="type">String</span> &#123; <span class="keyword">return</span> name &#125;</span><br><span class="line">    <span class="keyword">var</span> thumbnailName: <span class="type">String</span> &#123; <span class="keyword">return</span> name <span class="operator">+</span> <span class="string">&quot;Thumb&quot;</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">#if</span> <span class="type">DEBUG</span></span><br><span class="line"><span class="keyword">let</span> testData <span class="operator">=</span> [</span><br><span class="line">    <span class="type">Room</span>(name: <span class="string">&quot;Observation Deck&quot;</span>, capacity: <span class="number">6</span>, hasVideo: <span class="literal">true</span>),</span><br><span class="line">    <span class="type">Room</span>(name: <span class="string">&quot;Executive Suite&quot;</span>, capacity: <span class="number">8</span>, hasVideo: <span class="literal">false</span>),</span><br><span class="line">    <span class="type">Room</span>(name: <span class="string">&quot;Charter Jet&quot;</span>, capacity: <span class="number">16</span>, hasVideo: <span class="literal">true</span>),</span><br><span class="line">    <span class="type">Room</span>(name: <span class="string">&quot;Dungeon&quot;</span>, capacity: <span class="number">10</span>, hasVideo: <span class="literal">true</span>),</span><br><span class="line">    <span class="type">Room</span>(name: <span class="string">&quot;Panorama&quot;</span>, capacity: <span class="number">12</span>, hasVideo: <span class="literal">false</span>),</span><br><span class="line">    <span class="type">Room</span>(name: <span class="string">&quot;Oceanfront&quot;</span>, capacity: <span class="number">8</span>, hasVideo: <span class="literal">false</span>),</span><br><span class="line">    <span class="type">Room</span>(name: <span class="string">&quot;Rainbow Room&quot;</span>, capacity: <span class="number">10</span>, hasVideo: <span class="literal">true</span>),</span><br><span class="line">    <span class="type">Room</span>(name: <span class="string">&quot;Pastoral&quot;</span>, capacity: <span class="number">7</span>, hasVideo: <span class="literal">false</span>),</span><br><span class="line">    <span class="type">Room</span>(name: <span class="string">&quot;Elephant Room&quot;</span>, capacity: <span class="number">1</span>, hasVideo: <span class="literal">true</span>)</span><br><span class="line">]</span><br><span class="line"><span class="keyword">#endif</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这是我照着手敲的…如果有人知道哪里能弄来 WWDC 视频里的 Demo 项目源文件，请务必告诉我！</p>
</blockquote>
<p>到这一步为止还没什么不同，唯一比较不常见的可能是下面的 <code>testData</code>，这是方便我们调试用的假数据。</p>
<p>为了让 SwiftUI 的 <code>List</code> 能正常使用这个数据结构，我们还需要进行一点点改造：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Room</span>: <span class="title">Identifiable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id <span class="operator">=</span> <span class="type">UUID</span>()</span><br><span class="line">	  <span class="operator">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>List</code> 能使用的数据结构必须遵循 SwiftUI 里新加入的 <code>Identifiable</code> 协议，它要求这个数据结构里必须有一个符合 <code>Hashable</code> 协议的变量 <code>id</code>，我们这里用到的 <code>id</code> 是 <code>UUID</code> 类型的，本身已经满足这个要求，所以这里就不需要做更多修改了。</p>
<h2 id="列表显示">列表显示</h2>
<p>现在我们把 UI 和数据都准备好了，接下来就让它们组合起来，显示成一个列表！</p>
<p>对于 <code>List</code> 来说，列表项的默认布局就是水平方向的，所以我们可以直接 Cmd + 鼠标左键点击列表项 UI 里的 <code>HStack</code>，然后选择“Convert to List…”：<br>
<img src="/uploads/swiftui-serial-tutorial-4/D66F6EDE-FA01-489B-A8D3-4EDC81B5E18A.png" alt=""></p>
<blockquote>
<p>也许是 Xcode 的版本问题，在我这里显示的是“Embed in List”，但是最后的效果也是把选中了的 <code>HStack</code> 替换成了 <code>List</code></p>
</blockquote>
<p>得益于 <code>List</code> 构造方法里的数组类型参数，这段 UI 代码看起来就像是一个 for…in 的语句一样！回头看看预览，一个像模像样的列表已经出来了：<br>
<img src="/uploads/swiftui-serial-tutorial-4/38B4C8E5-0363-4674-AB1D-F078915AAF24.png" alt=""></p>
<p>接下来我们把准备好的数据对接上去：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> rooms: [<span class="type">Room</span>] <span class="comment">// 1</span></span><br><span class="line">	<span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">		<span class="type">List</span>(rooms) &#123; room <span class="keyword">in</span> <span class="comment">// 2</span></span><br><span class="line">			<span class="type">Image</span>(room.thumbnailName)</span><br><span class="line">			<span class="type">VStack</span>(alignment: .leading) &#123;</span><br><span class="line">				<span class="type">Text</span>(room.name)</span><br><span class="line">				<span class="type">Text</span>(<span class="string">&quot;<span class="subst">\(room.capacity)</span> people&quot;</span>)</span><br><span class="line">					.font(.subheadline)</span><br><span class="line">					.foregroundColor(.secondary)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">#if</span> <span class="type">DEBUG</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListView_Previews</span>: <span class="title">PreviewProvider</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> previews: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ListView</span>(rooms: testData) <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">#endif</span></span><br></pre></td></tr></table></figure>
<ol>
<li>先定义一个成员变量来保管数据，这一行为符合单一数据源的原则，这个数据是由调用方负责构建和传入的</li>
<li>把 <code>List</code> 的参数缓存我们真实的数组，然后把内部的硬编码数据换成传进来的数据</li>
<li>这里我们能看到预览视图的另一个好处，就是它完全模拟了真实情况下的代码逻辑，所以我们可以直接把上一步准备好的测试数据传进去</li>
</ol>
<p><img src="/uploads/swiftui-serial-tutorial-4/ACCBAF94-47D3-43B5-B924-5589A3F68C9D.png" alt=""></p>
<p>对比导入数据前后的界面，我们可以发现：默认情况下 Cell 的高度为 44pt，但是当塞进去的内容（比如图片）需要用到的高度大于这个值时，Cell 会自动调整自己的高度以适应内容的大小，并填充合适的间距来美化我们的列表项。这些小细节全都是免费的！</p>
<blockquote>
<p>预览里的图片当然是要我们事先导入的，因为跟 SwiftUI 没什么关系，所以这里也就跳过了这一步；而且我也懒得找图片来代替它们了，所以截图里看到的还是之前默认图的样子…</p>
</blockquote>
<h2 id="NavigationViewController-NavigationBar">NavigationViewController &amp; NavigationBar</h2>
<p>孤零零的一个列表可能还不够有意思，一般来说列表是罗列概要数据用的，为了看到更完整的信息，我们通常会在用户点击列表项的时候跳转到一个详情界面，这就涉及到了界面导航的概念。</p>
<p>在原来的开发过程里，这时候我们就会实现一个 <code>NavigationViewController</code> 去把我们列表的视图控制器包裹起来，然后通过 push &amp; pop 这样的操作来实现界面的切换。</p>
<p>一起来看看 SwiftUI 是怎么做的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">NavigationView</span> &#123; <span class="comment">// 1</span></span><br><span class="line">    <span class="type">List</span>(rooms) &#123; </span><br><span class="line">		  <span class="comment">// 列表项的布局 </span></span><br><span class="line">	  &#125;</span><br><span class="line">	  .navigationBarTitle(<span class="type">Text</span>(<span class="string">&quot;Rooms&quot;</span>)) <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>我们用一个 <code>NavigationView</code> 把原本 <code>body</code> 里的全部内容包裹起来，就像我们原来用 <code>NavigationViewController</code> 把 <code>UIViewController</code> 包起来一个道理</li>
<li>然后，我们给 <code>NavigationView</code> 里的最外层子视图（在这里就是 <code>List</code>）加一个修饰器来配置导航栏的标题；注意我们这里传的是一个 <code>View</code>，也就是说它不仅限于显示文字，还可以是各种各样遵循 <code>View</code> 协议的视图</li>
</ol>
<p>完成这两步就可以在原有的视图之上显示一个导航栏了，不过还不够，我们要给列表项加上点击事件以便跳转到详情界面：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span>(rooms) &#123; </span><br><span class="line">    <span class="type">NavigationButton</span>(destination: <span class="type">Text</span>(room.name)) &#123;</span><br><span class="line">        <span class="comment">// 列表项的布局</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就只有一步：把原先用于布局列表项的代码用一个 <code>NavigationButton</code> 包起来，同时通过参数来指定这个导航事件的目的地。如例子的代码所示，实现的效果是点击列表项之后跳转到一个新的界面，界面中会居中显示房间的名字：<br>
<img src="/uploads/swiftui-serial-tutorial-4/IMG_E91EAE65D877-1.jpeg" alt=""></p>
<p>在加上 <code>NavigationButton</code> 之后，细心的童鞋们可能已经发现我们列表项的变化了：每一项的尾部都显示了一个小尖角，这是 iOS 里用于表示列表可以“点击查看更多”的常见元素了。</p>
<p>OK，用 Live Mode 运行一下预览，可以看到 SwiftUI 已经把转场过程中的标题动画处理好了，界面跳转、手势返回，全都丝般顺滑。</p>
<h2 id="表单">表单</h2>
<p>两个典型的常用组件我们已经看完了，接下来我们要实现一个更复杂一些的界面。往常要实现这么一个界面，虽说没有太多的智力活，但体力活是肯定少不了的。</p>
<p>一图胜千言，先来看看效果图：<br>
<img src="/uploads/swiftui-serial-tutorial-4/00BD9E2A-5EFD-4B06-86E1-E008B2FA3D55.png" alt=""><br>
这种界面在用户注册的过程中也是挺常见的，借用一个前端的概念——它叫做“表单（Form）”。</p>
<h3 id="环境准备">环境准备</h3>
<p>接下来的代码里，有些类需要在 Xcode11 beta 4 版本上才能使用（其实我只知道 Beta 1 用不了，但具体哪个版本变化的就不清楚了），建议大家先更新一下 Xcode，不然就只能在文章里过过眼瘾啦。虽说 WWDC 展示的时候那个讲师明明就已经用上了，果然发布会要用特供版本在哪里都是惯例啊。</p>
<p>顺带一提，这种变化除了更新软件之后上手试试之外，还能在哪里看到呢？答案就是：官方文档！<br>
<img src="/uploads/swiftui-serial-tutorial-4/1BCC5384-E073-417C-A7AA-DF85A6253099.png" alt=""><br>
在网页上找到你想看的 API 之后，把图示右上角的 “API Changes” 打开，选择要比较的版本（对于 Beta 版的软件，一般不会给出每个版本之间的变化，所以如上所述我也不知道 <code>Form</code> 这位兄弟是什么时候加进来的），然后就能在 “SDKs” 下面看到特定版本的需求是什么时候加进来的了。上面的截图就表示 macOS App 在 Xcode beta 4 版本上是无法使用 <code>Form</code> 的，因为它在 beta 5 才被正式加进来。</p>
<h3 id="需求梳理">需求梳理</h3>
<p>让我们用前三篇文章加上上面两个小节的知识，来判断一下要怎么实现它。</p>
<ol>
<li>我们要有一个大大的标题在界面左上角，也许是一个 <code>navigationBarTitle</code> 可以搞定的事情</li>
<li>标题下面的内容样式看起来像是一个 <code>UITableView</code></li>
<li>这个列表分了好几个 Section，有些 Section 有属于自己的标题、有些却没有</li>
<li>每一行都有自己的样式，可能要定制好几种 <code>UITableViewCell</code>，而最后一行起到的是按钮的作用，可以真的用按钮去实现，也可以用文字加上列表项点击事件的方式来做</li>
</ol>
<h3 id="那就动手吧！">那就动手吧！</h3>
<p>看看上面的需求，每一点都不难，可它们胜在多啊！如果用 UIKit 去实现，光是把界面做出来就已经要花不少代码，更别说界面背后的数据逻辑了。</p>
<p>于是 SwiftUI 应运而生，这种简单元素组合而成的复杂页面正是它的强项！</p>
<p>我们直接看最终的界面代码，不过你也不用看得太仔细，我们会在下面把它一点点拆开来讲：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FormView</span> : <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">var</span> userInfo <span class="operator">=</span> <span class="type">UserInfo</span>() <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Form</span> &#123; <span class="comment">// 2</span></span><br><span class="line">            <span class="type">Section</span>(header: <span class="type">Text</span>(“账号注册”).font(.title)) &#123; <span class="comment">// 3</span></span><br><span class="line">                <span class="type">TextField</span>(“请输入用户名”, text: <span class="variable">$userInfo</span>.name)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Section</span>(header: <span class="type">Text</span>(“种族”).font(.headline)) &#123;</span><br><span class="line">                <span class="type">Picker</span>(selection: <span class="variable">$userInfo</span>.race, label: <span class="type">Text</span>(“种族”)) &#123; <span class="comment">// 4</span></span><br><span class="line">                    <span class="type">ForEach</span>(<span class="type">Race</span>.allCases) &#123; race <span class="keyword">in</span> <span class="comment">// 4.1</span></span><br><span class="line">                        <span class="type">Text</span>(race.name).tag(race)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;.pickerStyle(<span class="type">SegmentedPickerStyle</span>())</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Section</span>(header: <span class="type">Text</span>(“口味”).font(.headline)) &#123;</span><br><span class="line">                <span class="type">Toggle</span>(isOn: <span class="variable">$userInfo</span>.loveSweet) &#123; <span class="comment">// 5</span></span><br><span class="line">                    <span class="type">Text</span>(“喜好甜食”)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">Toggle</span>(isOn: <span class="variable">$userInfo</span>.loveSpicy) &#123;</span><br><span class="line">                    <span class="type">Text</span>(“爱吃辣”)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Section</span>(header: <span class="type">Text</span>(<span class="string">&quot;年龄&quot;</span>).font(.headline)) &#123;</span><br><span class="line">                <span class="type">Stepper</span>(value: <span class="variable">$userInfo</span>.age, in: <span class="number">1</span><span class="operator">…</span><span class="number">120</span>)&#123; <span class="comment">// 6</span></span><br><span class="line">                    <span class="type">Text</span>(<span class="string">&quot;年龄：<span class="subst">\(userInfo.age)</span>&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Section</span> &#123;</span><br><span class="line">                <span class="type">Button</span>(action: &#123;</span><br><span class="line">                    <span class="built_in">print</span>(“register with info: \(<span class="keyword">self</span>.userInfo)”)</span><br><span class="line">                &#125;) &#123;</span><br><span class="line">                    <span class="type">Text</span>(“<span class="type">Register</span>”)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管有前几篇文章的知识作为铺垫，但这段代码里还是有不少的新面孔啊。</p>
<h4 id="UserInfo">UserInfo</h4>
<p><code>UserInfo</code> 的类型定义是这样的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UserInfo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> <span class="operator">=</span> “”</span><br><span class="line">    <span class="keyword">var</span> loveSweet <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> loveSpicy <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span> <span class="operator">=</span> <span class="number">18</span></span><br><span class="line">    <span class="keyword">var</span> race: <span class="type">Race</span> <span class="operator">=</span> .<span class="type">Yellow</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它其实就是一个普通的结构体，用来表示这位用户的个人信息。</p>
<p>在上一篇文章里我们讲过，如果要把一个完整的自定义对象绑定到视图上，那么这个对象的类型就需要遵循 <code>BindableObject</code> 协议。但在这个例子里，我们只是将对象的属性绑定到了视图上，我们只在意这些属性而不是对象这个整体，所以可以直接通过 <code>@State</code> 来进行对象局部的绑定。</p>
<h4 id="Form">Form</h4>
<p>如前面的文档截图里所述：<code>Form</code> 是一个用于组合一系列数据入口的视图，比如应用的设置页面，或者是例子里的用户信息录入界面。</p>
<p>话说回来，这么多新玩具，在开发过程中怎么知道有没有可以对症下药的呢？其实它们都整整齐齐码在了原来我们用于挑选 xib 或者 storyboard 组件的地方，我们可以用 Cmd + L 把这个界面弄出来：<br>
<img src="/uploads/swiftui-serial-tutorial-4/%E6%88%AA%E5%B1%8F2019-08-13%E4%B8%8B%E5%8D%8810.18.33.png" alt=""></p>
<h4 id="Section">Section</h4>
<p>顾名思义，这是一个用于分区的控件，它也可以被用在 <code>List</code> 里面，就组成了所谓的 “SectionList”，例如通讯录里按首字母分区的样式。</p>
<p>例子中的 <code>Section</code> 用于给 <code>Form</code> 里的不同数据进行分类，并提供统一样式的 Header，它显示的内容也可以通过构造方法里的 <code>header</code> 参数来进行修改。</p>
<h4 id="Picker">Picker</h4>
<p>这是目前为止碰到的最复杂的组件了，它有点类似于 UIKit 里的 <code>PickerView</code>，不过它是更广义的“选择器”，在样式上也会有更多的变化可供选择，比如例子里的 <code>SegmentedPickerStyle</code>（有些样式是平台相关的，在使用的时候要留意编译器的提醒）。</p>
<p>其实只要明白 <code>$</code> 变量的含义，这个构造方法也很好理解，就是把选择器里选中的内容与 <code>userInfo</code> 对象里的 <code>race</code> 属性绑定起来。</p>
<h5 id="ForEach">ForEach</h5>
<p>这个写法本质上跟往 <code>List</code> 的构造方法里传一个数组的意思差不多，这样拆开来可以让列表型视图的内容样式更丰富，感兴趣的童鞋们可以详细看看<a href="https://developer.apple.com/videos/play/wwdc2019/204/">这个视频</a>，这里就不展开讲了。</p>
<p>其中的 <code>Race</code> 是一个枚举类型，它的实现也很有意思：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Race</span> : <span class="title">CaseIterable</span>, <span class="title">Hashable</span>, <span class="title">Identifiable</span> </span>&#123; <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Yellow</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Black</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">White</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Mixed</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> id: <span class="type">UUID</span> &#123; <span class="type">UUID</span>() &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> .<span class="type">Yellow</span>: <span class="keyword">return</span> <span class="string">&quot;黄种人&quot;</span></span><br><span class="line">            <span class="keyword">case</span> .<span class="type">Black</span>: <span class="keyword">return</span> <span class="string">&quot;黑种人&quot;</span></span><br><span class="line">            <span class="keyword">case</span> .<span class="type">White</span>: <span class="keyword">return</span> <span class="string">&quot;白种人&quot;</span></span><br><span class="line">            <span class="keyword">case</span> .<span class="type">Mixed</span>: <span class="keyword">return</span> <span class="string">&quot;混血&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>例子里的 <code>Race.allCase</code> 是遵循 <code>CaseIterable</code> 协议带给我们的一个福利，意思是“枚举所有可能的值”，于是我们就可以把它用在需要数组类型参数的地方了。</p>
<p>而 <code>Hashable</code> 和 <code>Identifiable</code> 是为了让这个枚举的对象可以被作为唯一标识符来使用。之所以这样做，是因为 <code>Picker</code> 的列表项必须要设置 <code>tag</code> 以区分用户的选择，于是例子中就直接用了枚举对象本身来作为选项的 <code>tag</code>。</p>
<h4 id="Toggle">Toggle</h4>
<p>这个控件看名字就该知道是干嘛用的了，正如 Swift 4.2 之后的布尔值有了一个叫 <code>toggle</code> 的语法糖，这个控件就是用来标识开关状态的，也就是原来的 <code>UISwitch</code>。</p>
<h4 id="Stepper">Stepper</h4>
<p>直译过来应该叫“步进器”。对于重视用户体验的苹果来说，这样看上去简单，但要正确实现逻辑还需要费点心思的小玩意儿，当然是选择封装成一个系统组件！相信看了前面那些五花八门的组件之后，这个 <code>Stepper</code> 的用法也是不需要再多加解释了。</p>
<h3 id="小结">小结</h3>
<p>好了，这短短不到40行的代码（好吧，算上那个结构体和枚举也有60行左右了），就已经实现了我们这一小节开头截图里的那种表单效果。不仅如此，SwiftUI 还默默为我们做了大量的优化工作，我可以拍胸脯说这些代码在效率上也会是远超 UIKit 版本的。</p>
<h2 id="总结">总结</h2>
<p>四篇文章下来，这个系列的 SwiftUI 教程也算是告一段落了。显然这仅仅是一个入门教程，更多有意思的新元素还在后面等着你。</p>
<p>文章里面的例子都是通过 Xcode 的新功能 Canvas 预览和截图出来的，目前它也只有个 iPhone 的外框样式，这难免有点限制了我们的想象，所以我必须要在最后提醒大家一句：</p>
<p><strong>用 SwiftUI 构建的界面天生就是跨全苹果平台的！</strong></p>
<p>也就是说，之前例子里的<strong>所有代码放到 macOS 和 watchOS 上都是适用的</strong>！（当然要除掉跟 UIKit 混合的那部分）而且所有界面的样式都会根据平台的不同而自动调整，几乎不需要开发者的介入就可以做到全平台适配！</p>
<p>写到这的时候我居然感觉挺兴奋的，就像是回到了刚刚接触 Xcode 和在 iOS 5 上做开发的那个年代。那个时候 Android 已经有好些机型要适配，而我只要把应用在我手里的 iPhone 上跑顺就八九不离十了:)</p>
<h2 id="参考文章">参考文章</h2>
<ul>
<li><a href="https://developer.apple.com/videos/play/wwdc2019/204/">Introducing SwiftUI: Building Your First App - WWDC 2019 - Videos - Apple Developer</a></li>
<li><a href="https://developer.apple.com/videos/play/wwdc2019/216/">SwiftUI Essentials - WWDC 2019 - Videos - Apple Developer</a></li>
<li><a href="https://onevcat.com/2019/06/swift-ui-firstlook-2/">SwiftUI 的一些初步探索 (二)</a></li>
</ul>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"8225264e14e677544541","clientSecret":"ed2a2c6d5043e9f0b41cae78b0d5b4571099de53","repo":"HexoBlogSource","owner":"davidleee","admin":["davidleee"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>Swift</tag>
        <tag>SwiftUI</tag>
        <tag>List</tag>
        <tag>NavigationView</tag>
        <tag>NavigationButton</tag>
        <tag>Form</tag>
        <tag>Picker</tag>
        <tag>Toggle</tag>
        <tag>Section</tag>
        <tag>Stepper</tag>
      </tags>
  </entry>
</search>
