<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lee 的笔记本</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://davidleee.com/"/>
  <updated>2021-03-05T06:03:51.581Z</updated>
  <id>http://davidleee.com/</id>
  
  <author>
    <name>Lee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>多喝水技术支持</title>
    <link href="http://davidleee.com/2021/03/05/techsupport-drinkmore/"/>
    <id>http://davidleee.com/2021/03/05/techsupport-drinkmore/</id>
    <published>2021-03-05T05:52:42.000Z</published>
    <updated>2021-03-05T06:03:51.581Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/uploads/techsupport-drinkmore/drinkmore-presentation.png" alt></p><a id="more"></a><p>你是否曾经有过这样的困扰：<br>白天水喝少了或者吃咸了导致晚上睡前总口渴，<br>但是睡前水喝多了又会导致睡着之后老起夜？</p><p>多喝水 就是来帮你解决身体水平衡问题的，让你的身体从此水分满满没烦恼！</p><p>== 功能 ==</p><ul><li>科学计算你所需的喝水量</li><li>在合适的时机提醒你喝水</li><li>方便快捷地记录每次水分摄入</li><li>让你一目了然自己过去的表现</li></ul><p>获取技术支持：</p><ul><li>邮件：onetap@foxmail.com</li><li>或直接在下方评论区流言</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/uploads/techsupport-drinkmore/drinkmore-presentation.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术支持" scheme="http://davidleee.com/tags/%E6%8A%80%E6%9C%AF%E6%94%AF%E6%8C%81/"/>
    
      <category term="多喝水" scheme="http://davidleee.com/tags/%E5%A4%9A%E5%96%9D%E6%B0%B4/"/>
    
  </entry>
  
  <entry>
    <title>隐私协议</title>
    <link href="http://davidleee.com/2021/03/05/privacy/"/>
    <id>http://davidleee.com/2021/03/05/privacy/</id>
    <published>2021-03-05T05:44:12.000Z</published>
    <updated>2021-03-05T05:45:59.947Z</updated>
    
    <content type="html"><![CDATA[<p>本软件尊重并保护所有使用服务用户的个人隐私权。为了给您提供更准确、更有个性化的服务，本软件会按照本隐私权政策的规定使用和披露您的个人信息。但本软件将以高度的勤勉、审慎义务对待这些信息。除本隐私权政策另有规定外，在未征得您事先许可的情况下，本软件不会将这些信息对外披露或向第三方提供。本软件会不时更新本隐私权政策。您在同意本软件服务使用协议之时，即视为您已经同意本隐私权政策全部内容。本隐私权政策属于本软件服务使用协议不可分割的一部分。</p><p>1.适用范围</p><p>a)在您使用本软件网络服务，本软件自动接收并记录的您的手机上的信息，包括但不限于您的健康数据、使用的语言、访问日期和时间、软硬件特征信息及您需求的网页记录等数据；</p><p>2.信息的使用</p><p>a)在获得您的数据之后，本软件会将其上传至服务器，以生成您的排行榜数据，以便您能够更好地使用服务。</p><p>3.信息披露</p><p>a)本软件不会将您的信息披露给不受信任的第三方。</p><p>b)根据法律的有关规定，或者行政或司法机构的要求，向第三方或者行政、司法机构披露；</p><p>c)如您出现违反中国有关法律、法规或者相关规则的情况，需要向第三方披露；</p><p>4.信息存储和交换</p><p>本软件收集的有关您的信息和资料将保存在本软件及（或）其关联公司的服务器上，这些信息和资料可能传送至您所在国家、地区或本软件收集信息和资料所在地的境外并在境外被访问、存储和展示。</p><p>5.信息安全</p><p>a)在使用本软件网络服务进行网上交易时，您不可避免的要向交易对方或潜在的交易对方披露自己的个人信息，如联络方式或者邮政地址。请您妥善保护自己的个人信息，仅在必要的情形下向他人提供。如您发现自己的个人信息泄密，请您立即联络本软件客服，以便本软件采取相应措施。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本软件尊重并保护所有使用服务用户的个人隐私权。为了给您提供更准确、更有个性化的服务，本软件会按照本隐私权政策的规定使用和披露您的个人信息。但本软件将以高度的勤勉、审慎义务对待这些信息。除本隐私权政策另有规定外，在未征得您事先许可的情况下，本软件不会将这些信息对外披露或向第三
      
    
    </summary>
    
    
      <category term="协议" scheme="http://davidleee.com/tags/%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>在 macOS 中如何使用 XPC 实现跨进程通讯？</title>
    <link href="http://davidleee.com/2020/07/20/ipc-for-macOS/"/>
    <id>http://davidleee.com/2020/07/20/ipc-for-macOS/</id>
    <published>2020-07-20T04:45:38.000Z</published>
    <updated>2020-08-09T14:42:54.698Z</updated>
    
    <content type="html"><![CDATA[<p>最近需要在 Electron 项目上引入一个比较吃性能的大头功能，因为已经用 Objective-C 实现过一套稳定且性能也可接受的带 UI 方案了，所以计划看看能不能将这套现成的方案直接用到 Electron 里。但想要这么做就必须解决原生 UI 与 Electron 通讯的问题，再进一步，能不能让 Electron 以多进程的方式调起这个大头功能的 Demo 以节省掉绝大部分的重复工作呢？</p><blockquote><p>本文只研究了原生 XPC 通讯的部分，关于集成到 Electron 里还有哪些坑会在下一篇文章里讲讲</p></blockquote><a id="more"></a><h2 id="什么是-xpc">什么是 XPC</h2><blockquote><p>选型的过程不是这次要讨论的重点，就当作我们经过一番挣扎然后选择了原生的 XPC 实现吧：）</p></blockquote><p>XPC 是苹果官方提供的一种进程间通讯的手段，是一种苹果特有的 IPC 技术。</p><p>在 NSHipster 的<a href="https://nshipster.com/inter-process-communication/" target="_blank" rel="noopener">一篇文章</a>里，作者说 XPC 是官方 SDK 内跨进程通讯的最优解决方案（2014）。从 2011 年被提出的时候，XPC 就持续在“体制内”发光发热，比如 macOS 的沙盒、iOS 的 Remote View Controller 和两个平台上都有的应用扩展（App Extensions）里都用到了 XPC 的技术。</p><p>对于开发者来说，使用 XPC 技术我们就能做到像这样的事情：</p><ol><li>模块 A 负责 UI 展示，它<strong>不需要申请任何系统权限</strong>，用到网络图片时就向模块 B 获取</li><li>模块 B 拥有<strong>网络权限</strong>，能从网络或缓存中获取图片，但操作文件系统的工作由模块 C 负责</li><li>模块 C 拥有<strong>文件读写权限</strong>，负责将数据写成文件或读取文件数据</li><li>这三个模块都在同一个应用中，它们所需要的权限相互独立，功能单一，而且即使崩溃了也不会相互影响，只需要重启相应的模块就又可以恢复正常使用</li></ol><p>看完是不是已经迫不及待了呢？别着急，在使用这个强大工具前，我们还需要了解两个关键技术。</p><h3 id="题外话1-launchd">题外话1 - launchd</h3><p><code>launchd</code> 负责管理 macOS 上的守护进程，在构建 XPC 方案的过程中，我们会用它来配置一个我们自己的守护进程。</p><p>这个守护进程会一直潜伏在系统里（只占用非常少的资源），当我们的应用需要它的时候就可以被随时唤醒。</p><p>更多 <code>launchd</code> 的信息和用法可以在它的<a href="x-man-page://5/launchd.plist" target="_blank" rel="noopener">man 页面</a>找到。</p><h3 id="题外话2-smjobbless">题外话2 - SMJobBless</h3><p>字面意思是“给任务加上祝福”，任何应用都不能跟一个没有被系统祝福的任务愉快地玩耍。</p><p>这是一组协助开发者安全地安装守护进程的 API，长这个样子：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Boolean SMJobBless(<span class="built_in">CFStringRef</span> domain, <span class="built_in">CFStringRef</span> executableLabel, AuthorizationRef auth, <span class="built_in">CFErrorRef</span> *outError);</span><br></pre></td></tr></table></figure><p>苹果似乎也认为这组 API 的用法只可意会不可言传，所以在<a href="https://developer.apple.com/documentation/servicemanagement/1431078-smjobbless?language=objc" target="_blank" rel="noopener">SMJobBless 的方法说明</a>里写了很多，还给出了一个很完整的<a href="http://developer.apple.com/library/mac/#samplecode/SMJobBless/" target="_blank" rel="noopener">示例工程</a>并通过一个 <a href="https://developer.apple.com/library/archive/samplecode/SMJobBless/Listings/SMJobBlessUtil_py.html#//apple_ref/doc/uid/DTS40010071-SMJobBlessUtil_py-DontLinkElementID_8" target="_blank" rel="noopener">Python 脚本</a>把安装守护进程的前置条件给配置好了。</p><blockquote><p>脚本这个动作，虽然让整个流程变得更加完善，但却将原本只要几句命令就能解决的事情复杂化了，少了一些苹果味。</p></blockquote><h2 id="架起通讯的桥梁">架起通讯的桥梁</h2><p>写了这么多，其实都还在 <strong>Prerequisites</strong> 阶段打转转。接下来才要正式开始跨应用通讯的实现！</p><p>不过在此之前，我们还是先把上文题外话里提到的前置条件准备好，让后面的过程更顺畅一些。</p><h3 id="前置准备">前置准备</h3><p>通过 <code>launchd</code> 安装守护进程是个需要很高安全性的动作，所以应用签名是必不可少的。而对于一个跨应用通讯的系统来说，安全性主要涉及到两个部分：</p><ul><li>通讯发起方</li><li>XPC 应用</li></ul><blockquote><p>在这篇文章中，通讯的接收方不负责 XPC 应用的安装，所以它只要管好自己的签名就够了</p></blockquote><p>这里我们就要用上前面提到的 Python 脚本里的一句关键命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">codesign -d -r - /path/to/file.app</span><br></pre></td></tr></table></figure><blockquote><p>虽然官方 Demo 里的这个脚本还做了许多其他的检验来确保信息的完整和正确，但对于我们这样成熟的（嘿嘿）开发者来说，当然要直接薅最珍贵的羊毛啦。</p></blockquote><p>把这个命令的路径参数改为我们已经签好名的应用，会得到像这样子的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Executable=/path/to/file.app</span><br><span class="line">designated =&gt; anchor apple generic and identifier &quot;com.example.apple-samplecode.EBAS.App&quot; and (certificate leaf[field.1.2.840.113635.100.6.1.9] /* exists */ or certificate 1[field.1.2.840.113635.100.6.2.6] /* exists */ and certificate leaf[field.1.2.840.113635.100.6.1.13] /* exists */ and certificate leaf[subject.OU] = SKMME9E2Y8)</span><br></pre></td></tr></table></figure><p>其中，<code>designated =&gt;</code> 后面的部分（例子里是从 “anchor” 开始，我们自己签名的话开头可能是“identifier”，这个顺序并不要紧）就是我们需要的“签名需求”（Code Signing Requirement）。</p><p>把签名需求放到我们自己的 XPC 应用的 Info.plist 里，如此一来这个 XPC 应用就只能被拥有这个签名的应用启动了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>SMAuthorizedClients<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>anchor apple generic and identifier "com.example.apple-samplecode.EBAS.App" and (certificate leaf[field.1.2.840.113635.100.6.1.9] /* exists */ or certificate 1[field.1.2.840.113635.100.6.2.6] /* exists */ and certificate leaf[field.1.2.840.113635.100.6.1.13] /* exists */ and certificate leaf[subject.OU] = SKMME9E2Y8)<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里的 value 是数组格式的，意味着如果想允许多个 App 启动这个 XPC 应用的话，就需要把这些 App 的签名需求都写上。</p><p>同理，还要取到 XPC 应用的签名需求并配到我们客户端的 Info.plist 里：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>SMPrivilegedExecutables<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>com.example.apple-samplecode.EBAS.HelperTool<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>anchor apple generic and identifier "com.example.apple-samplecode.EBAS.HelperTool" and (certificate leaf[field.1.2.840.113635.100.6.1.9] /* exists */ or certificate 1[field.1.2.840.113635.100.6.2.6] /* exists */ and certificate leaf[field.1.2.840.113635.100.6.1.13] /* exists */ and certificate leaf[subject.OU] = SKMME9E2Y8)<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意这个 “dict” 里的 “key” 要填的是我们的 XPC 应用的 label，不过因为 label 通常会定成跟 Bundle Identifier 一致，所以写上它的 Bundle Identifier 也就可以了。</p><blockquote><p>上一段啰嗦了一下是因为 label 其实可以跟 Bundle Identifier 不同的，但这会给开发的过程带来许多麻烦，所以建议还是统一。这个 label 具体是什么鬼会在下一个小节里讲到。</p></blockquote><h3 id="创建-安装-xpc-应用">创建 &amp; 安装 XPC 应用</h3><p>首先来添加一个 Target 并选择 XPC Service，让 Xcode 帮我们生成一些默认代码：<br><img src="/uploads/ipc-for-macOS/create_target.png" alt></p><p>然后为我们的 XPC 应用再创建一个 plist，这个文件会在 XPC 应用被安装的时候自动拷贝到 <em>/Library/LaunchDaemons</em> 目录下，这是统一存放守护进程配置文件的地方。</p><p>为了与默认的 Info.plist 区分开来，在文件的名字里加上个 “Launchd”，文件内容是这样的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">plist</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//Apple//DTD PLIST 1.0//EN"</span> <span class="meta-string">"http://www.apple.com/DTDs/PropertyList-1.0.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plist</span> <span class="attr">version</span>=<span class="string">"1.0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>Label<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>com.example.apple-samplecode.EBAS.HelperTool<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>MachServices<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>com.example.apple-samplecode.EBAS.HelperTool<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plist</span>&gt;</span></span><br></pre></td></tr></table></figure><p>看，前面埋的坑—— <strong>Label</strong> 出现了！这是系统用来唯一标识守护进程的值，下面 MachServices 中的 key 是我们 XPC 应用的 Bundle Identifier。在建立连接的时候，系统就会根据这张配置表去寻找正确的 XPC 应用。</p><p>完成后我们的目录结构是这样的：（例子来自官方的 <a href="https://developer.apple.com/library/archive/samplecode/EvenBetterAuthorizationSample/Introduction/Intro.html#//apple_ref/doc/uid/DTS40013768-Intro-DontLinkElementID_2" target="_blank" rel="noopener">EvenBetterAuthorizationSample</a>）<br><img src="/uploads/ipc-for-macOS/9B514455-AC1D-454F-8681-34076024982E.png" alt></p><blockquote><p>如图，官方例子中还给 plist 加上了项目名前缀，但名字不重要，重要的是别忘了把签名需求写对。</p></blockquote><p>最后，因为我们要用到的产物是 .xpc 包里的二进制文件，所以必须把这两个 plist 也打进二进制文件里去，这就要在 Build Settings 的 Other Linker Flags 里配置一下：<br><img src="/uploads/ipc-for-macOS/29AEBF92-9331-41E1-8EAB-04718FEFDB6C.png" alt></p><p>配置内容如下，把最后的路径改成自己的 plist 就可以了（这也是为什么前面说文件名不重要）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-sectcreate __TEXT __info_plist HelperTool/HelperTool-Info.plist</span><br><span class="line">-sectcreate __TEXT __launchd_plist HelperTool/HelperTool-Launchd.plist</span><br></pre></td></tr></table></figure><p>完成了这些配置后打出来的包会是一个完整的 .xpc 文件了，但我们需要的只是它里面的二进制文件。在用上它之前，让我们把安装 XPC 应用的代码写好，这里的代码是在官方例子的基础上改的，个人感觉比例子里的更易懂一些：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">AuthorizationItem authItem = &#123; kSMRightBlessPrivilegedHelper, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span> &#125;;</span><br><span class="line">AuthorizationRights authRights = &#123; <span class="number">1</span>, &amp;authItem &#125;;</span><br><span class="line">AuthorizationFlags flags = kAuthorizationFlagDefaults | kAuthorizationFlagInteractionAllowed | kAuthorizationFlagPreAuthorize | kAuthorizationFlagExtendRights;</span><br><span class="line"></span><br><span class="line">AuthorizationRef authRef = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">OSStatus status = AuthorizationCreate(&amp;authRights, kAuthorizationEmptyEnvironment, flags, &amp;authRef);</span><br><span class="line"><span class="keyword">if</span> (status != errAuthorizationSuccess) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Failed to create AuthorizationRef, return code %i"</span>, status);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">CFErrorRef</span> error;</span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="built_in">BOOL</span> success = SMJobBless(kSMDomainSystemLaunchd, (__bridge <span class="built_in">CFStringRef</span>)<span class="string">@"com.example.apple-samplecode.EBAS.HelperTool"</span>, authRef, &amp;error);</span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"job bless success"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"job bless error: %@"</span>, (__bridge <span class="built_in">NSError</span> *)error);</span><br><span class="line">        <span class="built_in">CFRelease</span>(error);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>构造申请权限所需要的参数，官方例子中没有这一步</li><li>申请权限，如果这一步失败了，那我们的应用就不能做任何需要用户授权的操作了；官方例子中因为少了构造参数的步骤，所以这里会变成 <code>AuthorizationCreate(NULL, NULL, 0, &amp;authRef)</code></li><li>使用题外话里讲到的 API 来安装我们的 XPC 应用，其中，<code>kSMDomainSystemLaunchd</code> 表示我们要使用 launchd 服务（这也是目前仅有的可选项），第二个参数是我们之前设置的 XPC 应用的 label</li></ol><p>当执行到上面的逻辑时，我们从两个角度来看看会发生什么：</p><ul><li>用户角度：界面上弹出一个授权框，提示用户输入解锁密码</li><li>系统角度：系统会进入申请授权的应用内部寻找这个待安装的 XPC 应用二进制包，如果找到了会将它 <em>存起来</em> 以便下一次可以直接唤起，并把其中的 launchd 配置拷贝的统一的位置</li></ul><blockquote><p>通过 SMJobBless 安装的 XPC 应用会存在 /Library/PrivilegedHelperTools 下面，一旦授权完成过一次，后续只要配置文件和这里的二进制文件还对得上就不会再弹授权框了</p></blockquote><p>为了让系统方便地找到 XPC 应用，要把它的<strong>二进制文件</strong>放到应用的 /Contents/Library/LaunchServices 路径下，我们可以在客户端的 Build Phases 里面加一个步骤来做这件事：<br><img src="/uploads/ipc-for-macOS/03FE8C66-DDBB-4A23-9D0B-5C0FE1535F30.png" alt></p><blockquote><p>千万记得这里要放的是 .xpc 包里的二进制文件，在 xxx.xpc/Contents/MacOS 目录下</p></blockquote><p>OK，万事具备，接下来我们真的要写代码了。</p><h3 id="与-xpc-应用通讯">与 XPC 应用通讯</h3><p>首先我们来实现 XPC 应用的连接监听逻辑，在创建 Target 之后的 .m 文件里已经有连接处理的模版和丰富的注释了：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.listener = [[<span class="built_in">NSXPCListener</span> alloc] initWithMachServiceName:<span class="string">@"这里改成上面设置的 Label"</span>];</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)listener:(<span class="built_in">NSXPCListener</span> *)listener shouldAcceptNewConnection:(<span class="built_in">NSXPCConnection</span> *)newConnection &#123;</span><br><span class="line">    <span class="comment">// This method is where the NSXPCListener configures, accepts, and resumes a new incoming NSXPCConnection.</span></span><br><span class="line">    assert(listener == <span class="keyword">self</span>.listener);</span><br><span class="line">    assert(newConnection != <span class="literal">nil</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Configure the connection.</span></span><br><span class="line">    <span class="comment">// First, set the interface that the exported object implements.</span></span><br><span class="line">    newConnection.exportedInterface = [<span class="built_in">NSXPCInterface</span> interfaceWithProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">HelperToolProtocol</span>)];</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Next, set the object that the connection exports. All messages sent on the connection to this service will be sent to the exported object to handle. The connection retains the exported object.</span></span><br><span class="line">    newConnection.exportedObject = <span class="keyword">self</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Resuming the connection allows the system to deliver more incoming messages.</span></span><br><span class="line">    [newConnection resume];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Returning YES from this method tells the system that you have accepted this connection. If you want to reject the connection for some reason, call -invalidate on the connection and return NO.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要特别说明的一点是，XPC 连接建立起来之后，连接发起方就能获取到上面的逻辑里的 <code>exportedObject</code>，而再上一行的 <code>exportedInterface</code> 是声明这个对象在这次 XPC 通讯中会遵循的协议。</p><p>换句话说，连接的发起方会把连接上的 XPC 应用直接当作一个对象来操作。这个对象的消息传递是异步的，所以在调用的时候要小心避免卡主线程。</p><blockquote><p>因为协议需要连接双方自行约定统一，所以上面 <code>HelperToolProtocol</code> 的定义建议放到一个公共的文件里，让我们的应用项目和 XPC 应用项目都能访问到</p></blockquote><p>XPC 应用这边先说这么多，大多数情况下模版代码就够了，只需要自己定义一下 <code>exportedInterface</code> 就能实现例如心跳机制这样的功能。</p><p>接下来实现客户端发起连接的逻辑，我们直接参考官方例子里的代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)connectToHelperTool</span><br><span class="line">    <span class="comment">// Ensures that we're connected to our helper tool.</span></span><br><span class="line">&#123;</span><br><span class="line">    assert([<span class="built_in">NSThread</span> isMainThread]);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.helperToolConnection == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">self</span>.helperToolConnection = [[<span class="built_in">NSXPCConnection</span> alloc] initWithMachServiceName:kHelperToolMachServiceName options:<span class="built_in">NSXPCConnectionPrivileged</span>];</span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">self</span>.helperToolConnection.remoteObjectInterface = [<span class="built_in">NSXPCInterface</span> interfaceWithProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">HelperToolProtocol</span>)];</span></span><br><span class="line">        <span class="comment">// 3</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic push</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">"-Warc-retain-cycles"</span></span></span><br><span class="line">        <span class="comment">// We can ignore the retain cycle warning because a) the retain taken by the</span></span><br><span class="line">        <span class="comment">// invalidation handler block is released by us setting it to nil when the block </span></span><br><span class="line">        <span class="comment">// actually runs, and b) the retain taken by the block passed to -addOperationWithBlock: </span></span><br><span class="line">        <span class="comment">// will be released when that operation completes and the operation itself is deallocated </span></span><br><span class="line">        <span class="comment">// (notably self does not have a reference to the NSBlockOperation).</span></span><br><span class="line">        <span class="keyword">self</span>.helperToolConnection.invalidationHandler = ^&#123;</span><br><span class="line">            <span class="comment">// If the connection gets invalidated then, on the main thread, nil out our</span></span><br><span class="line">            <span class="comment">// reference to it.  This ensures that we attempt to rebuild it the next time around.</span></span><br><span class="line">            <span class="keyword">self</span>.helperToolConnection.invalidationHandler = <span class="literal">nil</span>;</span><br><span class="line">            [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">                <span class="keyword">self</span>.helperToolConnection = <span class="literal">nil</span>;</span><br><span class="line">                [<span class="keyword">self</span> logText:<span class="string">@"connection invalidated\n"</span>];</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic pop</span></span><br><span class="line">        <span class="comment">// 4</span></span><br><span class="line">        [<span class="keyword">self</span>.helperToolConnection resume];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>通过 label 找到特定 XPC 应用并建立连接，建议把这个连接实例保存起来，避免重复创建带来别的问题</li><li>这一步参数里的协议就是我们在 XPC 应用中声明的协议，两边的协议要对得上才能拿到 XPC 应用中暴露出来的正确对象</li><li>大段注释是在解释为什么这里不需要担心循环引用的问题；要注意的是如果我们把连接实例存了起来，最好是像这样在 <code>invalidationHandler</code> 里置空，在其他地方通过 <code>[connection invalidate]</code>来实现断连</li><li>手动调用 <code>resume</code> 来建立连接，调用后 XPC 应用那边才会收到 <code>-[listener:shouldAcceptNewConnection:]</code> 回调</li></ol><p>Done！如果前面的一系列配置都正确的话，这个方法就能搭起客户端与 XPC 应用之间连接桥梁了！</p><h3 id="与其他进程通讯">与其他进程通讯</h3><p>除了与 XPC 应用建立连接之外，NSXPCConnection 还提供了另一组 API 用于直接跟其他客户端建立连接：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithListenerEndpoint:(<span class="built_in">NSXPCListenerEndpoint</span> *)endpoint;</span><br></pre></td></tr></table></figure><p>一次完整的连接建立流程是这样的：</p><ol><li>客户端 A 与 XPC 应用建立连接</li><li>客户端 A 生成一个 NSXPCListenerEndpoint 并存放到 XPC 应用里</li><li>客户端 B 与 XPC 应用建立连接并取到这个 NSXPCListenerEndpoint</li><li>客户端 B 通过 NSXPCListenerEndpoint 与客户端 A 建立连接</li></ol><p>在上个小节中我们完成了第一步，而第四步跟第一步其实挺像的，所以第二三步就是我们现在要处理的了。</p><p>之前我们声明了一个空的 <code>HelperToolProtocol</code>，现在就给它加一些内容，向外界提供对象读写的能力：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">HelperToolProtocol</span></span></span><br><span class="line">- (<span class="keyword">void</span>)setEndpoint:(<span class="built_in">NSXPCListenerEndpoint</span> *)endpoint withReply:(<span class="keyword">void</span> (^)(<span class="built_in">BOOL</span>))reply;</span><br><span class="line">- (<span class="keyword">void</span>)getEndpointWithReply:(<span class="keyword">void</span> (^)(<span class="built_in">NSXPCListenerEndpoint</span> *))reply;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><blockquote><p>因为 <code>exportedObject</code> 的消息传递是异步的，所以在需要返回值的时候要改用回调的方式实现。</p></blockquote><p>然后在 XPC 应用里声明一个成员变量并实现上面的两个方法就完成了：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSXPCListenerEndpoint</span> *endpoint;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setEndpoint:(<span class="built_in">NSXPCListenerEndpoint</span> *)endpoint withReply:(<span class="keyword">void</span> (^)(<span class="built_in">BOOL</span>))reply &#123;</span><br><span class="line">    <span class="keyword">self</span>.endpoint = endpoint;</span><br><span class="line">    reply(<span class="literal">YES</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)getEndpointWithReply:(<span class="keyword">void</span> (^)(<span class="built_in">NSXPCListenerEndpoint</span> *))reply &#123;</span><br><span class="line">    reply(<span class="keyword">self</span>.endpoint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来回到客户端的代码里（现在还没实现客户端 B，所以这里讲的都是客户端 A）：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">[<span class="keyword">self</span> connectToHelperTool];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">self</span>.listener = [<span class="built_in">NSXPCListener</span> anonymousListener];</span><br><span class="line"><span class="keyword">self</span>.listener.delegate = <span class="keyword">self</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">id</span>&lt;HelperToolProtocol&gt; service = [<span class="keyword">self</span>.connection remoteObjectProxyWithErrorHandler:^(<span class="built_in">NSError</span> * _Nonnull error) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"get remote object proxy error: %@"</span>, error);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line">[service setEndpoint:<span class="keyword">self</span>.listener.endpoint withReply:^(<span class="built_in">BOOL</span> result) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"set endpoint result: %@"</span>, result ? <span class="string">@"success"</span> : <span class="string">@"failed"</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><ol><li>先 XPC 应用建立连接</li><li>准备一个监听器来处理其他客户端的连接</li><li>获取到 XPC 应用的 <code>exportedObject</code>，因为方法返回的是实现了这个协议的对象，所以协议的匹配很关键</li><li>调用协议中的方法把匿名监听器的端点设置过去，因为我们在 XPC 应用里写死了返回 <code>YES</code>，所以这里肯定会成功，实际使用的过程中可能要加上安全性的处理</li></ol><p>监听器有了，就差监听到连接后的回调了：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)listener:(<span class="built_in">NSXPCListener</span> *)listener shouldAcceptNewConnection:(<span class="built_in">NSXPCConnection</span> *)newConnection &#123;</span><br><span class="line">    assert(listener == <span class="keyword">self</span>.listener);</span><br><span class="line">    assert(newConnection != <span class="literal">nil</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">self</span>.clientConnection.invalidationHandler = ^&#123;</span><br><span class="line">        weakSelf.clientConnection.invalidationHandler = <span class="literal">nil</span>;</span><br><span class="line">        [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">            weakSelf.clientConnection = <span class="literal">nil</span>;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">self</span>.clientConnection.remoteObjectInterface = [<span class="built_in">NSXPCInterface</span> interfaceWithProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">ClientBProtocol</span>)];</span></span><br><span class="line">    <span class="keyword">self</span>.clientConnection.exportedInterface = [<span class="built_in">NSXPCInterface</span> interfaceWithProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">ClientAProtocol</span>)];</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.clientConnection.exportedObject = <span class="keyword">self</span>;</span><br><span class="line">    [<span class="keyword">self</span>.clientConnection resume];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>这个熟悉的回调方法其实跟 XPC 应用里的那个一样，客户端 A 已经具备了一个 XPC 应用的基本功能了</li><li>官方例子的另一种写法，逻辑上是一样的（可能这种还亲切一些呢😬）</li><li>除了 <code>exportedInterface</code> 之外，还要设置 <code>remoteObjectInterface</code>，因为这是一条双向通讯的连接，所以要让其他客户端知道我们期望它们能遵循什么协议</li></ol><p>好的，流程走完一半了，第三四步需要在客户端 B 里面实现：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">[<span class="keyword">self</span> connectToHelperTool];</span><br><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">[[<span class="keyword">self</span>.connection remoteObjectProxyWithErrorHandler:<span class="literal">nil</span>] getEndpointWithReply:^(<span class="built_in">NSXPCListenerEndpoint</span> *endpoint) &#123;</span><br><span class="line">    [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">        <span class="keyword">if</span> (endpoint) &#123;</span><br><span class="line">            [weakSelf connectWithEndpoint:endpoint];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;]</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)connectWithEndpoint:(<span class="built_in">NSXPCListenerEndpoint</span> *)endpoint &#123;</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">self</span>.serverConnection = [[<span class="built_in">NSXPCConnection</span> alloc] initWithListenerEndpoint:endpoint];</span><br><span class="line">    <span class="keyword">self</span>.serverConnection.remoteObjectInterface = [<span class="built_in">NSXPCInterface</span> interfaceWithProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">ServerCommunicationProtocol</span>)];</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">self</span>.serverConnection.exportedInterface = [<span class="built_in">NSXPCInterface</span> interfaceWithProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">ClientCommunicationProtocol</span>)];</span></span><br><span class="line">    <span class="keyword">self</span>.serverConnection.exportedObject = <span class="keyword">self</span>;</span><br><span class="line">    </span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">self</span>.serverConnection.invalidationHandler = ^&#123;</span><br><span class="line">        weakSelf.serverConnection.invalidationHandler = <span class="literal">nil</span>;</span><br><span class="line">        [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">            weakSelf.serverConnection = <span class="literal">nil</span>;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span>.serverConnection resume];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4</span></span><br><span class="line">    <span class="comment">// self.serverConnectionEndpoint = endpoint;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>客户端 B 从 XPC 应用中拿到客户端 A 设置的端点，这跟设置端点的代码差不多</li><li>通过端点来构造 <code>NSXPCConnection</code>，这样在调用 <code>resume</code> 之后对方会收到 <code>-[listener:shouldAcceptNewConnection:]</code> 的回调</li><li>与上文的回调处理类似，因为我们要做的是双向通讯，所以客户端 B 在发起连接时也要把 <code>exportedInterface</code> 和 <code>exportedObject</code> 设置好，之后的代码就跟其他地方看到的差不多了</li><li>有必要的话可以把这个端点存起来用于一些判断或重连的逻辑</li></ol><h2 id="常见错误">常见错误</h2><blockquote><p>这一段总结了我在实现过程中踩的坑，也许我们的情况不太一样，但希望能给大家一个排查的思路</p></blockquote><p>涉及到多端通讯的逻辑调试起来比较绕，错误通常会发生在以下两个部分：</p><ol><li>客户端部分：确认代码逻辑没漏的话，可以把各种 <code>handler</code> 的结果都打印一下，一般都会带有比较明确的错误域和错误码</li><li>连接部分：这类错误信息不会出现在客户端日志里，也分两类<ol><li>没有任何反应但就是连不上：可以用自带的控制台工具去捞日志</li><li>调用 API 导致崩溃：也是控制台捞，macOS 的系统崩溃上报弹窗里可能会有更多信息</li></ol></li></ol><p>下面是我碰过的一些错误和处理方式：</p><h3 id="cferrordomainlaunchd-code-2">CFErrorDomainLaunchd Code=2</h3><p>安装 XPC 应用时在客户端内找不到 XPC 应用的二进制文件，检查一下二进制包是不是放到了正确的路径下，格式是否正确（记得要取 .xpc 后缀的文件里的二进制文件）。</p><h3 id="cferrordomainlaunchd-code-4-or-8">CFErrorDomainLaunchd Code=4 or 8</h3><p>签名匹配不上。大概率是 Info.plist 里配置的签名需求不正确，回头看看 <em>前置准备</em> 那个小节，检查内容是否跟 <code>codesign -d -r - /path/to/app</code>  和 <code>codesign -d -r - /path/to/xpc</code>  的一致。</p><h3 id="error-domain-nscocoaerrordomain-code-4097">Error Domain=NSCocoaErrorDomain Code=4097</h3><blockquote><p>出自 FoundationErrors.h - NSXPCConnectionInterrupted</p></blockquote><p>连接被打断（interrupted），约等于 connection.interruptionHandler 被触发了。<br>如果发生在连接建立的过程中，那意味着它发现连接已经被占用了，多见于调试过程中重启了其中一端，但是另一端没有把连接释放掉。</p><p>在正常运行的过程中发生的话，可能是系统 XPC 服务发现我们的连接长时间没有使用而挂起了它，这种情况一般不需要处理，系统会在我们下次使用这条连接的时候自动帮我们处理好。</p><h3 id="error-domain-nscocoaerrordomain-code-4099">Error Domain=NSCocoaErrorDomain Code=4099</h3><blockquote><p>出自 FoundationErrors.h - NSXPCConnectionInvalid</p></blockquote><p>同样分两种情况，一连接就出事的话，可能是 XPC 应用没有安装成功，排查方式是看 plist 和二进制文件有没有出现在它们该出现的路径里。<br>另一种情况，可能是客户端因为沙盒的原因而无法建立这条连接，控制台日志里会看到类似 <em>deny mach-lookup</em> 的信息，可以选择把 App Sandbox 关上（会没法上 Mac App Store 但不影响其他渠道的分发），真要打开沙盒的话有两条可以尝试的路径：</p><ol><li>想办法搞定 entitlements 的配置，可以参考<a href="https://christiantietze.de/posts/2015/01/xpc-helper-sandboxing-mac/" target="_blank" rel="noopener">这篇文章</a></li><li>应用内置另一个不在沙盒内的 XPC 应用，通过它去跟安装到系统里的 XPC 应用建立连接，具体的方式在官方的 <a href="https://developer.apple.com/library/archive/samplecode/EvenBetterAuthorizationSample/Introduction/Intro.html#//apple_ref/doc/uid/DTS40013768-Intro-DontLinkElementID_2" target="_blank" rel="noopener">EvenBetterAuthorizationSample</a>中有实现</li></ol><h2 id="总结">总结</h2><p>XPC 是 macOS 跨应用通讯中不得不面对的一种方案，可能出于各种原因最终的选择并不是它，但它确实是目前最简单可靠的实现了。</p><p>尽管我在网上已经查了非常多的资料，也还是在动手的过程中频频踩坑。写下这篇长文也是希望能把这条路尽可能填平，只是这个文章长度就有些一发不可收拾了😅。</p><h2 id="参考资料">参考资料</h2><ul><li><a href="http://www.tanhao.me/pieces/1623.html/" target="_blank" rel="noopener">通过ServiceManagement注册LaunchdDaemon | 老谭笔记</a></li><li><a href="https://nshipster.com/inter-process-communication/" target="_blank" rel="noopener">Inter-Process Communication - NSHipster</a></li><li><a href="https://developer.apple.com/library/archive/samplecode/EvenBetterAuthorizationSample/Listings/Read_Me_About_EvenBetterAuthorizationSample_txt.html#//apple_ref/doc/uid/DTS40013768-Read_Me_About_EvenBetterAuthorizationSample_txt-DontLinkElementID_17" target="_blank" rel="noopener">Read Me About EvenBetterAuthorizationSample.txt</a></li><li><a href="http://www.objc.io/issue-14/xpc.html" target="_blank" rel="noopener">XPC · objc.io</a></li><li><a href="https://rderik.com/blog/creating-a-launch-agent-that-provides-an-xpc-service-on-macos/" target="_blank" rel="noopener">Creating a Launch Agent that provides an XPC service on macOS using Swift</a></li><li><a href="https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingLaunchdJobs.html#//apple_ref/doc/uid/10000172i-SW7-BCIEDDBJ" target="_blank" rel="noopener">Creating Launch Daemons and Agents</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近需要在 Electron 项目上引入一个比较吃性能的大头功能，因为已经用 Objective-C 实现过一套稳定且性能也可接受的带 UI 方案了，所以计划看看能不能将这套现成的方案直接用到 Electron 里。但想要这么做就必须解决原生 UI 与 Electron 通讯的问题，再进一步，能不能让 Electron 以多进程的方式调起这个大头功能的 Demo 以节省掉绝大部分的重复工作呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文只研究了原生 XPC 通讯的部分，关于集成到 Electron 里还有哪些坑会在下一篇文章里讲讲&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="macOS" scheme="http://davidleee.com/tags/macOS/"/>
    
      <category term="XPC" scheme="http://davidleee.com/tags/XPC/"/>
    
      <category term="launchd" scheme="http://davidleee.com/tags/launchd/"/>
    
      <category term="SMJobBless" scheme="http://davidleee.com/tags/SMJobBless/"/>
    
  </entry>
  
  <entry>
    <title>SwiftUI 系列教程（4）—— UIKit 老相好在 SwiftUI 下的实现</title>
    <link href="http://davidleee.com/2019/08/15/swiftui-serial-tutorial-4/"/>
    <id>http://davidleee.com/2019/08/15/swiftui-serial-tutorial-4/</id>
    <published>2019-08-15T00:44:32.000Z</published>
    <updated>2020-05-05T03:43:31.445Z</updated>
    
    <content type="html"><![CDATA[<p>咱们最有意思的第四篇 SwiftUI 教程来啦！为什么说是“最有意思”的呢？因为按照约定，在这篇文章里我们会一起来看看用 SwiftUI 开发界面的快捷便利体现在什么地方。相信这会让许多苹果开发者们耳目一新。</p><blockquote><p>信了苹果教之后，每次有什么更新，我最期待的都是隐藏在大功能下的小细节，不知道有多少人跟我一样？</p></blockquote><a id="more"></a><h2 id="uitableview-uitableviewcell">UITableView &amp; UITableViewCell</h2><p>首先要说的是 UI 中最常见的列表：在萌新们刚开始学习 iOS 开发的时候，列表的实现也许就是其中一个劝退点。虽然 UIKit 的 API 已经做了比较友好的封装，但在这个前提下，开发者还必须要了解 UITableViewDelegate、UITableViewDataSource、Cell 与列表的关系，如果想要构造一个高性能的列表，还需要了解 Cell 的重用等等等等。</p><p>那么在 SwiftUI 里构造一个列表的操作是怎样的呢？我们分三步走：</p><ol><li>单个列表项的布局</li><li>准备数据</li><li>全部塞到一个列表里显示出来</li></ol><h3 id="列表项布局">列表项布局</h3><p>假设我们就构造一个最基础的列表项布局好了，一种 UIKit 直接就支持的显示模式：图片 + 标题 + 详情描述。</p><p>经过前面几篇文章的训练，我们对这种类型的 UI 构造应该熟门熟路了：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HStack</span>() &#123;</span><br><span class="line"><span class="type">Image</span>(systemName: <span class="string">"photo"</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="type">VStack</span>(alignment: .leading) &#123;</span><br><span class="line"><span class="type">Text</span>(<span class="string">"Title"</span>)</span><br><span class="line"><span class="type">Text</span>(<span class="string">"Detail description"</span>)</span><br><span class="line">.font(.subheadline)</span><br><span class="line">.foregroundColor(.secondary) <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>我们这里用了一张名为“photo”的图片，这个图片是 iOS 13 送给我们的，就是那个常见的图片占位符图标</li><li>UIKit 默认的详情描述用的是一种灰色的偏小一点的字体，我们直接用系统提供的属性就能模仿出来</li></ol><p>完成这一步之后，预览会是这个样子的：<br><img src="/uploads/swiftui-serial-tutorial-4/B1BE86B5-7B16-46DF-8DE8-C6AD6B23565D.png" alt></p><p>OK，学习完前面三篇文章之后，这里并没有什么新鲜的知识。下一步是准备数据。</p><h3 id="准备数据">准备数据</h3><p>这一步跟直接用 Swift 来实现没有太多区别，我就直接用 WWDC 视频里的数据结构了：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Room</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id = <span class="type">UUID</span>()</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> capacity: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> hasVideo: <span class="type">Bool</span> = <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> imageName: <span class="type">String</span> &#123; <span class="keyword">return</span> name &#125;</span><br><span class="line">    <span class="keyword">var</span> thumbnailName: <span class="type">String</span> &#123; <span class="keyword">return</span> name + <span class="string">"Thumb"</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> <span class="type">DEBUG</span></span><br><span class="line"><span class="keyword">let</span> testData = [</span><br><span class="line">    <span class="type">Room</span>(name: <span class="string">"Observation Deck"</span>, capacity: <span class="number">6</span>, hasVideo: <span class="literal">true</span>),</span><br><span class="line">    <span class="type">Room</span>(name: <span class="string">"Executive Suite"</span>, capacity: <span class="number">8</span>, hasVideo: <span class="literal">false</span>),</span><br><span class="line">    <span class="type">Room</span>(name: <span class="string">"Charter Jet"</span>, capacity: <span class="number">16</span>, hasVideo: <span class="literal">true</span>),</span><br><span class="line">    <span class="type">Room</span>(name: <span class="string">"Dungeon"</span>, capacity: <span class="number">10</span>, hasVideo: <span class="literal">true</span>),</span><br><span class="line">    <span class="type">Room</span>(name: <span class="string">"Panorama"</span>, capacity: <span class="number">12</span>, hasVideo: <span class="literal">false</span>),</span><br><span class="line">    <span class="type">Room</span>(name: <span class="string">"Oceanfront"</span>, capacity: <span class="number">8</span>, hasVideo: <span class="literal">false</span>),</span><br><span class="line">    <span class="type">Room</span>(name: <span class="string">"Rainbow Room"</span>, capacity: <span class="number">10</span>, hasVideo: <span class="literal">true</span>),</span><br><span class="line">    <span class="type">Room</span>(name: <span class="string">"Pastoral"</span>, capacity: <span class="number">7</span>, hasVideo: <span class="literal">false</span>),</span><br><span class="line">    <span class="type">Room</span>(name: <span class="string">"Elephant Room"</span>, capacity: <span class="number">1</span>, hasVideo: <span class="literal">true</span>)</span><br><span class="line">]</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><blockquote><p>这是我照着手敲的…如果有人知道哪里能弄来 WWDC 视频里的 Demo 项目源文件，请务必告诉我！</p></blockquote><p>到这一步为止还没什么不同，唯一比较不常见的可能是下面的 <code>testData</code>，这是方便我们调试用的假数据。</p><p>为了让 SwiftUI 的 <code>List</code> 能正常使用这个数据结构，我们还需要进行一点点改造：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Room</span>: <span class="title">Identifiable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id = <span class="type">UUID</span>()</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>List</code> 能使用的数据结构必须遵循 SwiftUI 里新加入的 <code>Identifiable</code> 协议，它要求这个数据结构里必须有一个符合 <code>Hashable</code> 协议的变量 <code>id</code>，我们这里用到的 <code>id</code> 是 <code>UUID</code> 类型的，本身已经满足这个要求，所以这里就不需要做更多修改了。</p><h2 id="列表显示">列表显示</h2><p>现在我们把 UI 和数据都准备好了，接下来就让它们组合起来，显示成一个列表！</p><p>对于 <code>List</code> 来说，列表项的默认布局就是水平方向的，所以我们可以直接 Cmd + 鼠标左键点击列表项 UI 里的 <code>HStack</code>，然后选择“Convert to List…”：<br><img src="/uploads/swiftui-serial-tutorial-4/D66F6EDE-FA01-489B-A8D3-4EDC81B5E18A.png" alt></p><blockquote><p>也许是 Xcode 的版本问题，在我这里显示的是“Embed in List”，但是最后的效果也是把选中了的 <code>HStack</code> 替换成了 <code>List</code></p></blockquote><p>得益于 <code>List</code> 构造方法里的数组类型参数，这段 UI 代码看起来就像是一个 for…in 的语句一样！回头看看预览，一个像模像样的列表已经出来了：<br><img src="/uploads/swiftui-serial-tutorial-4/38B4C8E5-0363-4674-AB1D-F078915AAF24.png" alt></p><p>接下来我们把准备好的数据对接上去：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> rooms: [<span class="type">Room</span>] <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line"><span class="type">List</span>(rooms) &#123; room <span class="keyword">in</span> <span class="comment">// 2</span></span><br><span class="line"><span class="type">Image</span>(room.thumbnailName)</span><br><span class="line"><span class="type">VStack</span>(alignment: .leading) &#123;</span><br><span class="line"><span class="type">Text</span>(room.name)</span><br><span class="line"><span class="type">Text</span>(<span class="string">"\(room.capacity) people"</span>)</span><br><span class="line">.font(.subheadline)</span><br><span class="line">.foregroundColor(.secondary)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> <span class="type">DEBUG</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListView_Previews</span>: <span class="title">PreviewProvider</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> previews: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ListView</span>(rooms: testData) <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><ol><li>先定义一个成员变量来保管数据，这一行为符合单一数据源的原则，这个数据是由调用方负责构建和传入的</li><li>把 <code>List</code> 的参数缓存我们真实的数组，然后把内部的硬编码数据换成传进来的数据</li><li>这里我们能看到预览视图的另一个好处，就是它完全模拟了真实情况下的代码逻辑，所以我们可以直接把上一步准备好的测试数据传进去</li></ol><p><img src="/uploads/swiftui-serial-tutorial-4/ACCBAF94-47D3-43B5-B924-5589A3F68C9D.png" alt></p><p>对比导入数据前后的界面，我们可以发现：默认情况下 Cell 的高度为 44pt，但是当塞进去的内容（比如图片）需要用到的高度大于这个值时，Cell 会自动调整自己的高度以适应内容的大小，并填充合适的间距来美化我们的列表项。这些小细节全都是免费的！</p><blockquote><p>预览里的图片当然是要我们事先导入的，因为跟 SwiftUI 没什么关系，所以这里也就跳过了这一步；而且我也懒得找图片来代替它们了，所以截图里看到的还是之前默认图的样子…</p></blockquote><h2 id="navigationviewcontroller-navigationbar">NavigationViewController &amp; NavigationBar</h2><p>孤零零的一个列表可能还不够有意思，一般来说列表是罗列概要数据用的，为了看到更完整的信息，我们通常会在用户点击列表项的时候跳转到一个详情界面，这就涉及到了界面导航的概念。</p><p>在原来的开发过程里，这时候我们就会实现一个 <code>NavigationViewController</code> 去把我们列表的视图控制器包裹起来，然后通过 push &amp; pop 这样的操作来实现界面的切换。</p><p>一起来看看 SwiftUI 是怎么做的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NavigationView</span> &#123; <span class="comment">// 1</span></span><br><span class="line">    <span class="type">List</span>(rooms) &#123; </span><br><span class="line">  <span class="comment">// 列表项的布局 </span></span><br><span class="line">  &#125;</span><br><span class="line">  .navigationBarTitle(<span class="type">Text</span>(<span class="string">"Rooms"</span>)) <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>我们用一个 <code>NavigationView</code> 把原本 <code>body</code> 里的全部内容包裹起来，就像我们原来用 <code>NavigationViewController</code> 把 <code>UIViewController</code> 包起来一个道理</li><li>然后，我们给 <code>NavigationView</code> 里的最外层子视图（在这里就是 <code>List</code>）加一个修饰器来配置导航栏的标题；注意我们这里传的是一个 <code>View</code>，也就是说它不仅限于显示文字，还可以是各种各样遵循 <code>View</code> 协议的视图</li></ol><p>完成这两步就可以在原有的视图之上显示一个导航栏了，不过还不够，我们要给列表项加上点击事件以便跳转到详情界面：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span>(rooms) &#123; </span><br><span class="line">    <span class="type">NavigationButton</span>(destination: <span class="type">Text</span>(room.name)) &#123;</span><br><span class="line">        <span class="comment">// 列表项的布局</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就只有一步：把原先用于布局列表项的代码用一个 <code>NavigationButton</code> 包起来，同时通过参数来指定这个导航事件的目的地。如例子的代码所示，实现的效果是点击列表项之后跳转到一个新的界面，界面中会居中显示房间的名字：<br><img src="/uploads/swiftui-serial-tutorial-4/IMG_E91EAE65D877-1.jpeg" alt></p><p>在加上 <code>NavigationButton</code> 之后，细心的童鞋们可能已经发现我们列表项的变化了：每一项的尾部都显示了一个小尖角，这是 iOS 里用于表示列表可以“点击查看更多”的常见元素了。</p><p>OK，用 Live Mode 运行一下预览，可以看到 SwiftUI 已经把转场过程中的标题动画处理好了，界面跳转、手势返回，全都丝般顺滑。</p><h2 id="表单">表单</h2><p>两个典型的常用组件我们已经看完了，接下来我们要实现一个更复杂一些的界面。往常要实现这么一个界面，虽说没有太多的智力活，但体力活是肯定少不了的。</p><p>一图胜千言，先来看看效果图：<br><img src="/uploads/swiftui-serial-tutorial-4/00BD9E2A-5EFD-4B06-86E1-E008B2FA3D55.png" alt><br>这种界面在用户注册的过程中也是挺常见的，借用一个前端的概念——它叫做“表单（Form）”。</p><h3 id="环境准备">环境准备</h3><p>接下来的代码里，有些类需要在 Xcode11 beta 4 版本上才能使用（其实我只知道 Beta 1 用不了，但具体哪个版本变化的就不清楚了），建议大家先更新一下 Xcode，不然就只能在文章里过过眼瘾啦。虽说 WWDC 展示的时候那个讲师明明就已经用上了，果然发布会要用特供版本在哪里都是惯例啊。</p><p>顺带一提，这种变化除了更新软件之后上手试试之外，还能在哪里看到呢？答案就是：官方文档！<br><img src="/uploads/swiftui-serial-tutorial-4/1BCC5384-E073-417C-A7AA-DF85A6253099.png" alt><br>在网页上找到你想看的 API 之后，把图示右上角的 “API Changes” 打开，选择要比较的版本（对于 Beta 版的软件，一般不会给出每个版本之间的变化，所以如上所述我也不知道 <code>Form</code> 这位兄弟是什么时候加进来的），然后就能在 “SDKs” 下面看到特定版本的需求是什么时候加进来的了。上面的截图就表示 macOS App 在 Xcode beta 4 版本上是无法使用 <code>Form</code> 的，因为它在 beta 5 才被正式加进来。</p><h3 id="需求梳理">需求梳理</h3><p>让我们用前三篇文章加上上面两个小节的知识，来判断一下要怎么实现它。</p><ol><li>我们要有一个大大的标题在界面左上角，也许是一个 <code>navigationBarTitle</code> 可以搞定的事情</li><li>标题下面的内容样式看起来像是一个 <code>UITableView</code></li><li>这个列表分了好几个 Section，有些 Section 有属于自己的标题、有些却没有</li><li>每一行都有自己的样式，可能要定制好几种 <code>UITableViewCell</code>，而最后一行起到的是按钮的作用，可以真的用按钮去实现，也可以用文字加上列表项点击事件的方式来做</li></ol><h3 id="那就动手吧">那就动手吧！</h3><p>看看上面的需求，每一点都不难，可它们胜在多啊！如果用 UIKit 去实现，光是把界面做出来就已经要花不少代码，更别说界面背后的数据逻辑了。</p><p>于是 SwiftUI 应运而生，这种简单元素组合而成的复杂页面正是它的强项！</p><p>我们直接看最终的界面代码，不过你也不用看得太仔细，我们会在下面把它一点点拆开来讲：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FormView</span> : <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">var</span> userInfo = <span class="type">UserInfo</span>() <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Form</span> &#123; <span class="comment">// 2</span></span><br><span class="line">            <span class="type">Section</span>(header: <span class="type">Text</span>(“账号注册”).font(.title)) &#123; <span class="comment">// 3</span></span><br><span class="line">                <span class="type">TextField</span>(“请输入用户名”, text: $userInfo.name)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Section</span>(header: <span class="type">Text</span>(“种族”).font(.headline)) &#123;</span><br><span class="line">                <span class="type">Picker</span>(selection: $userInfo.race, label: <span class="type">Text</span>(“种族”)) &#123; <span class="comment">// 4</span></span><br><span class="line">                    <span class="type">ForEach</span>(<span class="type">Race</span>.allCases) &#123; race <span class="keyword">in</span> <span class="comment">// 4.1</span></span><br><span class="line">                        <span class="type">Text</span>(race.name).tag(race)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;.pickerStyle(<span class="type">SegmentedPickerStyle</span>())</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Section</span>(header: <span class="type">Text</span>(“口味”).font(.headline)) &#123;</span><br><span class="line">                <span class="type">Toggle</span>(isOn: $userInfo.loveSweet) &#123; <span class="comment">// 5</span></span><br><span class="line">                    <span class="type">Text</span>(“喜好甜食”)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">Toggle</span>(isOn: $userInfo.loveSpicy) &#123;</span><br><span class="line">                    <span class="type">Text</span>(“爱吃辣”)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Section</span>(header: <span class="type">Text</span>(<span class="string">"年龄"</span>).font(.headline)) &#123;</span><br><span class="line">                <span class="type">Stepper</span>(value: $userInfo.age, <span class="keyword">in</span>: <span class="number">1</span>…<span class="number">120</span>)&#123; <span class="comment">// 6</span></span><br><span class="line">                    <span class="type">Text</span>(<span class="string">"年龄：\(userInfo.age)"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Section</span> &#123;</span><br><span class="line">                <span class="type">Button</span>(action: &#123;</span><br><span class="line">                    <span class="built_in">print</span>(“register with info: \(<span class="keyword">self</span>.userInfo)”)</span><br><span class="line">                &#125;) &#123;</span><br><span class="line">                    <span class="type">Text</span>(“<span class="type">Register</span>”)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管有前几篇文章的知识作为铺垫，但这段代码里还是有不少的新面孔啊。</p><h4 id="userinfo">UserInfo</h4><p><code>UserInfo</code> 的类型定义是这样的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UserInfo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> = “”</span><br><span class="line">    <span class="keyword">var</span> loveSweet = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> loveSpicy = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span> = <span class="number">18</span></span><br><span class="line">    <span class="keyword">var</span> race: <span class="type">Race</span> = .<span class="type">Yellow</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它其实就是一个普通的结构体，用来表示这位用户的个人信息。</p><p>在上一篇文章里我们讲过，如果要把一个完整的自定义对象绑定到视图上，那么这个对象的类型就需要遵循 <code>BindableObject</code> 协议。但在这个例子里，我们只是将对象的属性绑定到了视图上，我们只在意这些属性而不是对象这个整体，所以可以直接通过 <code>@State</code> 来进行对象局部的绑定。</p><h4 id="form">Form</h4><p>如前面的文档截图里所述：<code>Form</code> 是一个用于组合一系列数据入口的视图，比如应用的设置页面，或者是例子里的用户信息录入界面。</p><p>话说回来，这么多新玩具，在开发过程中怎么知道有没有可以对症下药的呢？其实它们都整整齐齐码在了原来我们用于挑选 xib 或者 storyboard 组件的地方，我们可以用 Cmd + L 把这个界面弄出来：<br><img src="/uploads/swiftui-serial-tutorial-4/%E6%88%AA%E5%B1%8F2019-08-13%E4%B8%8B%E5%8D%8810.18.33.png" alt></p><h4 id="section">Section</h4><p>顾名思义，这是一个用于分区的控件，它也可以被用在 <code>List</code> 里面，就组成了所谓的 “SectionList”，例如通讯录里按首字母分区的样式。</p><p>例子中的 <code>Section</code> 用于给 <code>Form</code> 里的不同数据进行分类，并提供统一样式的 Header，它显示的内容也可以通过构造方法里的 <code>header</code> 参数来进行修改。</p><h4 id="picker">Picker</h4><p>这是目前为止碰到的最复杂的组件了，它有点类似于 UIKit 里的 <code>PickerView</code>，不过它是更广义的“选择器”，在样式上也会有更多的变化可供选择，比如例子里的 <code>SegmentedPickerStyle</code>（有些样式是平台相关的，在使用的时候要留意编译器的提醒）。</p><p>其实只要明白 <code>$</code> 变量的含义，这个构造方法也很好理解，就是把选择器里选中的内容与 <code>userInfo</code> 对象里的 <code>race</code> 属性绑定起来。</p><h5 id="foreach">ForEach</h5><p>这个写法本质上跟往 <code>List</code> 的构造方法里传一个数组的意思差不多，这样拆开来可以让列表型视图的内容样式更丰富，感兴趣的童鞋们可以详细看看<a href="https://developer.apple.com/videos/play/wwdc2019/204/" target="_blank" rel="noopener">这个视频</a>，这里就不展开讲了。</p><p>其中的 <code>Race</code> 是一个枚举类型，它的实现也很有意思：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Race</span> : <span class="title">CaseIterable</span>, <span class="title">Hashable</span>, <span class="title">Identifiable</span> </span>&#123; <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Yellow</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Black</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">White</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Mixed</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> id: <span class="type">UUID</span> &#123; <span class="type">UUID</span>() &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> .<span class="type">Yellow</span>: <span class="keyword">return</span> <span class="string">"黄种人"</span></span><br><span class="line">            <span class="keyword">case</span> .<span class="type">Black</span>: <span class="keyword">return</span> <span class="string">"黑种人"</span></span><br><span class="line">            <span class="keyword">case</span> .<span class="type">White</span>: <span class="keyword">return</span> <span class="string">"白种人"</span></span><br><span class="line">            <span class="keyword">case</span> .<span class="type">Mixed</span>: <span class="keyword">return</span> <span class="string">"混血"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子里的 <code>Race.allCase</code> 是遵循 <code>CaseIterable</code> 协议带给我们的一个福利，意思是“枚举所有可能的值”，于是我们就可以把它用在需要数组类型参数的地方了。</p><p>而 <code>Hashable</code> 和 <code>Identifiable</code> 是为了让这个枚举的对象可以被作为唯一标识符来使用。之所以这样做，是因为 <code>Picker</code> 的列表项必须要设置 <code>tag</code> 以区分用户的选择，于是例子中就直接用了枚举对象本身来作为选项的 <code>tag</code>。</p><h4 id="toggle">Toggle</h4><p>这个控件看名字就该知道是干嘛用的了，正如 Swift 4.2 之后的布尔值有了一个叫 <code>toggle</code> 的语法糖，这个控件就是用来标识开关状态的，也就是原来的 <code>UISwitch</code>。</p><h4 id="stepper">Stepper</h4><p>直译过来应该叫“步进器”。对于重视用户体验的苹果来说，这样看上去简单，但要正确实现逻辑还需要费点心思的小玩意儿，当然是选择封装成一个系统组件！相信看了前面那些五花八门的组件之后，这个 <code>Stepper</code> 的用法也是不需要再多加解释了。</p><h3 id="小结">小结</h3><p>好了，这短短不到40行的代码（好吧，算上那个结构体和枚举也有60行左右了），就已经实现了我们这一小节开头截图里的那种表单效果。不仅如此，SwiftUI 还默默为我们做了大量的优化工作，我可以拍胸脯说这些代码在效率上也会是远超 UIKit 版本的。</p><h2 id="总结">总结</h2><p>四篇文章下来，这个系列的 SwiftUI 教程也算是告一段落了。显然这仅仅是一个入门教程，更多有意思的新元素还在后面等着你。</p><p>文章里面的例子都是通过 Xcode 的新功能 Canvas 预览和截图出来的，目前它也只有个 iPhone 的外框样式，这难免有点限制了我们的想象，所以我必须要在最后提醒大家一句：</p><p><strong>用 SwiftUI 构建的界面天生就是跨全苹果平台的！</strong></p><p>也就是说，之前例子里的<strong>所有代码放到 macOS 和 watchOS 上都是适用的</strong>！（当然要除掉跟 UIKit 混合的那部分）而且所有界面的样式都会根据平台的不同而自动调整，几乎不需要开发者的介入就可以做到全平台适配！</p><p>写到这的时候我居然感觉挺兴奋的，就像是回到了刚刚接触 Xcode 和在 iOS 5 上做开发的那个年代。那个时候 Android 已经有好些机型要适配，而我只要把应用在我手里的 iPhone 上跑顺就八九不离十了:)</p><h2 id="参考文章">参考文章</h2><ul><li><a href="https://developer.apple.com/videos/play/wwdc2019/204/" target="_blank" rel="noopener">Introducing SwiftUI: Building Your First App - WWDC 2019 - Videos - Apple Developer</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2019/216/" target="_blank" rel="noopener">SwiftUI Essentials - WWDC 2019 - Videos - Apple Developer</a></li><li><a href="https://onevcat.com/2019/06/swift-ui-firstlook-2/" target="_blank" rel="noopener">SwiftUI 的一些初步探索 (二)</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;咱们最有意思的第四篇 SwiftUI 教程来啦！为什么说是“最有意思”的呢？因为按照约定，在这篇文章里我们会一起来看看用 SwiftUI 开发界面的快捷便利体现在什么地方。相信这会让许多苹果开发者们耳目一新。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;信了苹果教之后，每次有什么更新，我最期待的都是隐藏在大功能下的小细节，不知道有多少人跟我一样？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://davidleee.com/tags/Swift/"/>
    
      <category term="SwiftUI" scheme="http://davidleee.com/tags/SwiftUI/"/>
    
      <category term="List" scheme="http://davidleee.com/tags/List/"/>
    
      <category term="NavigationView" scheme="http://davidleee.com/tags/NavigationView/"/>
    
      <category term="NavigationButton" scheme="http://davidleee.com/tags/NavigationButton/"/>
    
      <category term="Form" scheme="http://davidleee.com/tags/Form/"/>
    
      <category term="Picker" scheme="http://davidleee.com/tags/Picker/"/>
    
      <category term="Toggle" scheme="http://davidleee.com/tags/Toggle/"/>
    
      <category term="Section" scheme="http://davidleee.com/tags/Section/"/>
    
      <category term="Stepper" scheme="http://davidleee.com/tags/Stepper/"/>
    
  </entry>
  
  <entry>
    <title>SwiftUI 系列教程（3）—— SwiftUI 数据流</title>
    <link href="http://davidleee.com/2019/07/25/swiftui-serial-tutorial-3/"/>
    <id>http://davidleee.com/2019/07/25/swiftui-serial-tutorial-3/</id>
    <published>2019-07-25T08:41:24.000Z</published>
    <updated>2020-05-05T03:43:31.445Z</updated>
    
    <content type="html"><![CDATA[<p>通过前两篇文章（SwiftUI 系列教程 <a href="/2019/06/12/swiftui-serial-tutorial-1/" title="（1）">（1）</a> 和 <a href="/2019/07/08/swiftui-serial-tutorial-2/" title="（2）">（2）</a>），我们已经看到了 SwiftUI 是怎么运作的了，对于常规的界面元素来说，使用 SwiftUI 确实能带来不小的生产力提升。但是在前面的例子里，我们用到的数据全都是写死的，这跟复杂多变的真实需求可不大一样。这篇文章我们就来了解一下，SwiftUI 里用到的全新的数据流模型。</p><blockquote><p>相比起前两篇实操文，这篇文章可能会比较干，请大家看文章之前先访问一下饮水机。</p></blockquote><a id="more"></a><h2 id="先看看别人家是怎么做的">先看看别人家是怎么做的</h2><h3 id="老东家">老东家</h3><p>学习过斯坦福公开课的小伙伴们应该对下面这张图片很有印象了：<br><img src="/uploads/swiftui-serial-tutorial-3/mvc1.png" alt></p><p>这是 iOS 自出道以来就非常推崇的，可谓是“官方建议”的数据流模型，也就是大家都熟知的 MVC 模式。</p><p>从 GUI 开始兴起以来，基于职责分离的思想，工程师们慢慢把管理用户界面的 View 和管理用户数据的 Model 给区分了开来；而从 Smalltalk 的某个版本开始，为了进一步降低图形应用程序的管理难度，设计出了 MVC 模式。MVC 的出现主要是为了解决这两个问题：</p><ol><li>如何管理响应用户操作的业务逻辑</li><li>View 如何同步 Model 的变化</li></ol><p>解决这两个问题也是大多数为现代图形界面应用程序而诞生的设计模式们的目标，比如 MVVM、MVP。</p><h3 id="隔壁前端家">隔壁前端家</h3><p>因为有着一段不长不短的 React Native 开发经历（目前还在做着），所以从这个角度看过去，比较成熟的方案是 Redux + React Redux。</p><p>Redux 是专为 JavaScript 软件打造的一个可预测状态容器。听起来很厉害的样子，其实主要是做了三个事情：</p><ol><li>把 Model 层的数据统一放到一个地方</li><li>约定只能通过特定的手段去改变数据，除此之外，数据就是只读的</li><li>约定改变数据的操作必须是纯函数</li></ol><p>这样做了之后，我们就可以确定这个数据源是可以真实反应我们的应用状态的，所以叫做“可预测状态容器（Predictable State Container）”。</p><p>然后 React Redux 就好理解了，它的任务是建立一套机制，让上述的状态一一绑定到视图上，实现一条双向更新的通道。</p><blockquote><p>Redux 和 React Redux 都是 Redux 官方出品，所以质量还是比较有保证的。下面这两篇文章应该可以给大家技术选型的时候提供一些支持：<br><a href="https://redux.js.org/introduction/motivation" target="_blank" rel="noopener">Motivation · Redux</a><br><a href="https://react-redux.js.org/introduction/why-use-react-redux" target="_blank" rel="noopener">Why Use React Redux? · React Redux</a></p></blockquote><h2 id="swift-的实现">Swift 的实现</h2><p>如果你觉得 SwiftUI 在构造界面时用到的声明式语法跟 JSX 的相似度很高的话，那在介绍完它的数据绑定逻辑之后，你肯定会再一次把它拿来跟 JavaScript 做比较了。</p><p>SwiftUI 中引入了一个关键字 <code>@State</code> 来作为数据绑定的标识。当一个被绑定的数据被改变时，相关联的视图会重新计算它自己的 <code>body</code> 内容；反过来，当视图主动去改变绑定在数据上的属性时，这个数据也会随之变化。这种双向绑定的机制就像 JSX + Redux + React Redux 的组合拳，只不过 SwiftUI 自己就把这些事情给做了。</p><p>但是，凭什么 SwiftUI 用几个关键字就实现了别人整整两个开源库的功能？其实这得益于 Swift 5.1 的新功能——属性包装（Property Wrappers）。</p><h3 id="深挖一点点">深挖一点点</h3><p>在 2019 年3月份的时候，Swift 核心团队里的成员已经透露出了一个作用类似于 <code>lazy</code> 关键字的新功能，那个时候它被称为“属性代理”（Property Delegates）。</p><p>举个例子，延迟初始化可谓是编程里的一种美德，在 Swift 的世界里，除了直接用 <code>lazy</code>，我们也可以用一个私有属性加上一个作为访问器的 Computed Property 来实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> _lazyProp: <span class="type">Prop?</span></span><br><span class="line"><span class="keyword">var</span> lazyProp: <span class="type">Prop</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> value = _lazyProp &#123; <span class="keyword">return</span> value &#125;</span><br><span class="line">        <span class="keyword">let</span> initialValue = ... <span class="comment">// 初始化数据</span></span><br><span class="line">        _lazyProp = initialValue</span><br><span class="line">        <span class="keyword">return</span> initialValue</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> &#123;</span><br><span class="line">        _lazyProp = newValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如今，Property Wrappers 为我们提供了第三条路可走，不仅如此，它还承诺会为开发者们提供了一种实现类似 <code>lazy</code> 关键字用法的途径。</p><p>在 SwiftUI 的功能提议 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0258-property-wrappers.md" target="_blank" rel="noopener">SE-0258</a> 里可以看到，Property Wrappers 的主要目的就是为了避免开发者重复写出上面那种固定模式的代码。既然这种写法是比较固定的，那么就应该定义出一种机制，来把各种固定写法定义成一个个的工具库。</p><h3 id="官方的解决方案">官方的解决方案</h3><p>还是用 <code>lazy</code> 的例子，怎么用 Property Wrappers 来实现一个同样的功能呢？比如实现一个作用相同的 <code>@Lazy</code> 属性？</p><p>官方给出的解决方案是这样的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@propertyWrapper</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Lazy</span>&lt;<span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> uninitialized(() -&gt; <span class="type">Value</span>)</span><br><span class="line">  <span class="keyword">case</span> initialized(<span class="type">Value</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(wrappedValue: <span class="meta">@autoclosure</span> @escaping () -&gt; <span class="type">Value</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span> = .uninitialized(wrappedValue)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> wrappedValue: <span class="type">Value</span> &#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">get</span> &#123;</span><br><span class="line">      <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> .uninitialized(<span class="keyword">let</span> initializer):</span><br><span class="line">        <span class="keyword">let</span> value = initializer()</span><br><span class="line">        <span class="keyword">self</span> = .initialized(value)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">      <span class="keyword">case</span> .initialized(<span class="keyword">let</span> value):</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> &#123;</span><br><span class="line">      <span class="keyword">self</span> = .initialized(newValue)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此一来，下面这种变量声明</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">Lazy</span> <span class="keyword">var</span> foo = <span class="number">123</span></span><br></pre></td></tr></table></figure><p>就会被展开成这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> _foo: <span class="type">Lazy</span>&lt;<span class="type">Int</span>&gt; = <span class="type">Lazy</span>&lt;<span class="type">Int</span>&gt;(wrappedValue: <span class="number">123</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">var</span> foo: <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">get</span> &#123; <span class="keyword">return</span> _foo.wrappedValue &#125;</span><br><span class="line">  <span class="keyword">set</span> &#123; _foo.wrappedValue = newValue &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>调用了 <code>Lazy</code> 的 <code>init</code> 方法来进行初始化一个私有变量，它的类型是 <code>Lazy&lt;Int&gt;</code></li><li>通过把原变量包装成一个 Computed Value 的方式来对接 <code>wrappedValue</code> 里提供的真正的逻辑实现</li></ol><p>不仅如此，既然 <code>@Lazy</code> 是一个 <code>enum</code> ，那它本身就可以定义五花八门的公开方法，而每一个被 <code>@propertyWrapper</code> 标记的类型都可以通过定义一个 <code>projectedValue</code> 属性来实现一些骚操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@propertyWrapper</span><br><span class="line">enum Lazy&lt;Value&gt; &#123;</span><br><span class="line">    // ... 内容跟前面一样 ...</span><br><span class="line"></span><br><span class="line">    // 定义一个重置的方法，把 @Lazy 标记的变量还原为一个不同的初始值</span><br><span class="line">    public mutating func reset(_ newValue:  @autoclosure @escaping () -&gt; Value) &#123;</span><br><span class="line">        self = .uninitialized(newValue)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public var projectedValue: Self &#123;</span><br><span class="line">        get &#123; self &#125;</span><br><span class="line">        set &#123; self = newValue &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明了 <code>projectedValue</code> 之后 ，我们就自动获得了一个带 <code>$</code> 符号的分身用来访问我们 <code>projectedValue</code> 的 getter，从而调用到里面的方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">Lazy</span> <span class="keyword">var</span> foo = <span class="number">123</span></span><br><span class="line">$foo.reset(<span class="number">456</span>)</span><br></pre></td></tr></table></figure><p>上面那句声明变量的语句，会展开成这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> _foo: <span class="type">Lazy</span>&lt;<span class="type">Int</span>&gt; = <span class="type">Lazy</span>&lt;<span class="type">Int</span>&gt;(wrappedValue: <span class="number">123</span>)</span><br><span class="line"><span class="keyword">var</span> foo: <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">get</span> &#123; <span class="keyword">return</span> _foo.wrappedValue &#125;</span><br><span class="line">  <span class="keyword">set</span> &#123; _foo.wrappedValue = newValue &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 上面跟原来一样，下面是添加了 projectedValue 之后新增的 ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> $foo: <span class="type">Lazy</span>&lt;<span class="type">Int</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">get</span> &#123; _foo.projectedValue &#125;</span><br><span class="line">  <span class="keyword">set</span> &#123; _foo.projectedValue = newValue &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其实给 <code>Lazy</code> 添加 <code>extension</code> 也可以达到类似的目的，不过这时候的方法调用就要通过 <code>_foo</code> 来进行，而不是 <code>$foo</code> 了</p></blockquote><h2 id="说回-swiftui">说回 SwiftUI</h2><p>SwiftUI 的数据流模型是基于下面两点原则来构建的：</p><ol><li>Data Access as a Dependency</li><li>Source of Truth</li></ol><p>我们展开来看：</p><h3 id="data-access-as-a-dependency">Data Access as a Dependency</h3><p>在多数情况下，我们的视图是需要根据某些状态来动态变化显示样式的，比如对于 <code>Switch</code> 来说，改变它的 <code>on</code> 属性可以让它显示当前的开关状态。</p><p>对于这种情况，<code>on</code> 属性就应该作为 <code>Switch</code> 的依赖而存在，否则这个控件除了长得好看就一无是处了。所以在 SwiftUI 里，属性会被描述为视图的依赖，这意味着我们的注意力可以从属性和视图的关联里抽身出来，集中在建立更好的用户体验上。</p><h3 id="source-of-truth">Source of Truth</h3><p>同一组视图里的数据都是来自于同一个数据源的（甚至整个应用的数据都来自于同一个数据源，Redux 就是这么做的）。</p><p>对于开发者来说，数据源的不唯一意味着视图状态的不唯一。可以想象，位于同一视图层级的两个视图要共用某些参数时，数据来源的不唯一会为编程带来多大的麻烦。<br><img src="/uploads/swiftui-serial-tutorial-3/D1B04594-7FAA-4391-AC05-CBC2BF839DD8.png" alt></p><p>SwiftUI 对这种情况的处理是，让父视图作为子视图的唯一数据源：<br><img src="/uploads/swiftui-serial-tutorial-3/4CDDC5EC-0093-46EE-A17A-F38972875AF8.png" alt></p><blockquote><p>做过前端 UI 开发的童鞋们应该很熟悉这套操作了，这就是把 State 上提成 Props 嘛，目的是让子视图尽可能的简单，最好的情况下子视图本身应该是无状态的。</p></blockquote><p>于是我们可以得出，基于这两个原则来实现的数据流模型已经完全不同于我们以往的理解，我们需要重新定义我们所认识的视图：<strong>视图要体现的是一个个独立的状态，而不是一系列连续的事件</strong> 。</p><h2 id="实践出真知">实践出真知</h2><p>说了这么多，我们来实际改造一段代码试试。</p><p>假设我们要实现一个播放器的播放按钮，需求是它要能反应播放状态：</p><ol><li>没有音频播放时，它表现为播放按钮</li><li>在有音频播放时，它表现为暂停按钮</li></ol><p>我们通过给按钮设置不同的图片来区分这两个状态，按照之前的知识，我们能轻松写下这样的代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PlayerView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> isPlaying: <span class="type">Bool</span> = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Button</span>(action: &#123;</span><br><span class="line">            <span class="keyword">self</span>.isPlaying = !<span class="keyword">self</span>.isPlaying</span><br><span class="line">        &#125;) &#123;</span><br><span class="line">            <span class="keyword">self</span>.isPlaying ? <span class="type">Text</span>(<span class="string">"Pause"</span>) : <span class="type">Text</span>(<span class="string">"Play"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等等，我们这个 <code>PlayerControl</code> 是 <code>struct</code> 类型的，不能这样直接改变属性的值：<br><img src="/uploads/swiftui-serial-tutorial-3/29C7C479-1EBA-47FD-B9C5-1037A6FC8E17.png" alt></p><p>其中一个安抚编译器的方法是，用一个临时变量来替代 <code>self</code>，我们顺便把布尔值取反的操作也简化一下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PlayerView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> isPlaying: <span class="type">Bool</span> = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Button</span>(action: &#123;</span><br><span class="line">            <span class="keyword">var</span> tempSelf = <span class="keyword">self</span> <span class="comment">// 安抚编译器</span></span><br><span class="line">            tempSelf.isPlaying.toggle() <span class="comment">// Implemented in Swift 4.2</span></span><br><span class="line">        &#125;) &#123;</span><br><span class="line">            <span class="keyword">self</span>.isPlaying ? <span class="type">Text</span>(<span class="string">"Pause"</span>) : <span class="type">Text</span>(<span class="string">"Play"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，这样一改，那句临时变量赋值语句就成为了夜空中最亮的星，怎么看怎么别扭…</p><p>那接下来就轮到 SwiftUI 里定义的 Property Wrappers 出场了，这段代码可以改写成这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PlayerView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> isPlaying: <span class="type">Bool</span> = <span class="literal">false</span> <span class="comment">// 加上 `@State` 标记</span></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Button</span>(action: &#123;</span><br><span class="line">            <span class="keyword">self</span>.isPlaying.toggle() <span class="comment">// 可以直接改动 `self` 里的变量了</span></span><br><span class="line">        &#125;) &#123;</span><br><span class="line">            <span class="keyword">self</span>.isPlaying ? <span class="type">Text</span>(<span class="string">"Pause"</span>) : <span class="type">Text</span>(<span class="string">"Play"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>似乎…也没太大变化啊，代码量也不见少，只不过是省掉了临时变量了？<br>这是因为，这样的写法还是根据我们的惯常思维来走，回忆一下上面讲到的 SwiftUI 数据模型原则：</p><ol><li>以依赖的形式访问数据</li><li>单一数据源</li></ol><p>例子里的写法貌似符合了“单一数据源”，但是却把“以依赖的形式访问数据”晾在了一边。我们来进一步改造这个例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PlayerView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> isPlaying: <span class="type">Bool</span> = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">PlayButton</span>(isPlaying: $isPlaying) <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PlayButton</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">Binding</span> <span class="keyword">var</span> isPlaying: <span class="type">Bool</span> <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Button</span>(action: &#123;</span><br><span class="line">            <span class="keyword">self</span>.isPlaying.toggle()</span><br><span class="line">        &#125;) &#123;</span><br><span class="line">            <span class="type">Text</span>(isPlaying ? <span class="string">"Pause"</span> : <span class="string">"Play"</span>) <span class="comment">// 3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>使用 <code>@State</code> 标记的变量会自动生成一个以 <code>$</code> 作为前缀的新变量，这个新变量本质上是一个 Computed Value，实现了双向绑定的机制，也就是说当 <code>PlayButton</code> 内部改变了这个变量之后，<code>PlayerView</code> 里的 <code>isPlaying</code> 也会发生相同的变化</li><li>通过声明变量为 <code>@Binding</code>，我们就告诉了编译器这个变量是从外部传入的可以被绑定的参数，相当于 React 里的 <code>Props</code> 声明</li><li>我们将 <code>isPlaying</code> 作为 <code>Text</code> 的依赖来使用，对于 <code>PlayButton</code> 来说，变量的声明和使用都是在一个结构体里面完成的，这就意味着这个视图与 <code>PlayerView</code> 是解偶的</li></ol><blockquote><p><code>@Binding</code> 具有以下两种特性：</p><ol><li>在不持有变量的前提下进行变量的读写</li><li>可以从 <code>@State</code> 变量中推导出来</li></ol></blockquote><p>现在回忆一下，在 SwiftUI 之前我们是怎么实现类似逻辑的？在不知不觉中，我们已经舍弃了 ViewController，让视图直接成为了数据的载体。甚至可以说，在 SwiftUI 里，视图就是为数据服务的。</p><blockquote><p><code>@State</code> 标记的属性一旦变化，会引起依赖它的视图、这个视图的父视图和它的同级视图一起做<strong>必要的</strong>变化。为什么要强调<strong>必要的</strong>？因为相较于繁重的渲染工作来说，对声明式语法描述出来的数据结构进行比较并不消耗什么性能，SwiftUI 会在重新渲染前对视图状态进行比较，尽可能地去避免无谓的绘制，所以不需要担心性能的问题。<br>类似于 <code>React.PureComponent</code> 提供的逻辑。</p></blockquote><h2 id="小结">小结</h2><p>基于这套数据模型实现出来的数据流可以用下面这张图片来表示：<br><img src="/uploads/swiftui-serial-tutorial-3/870E1C27-D2D8-41AD-BBF2-66AABA4BD04A.png" alt><br>要知道，Action 不只可以来自于用户交互，它还可以来自我们自己实现的触发器、消息推送等等，而不管来源是什么，我们实现的逻辑都可以理解并做出同样的处理。</p><p>这样的数据流模式确保了数据的流动永远是单向的，而 State 在这里充当了视图变化的唯一数据源，让视图的更新是可预测和易懂的。</p><blockquote><p>当然，<code>@State</code> 也有它的局限性，比如它无法正确处理我们自己定义的对象类型的属性变化，所以我们还需要 BindableObject 协议来从旁辅助，这里就不继续展开了。</p></blockquote><p>了解了视图基础和数据流模型，相信大家都已经看到了 SwiftUI 的魅力，余下的细节就需要各位开发者在实际应用中发掘了。下一讲就让我们来把这个魅力继续扩大，一起来实际看看 SwiftUI 还给我们的开发带来了哪些好处。</p><h2 id="参考文章">参考文章</h2><ul><li><a href="https://www.linuxidc.com/Linux/2015-10/124622.htm" target="_blank" rel="noopener">界面之下：还原真实的 MVC、MVP、MVVM 模式</a></li><li><a href="https://redux.js.org/introduction/motivation" target="_blank" rel="noopener">Motivation · Redux</a></li><li><a href="https://react-redux.js.org/introduction/why-use-react-redux" target="_blank" rel="noopener">Why Use React Redux? · React Redux</a></li><li><a href="https://developer.apple.com/documentation/swiftui/state_and_data_flow" target="_blank" rel="noopener">State and Data Flow | Apple Developer Documentation</a></li><li><a href="https://nshipster.com/propertywrapper/" target="_blank" rel="noopener">Swift Property Wrappers - NSHipster</a></li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0258-property-wrappers.md" target="_blank" rel="noopener">swift-evolution/0258-property-wrappers.md at master · apple/swift-evolution · GitHub</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2019/226/" target="_blank" rel="noopener">Data Flow Through SwiftUI - WWDC 2019 - Videos - Apple Developer</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过前两篇文章（SwiftUI 系列教程 &lt;a href=&quot;/2019/06/12/swiftui-serial-tutorial-1/&quot; title=&quot;（1）&quot;&gt;（1）&lt;/a&gt; 和 &lt;a href=&quot;/2019/07/08/swiftui-serial-tutorial-2/&quot; title=&quot;（2）&quot;&gt;（2）&lt;/a&gt;），我们已经看到了 SwiftUI 是怎么运作的了，对于常规的界面元素来说，使用 SwiftUI 确实能带来不小的生产力提升。但是在前面的例子里，我们用到的数据全都是写死的，这跟复杂多变的真实需求可不大一样。这篇文章我们就来了解一下，SwiftUI 里用到的全新的数据流模型。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;相比起前两篇实操文，这篇文章可能会比较干，请大家看文章之前先访问一下饮水机。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://davidleee.com/tags/Swift/"/>
    
      <category term="Redux" scheme="http://davidleee.com/tags/Redux/"/>
    
      <category term="SwiftUI" scheme="http://davidleee.com/tags/SwiftUI/"/>
    
      <category term="MVC" scheme="http://davidleee.com/tags/MVC/"/>
    
      <category term="React" scheme="http://davidleee.com/tags/React/"/>
    
      <category term="Property Wrappers" scheme="http://davidleee.com/tags/Property-Wrappers/"/>
    
      <category term="State" scheme="http://davidleee.com/tags/State/"/>
    
      <category term="Binding" scheme="http://davidleee.com/tags/Binding/"/>
    
  </entry>
  
  <entry>
    <title>SwiftUI 系列教程（2）—— 与 UIKit 结合的自定义视图</title>
    <link href="http://davidleee.com/2019/07/08/swiftui-serial-tutorial-2/"/>
    <id>http://davidleee.com/2019/07/08/swiftui-serial-tutorial-2/</id>
    <published>2019-07-08T03:15:32.000Z</published>
    <updated>2020-05-05T03:43:31.444Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="/2019/06/12/swiftui-serial-tutorial-1/" title="上一篇文章">上一篇文章</a>中，我们了解了 SwiftUI 的 <code>Text</code>  组件，并通过 <code>Stack</code> 系列的组件对内容进行了一些简单的布局。在这篇文章里，我们会认识一个全新的图片组件，并且会尝试利用这两篇文章的知识，结合 MapKit 框架，来实现一个简单的地点详情界面。</p><a id="more"></a><blockquote><p>写完第一篇文章之后，本职的开发任务突然进入了紧张的预发布阶段，搞得早就写好的第二篇文章拖了这么久才完成润色和发布，看来“全网最早”要丢了…</p></blockquote><h2 id="自定义图片视图">自定义图片视图</h2><p>首先把一张地标图片放到 <em>Assets.xcassets</em> 里去，我在百度找了张广州塔的照片：<br><img src="/uploads/swiftui-serial-tutorial-2/BF6A8678-F10F-4633-A932-94B781BE73F9.png" alt></p><p>然后，我们要为新的图片视图创建一个新的类，就放在上一篇文章的 <em>ContentView.swift</em> 旁边好了。新建文件的时候，选择 <strong>SwiftUI View</strong>：<br><img src="/uploads/swiftui-serial-tutorial-2/8A140752-2AE7-40E5-B320-F9DF7ADECE5C.png" alt></p><p>取个名字叫 CircleImage，因为我们将要在这里把广州塔裁剪成一个圆。新建的代码内容跟上一章看到的一样，我们把 <code>Text</code> 改成 <code>Image</code>，然后把图片的名字传进去，直接就可以通过预览在画布上看到我们的图片了：<br><img src="/uploads/swiftui-serial-tutorial-2/03DBC394-DA28-4686-87CA-117FCAC32CC6.png" alt></p><p>接下来我们在代码里给它加上一个圆形的裁剪。原来的做法有很多了，最快速的做法应该是操作 <code>clipsToBounds</code> 和 <code>cornerRadius</code>，给图片加上长度等于一半宽高的圆角，这还得要求图片是正方形的才能达到满意的显示效果。</p><p>而在 SwiftUI 里，这就是一句话的事情：<br><img src="/uploads/swiftui-serial-tutorial-2/D1D63EE5-2169-40D0-ACAB-F68AE4EED5EB.png" alt></p><p><code>.clipShape()</code> 给图片加了个裁剪的形状，其中 <code>Circle</code> 类型是一个用来当作遮罩的图形，你也可以给它加上填充色或者描边来单独使用，类似于以往通过 <code>CALayer</code> 去实现的效果。</p><p>但这也太大了，我们的屏幕装不下，我们可以再加两行代码，把图片缩放到一个合适的大小：<br><img src="/uploads/swiftui-serial-tutorial-2/E0470CA5-E465-4D53-8E1A-555C180DED64.png" alt></p><blockquote><p>讲道理，这里设置的宽高应该是一样的，毕竟是个圆嘛…但是我懒得重新截图了，各位童鞋自己调整一下数值就可以了</p></blockquote><p>为了让图片本身在不同背景下都能凸显出来，我们再给它加个描边，这要通过 <code>overlay()</code> 方法去实现；也许再加个阴影吧，用到的是 <code>shadow()</code> 方法；最后出来的效果是这样的：<br><img src="/uploads/swiftui-serial-tutorial-2/1263812F-2159-4AD5-9B21-50A314CFA99C.png" alt></p><p>是不是醒目多啦？</p><blockquote><p>每当做完一个新视图，我就想对比一下用老方法实现同样的效果有什么不同…</p></blockquote><h2 id="在-swiftui-里使用-uikit">在 SwiftUI 里使用 UIKit</h2><p>不知道大家发现了没有，我们在 SwiftUI 里用到的视图全部都是 <code>struct</code>，这意味着它们跟我们原本熟悉的 UIKit 是两套不同的机制，那难道以前开发的视图就完全用不上了吗？</p><p>答案是可以的。</p><p>要在 SwiftUI 里使用 UIView 的子类，只需要把它用一个遵循 <code>UIViewRepresentable</code> 协议的 SwiftUI 视图包裹起来即可。</p><blockquote><p>这里举的是 UIKit 的例子，但同样也适用于 AppKit 和 WatchKit。</p></blockquote><p>我们再来创建一个新的 SwiftUI View 来做我们的地图界面，但这一次，我们要改一下内容视图的协议：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"><span class="keyword">import</span> MapKit <span class="comment">// 引入 MapKit</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MapView</span> : <span class="title">UIViewRepresentable</span> </span>&#123; <span class="comment">// 把这里的协议改掉</span></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(“<span class="type">Hello</span> <span class="type">World!</span>”)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后你会发现 Xcode 在 <code>UIViewRepresentable</code> 这里报错了，因为这个协议下有两个必须实现的方法：</p><ol><li><code>makeUIView(context:)</code> 用来创建我们的 <code>MKMapView</code></li><li><code>updateUIView(_:context:)</code> 用来进行视图的配置，并响应后续可能的变化</li></ol><p>那下面我们就来实现一下。再加新代码之前，可以把已经用不上的 <code>body</code> 部分先删掉了。</p><p>对于 <code>makeUIView(context:)</code>，只需要声明它返回的是 <code>MKMapView</code> 然后直接通过构造方法返回一个空对象就可以了：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeUIView</span><span class="params">(context: UIViewRepresentableContext&lt;MapView&gt;)</span></span> -&gt; <span class="type">MKMapView</span> &#123;</span><br><span class="line">    <span class="type">MKMapView</span>(frame: .zero)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>updateUIView(_:context:)</code> 要做的事情就比较多了，我们一步步说：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateUIView</span><span class="params">(<span class="number">_</span> uiView: MKMapView, context: UIViewRepresentableContext&lt;MapView&gt;)</span></span> &#123;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">let</span> coordinate = <span class="type">CLLocationCoordinate2D</span>(latitude: <span class="number">23.112223</span>, longitude: <span class="number">113.331084</span>)</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">let</span> span = <span class="type">MKCoordinateSpan</span>(latitudeDelta: <span class="number">0.01</span>, longitudeDelta: <span class="number">0.01</span>)</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">let</span> region = <span class="type">MKCoordinateRegion</span>(center: coordinate, span: span)</span><br><span class="line">    uiView.setRegion(region, animated: <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>先把表示广州塔坐标的对象给构造出来（这是我在网上查的，等会预览的时候看看准不准）</li><li>构造一个用来标识地图的缩放等级的对象，数值越小地图拉得越近</li><li>构造坐标区域，并把这个区域设置到我们的地图视图上</li></ol><p>赶紧预览一下看看效果吧！你会发现画布上空白一片…</p><p>那是因为预览默认是静态模式的，它只能完整渲染 SwiftUI 的视图。因为我们现在用到了 UIView 的子类，所以要把预览切换到实时模式（右下角红框里的按钮）：<br><img src="/uploads/swiftui-serial-tutorial-2/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A72019-06-16%E4%B8%8B%E5%8D%887.28.49.png" alt></p><p>emmmm…塔呢？这定位看起来也不是很准啊。</p><h2 id="把一切都组装起来吧">把一切都组装起来吧！</h2><p>先看看预期实现的效果图：<br><img src="/uploads/swiftui-serial-tutorial-2/973ba702-85db-4852-851f-86a94cfca002.png" alt></p><p>然后花一点时间思考一下怎么弄，我们这两篇文章的知识是完全足够了的。</p><p>好啦！公布答案！</p><p>我们会在上一篇文章实现的 <code>ContentView</code> 里直接进行组装，下面来看看分解动作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123; <span class="comment">// 1</span></span><br><span class="line">            <span class="type">MapView</span>() </span><br><span class="line">                .edgesIgnoringSafeArea(.top) <span class="comment">// 2.1</span></span><br><span class="line">                .frame(height: <span class="number">300</span>) <span class="comment">// 2.2</span></span><br><span class="line"></span><br><span class="line">            <span class="type">CircleImage</span>()</span><br><span class="line">                .offset(y: -<span class="number">100</span>)</span><br><span class="line">                .padding(.bottom, -<span class="number">100</span>) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">            <span class="type">VStack</span>(alignment: .leading) &#123;</span><br><span class="line">                <span class="type">Text</span>(“<span class="type">Hello</span> <span class="type">SwiftUI</span>”)</span><br><span class="line">                    .font(.title)</span><br><span class="line">                <span class="type">HStack</span>(alignment: .top) &#123;</span><br><span class="line">                    <span class="type">Text</span>(“<span class="type">First</span> <span class="type">Description</span>”)</span><br><span class="line">                        .font(.subheadline)</span><br><span class="line">                    <span class="type">Spacer</span>()</span><br><span class="line">                    <span class="type">Text</span>(“<span class="type">Second</span> <span class="type">Description</span>”)</span><br><span class="line">                        .font(.subheadline)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .padding()</span><br><span class="line"></span><br><span class="line">            <span class="type">Spacer</span>() <span class="comment">// 4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>先用一个 <code>VStack</code> 把所有内容包裹起来，默认情况下 <code>VStack</code> 的内容布局是居中的，所以我们不需要做修改</li><li>针对 <code>MapView</code> 我们要做两个修改<ol><li><code>edgesIgnoringSafeArea</code> 可以让我们的视图把系统预留给刘海和状态栏的区域也用掉，这样看起来会更自然一点</li><li>对于只设置了 <code>height</code> 的视图，它的宽度会默认占满所有父视图里的可用空间</li></ol></li><li>我们的图片视图本身已经实现了所有效果了，现在只需要调整一下位置即可。需要注意的是，因为这里是通过 <code>offset</code> 移动的，所以为了保持与底部文字的间距，特意加上了一个负的 <code>padding</code> 来抵消掉位移导致的差距</li><li>做完前三步的操作后，这个 <code>VStack</code> 整体是在竖直方向上居中的，所以加上一个 <code>Spacer</code> 把整体有内容的部分顶到最上面（其实也可以通过 <code>HStack</code> 的 <code>alignment</code>来实现，不过那样代码就没有现在的简单优雅了）</li></ol><p>最终成果：<br><img src="/uploads/swiftui-serial-tutorial-2/EF653793-4B81-42D7-9B53-00790EE31E8F.png" alt></p><blockquote><p>如果你发现照着实现出来之后，中间圆形部分特别大的话，别担心，你是对的！<br>因为文章前面的 <code>CircleImage</code> 确实是为了展示而特意设置得比较大的，所以调整一下里面的宽高即可。</p></blockquote><h2 id="小结">小结</h2><p>到这里大家应该对 SwiftUI 的使用比较上手了，但目前为止涉及到的组件还比较少，SwiftUI 光是各种强大的组件就已经够玩很久了。不过我打算在第四篇文章里再集中讲各种有意思的组件使用方式，因为下一篇文章我们要先解决数据来源的问题。</p><p>既然我们的视图组件已经是通过声明式的写法来构建的了，那我们的数据是不是也该换一种方式绑定到视图上呢？在 JS 上我们可以用 react-redux 这样的数据绑定手段，那 SwiftUI 是不是该搭配 RxSwift 来使用了？</p><p>这些问题都将在下一篇文章里为大家解答！</p><h2 id="参考链接">参考链接</h2><p><a href="https://developer.apple.com/tutorials/swiftui/creating-and-combining-views" target="_blank" rel="noopener">SwiftUI | Creating and Combining Views</a><br><a href="https://developer.apple.com/videos/play/wwdc2019/216/" target="_blank" rel="noopener">SwiftUI Essentials - WWDC 2019 - Videos - Apple Developer</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;/2019/06/12/swiftui-serial-tutorial-1/&quot; title=&quot;上一篇文章&quot;&gt;上一篇文章&lt;/a&gt;中，我们了解了 SwiftUI 的 &lt;code&gt;Text&lt;/code&gt;  组件，并通过 &lt;code&gt;Stack&lt;/code&gt; 系列的组件对内容进行了一些简单的布局。在这篇文章里，我们会认识一个全新的图片组件，并且会尝试利用这两篇文章的知识，结合 MapKit 框架，来实现一个简单的地点详情界面。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://davidleee.com/tags/Swift/"/>
    
      <category term="SwiftUI" scheme="http://davidleee.com/tags/SwiftUI/"/>
    
      <category term="Image" scheme="http://davidleee.com/tags/Image/"/>
    
      <category term="UIView" scheme="http://davidleee.com/tags/UIView/"/>
    
      <category term="UIViewRepresentable" scheme="http://davidleee.com/tags/UIViewRepresentable/"/>
    
      <category term="MKMapView" scheme="http://davidleee.com/tags/MKMapView/"/>
    
      <category term="Spacer" scheme="http://davidleee.com/tags/Spacer/"/>
    
  </entry>
  
  <entry>
    <title>SwiftUI 系列教程（1）—— 初识 SwiftUI</title>
    <link href="http://davidleee.com/2019/06/12/swiftui-serial-tutorial-1/"/>
    <id>http://davidleee.com/2019/06/12/swiftui-serial-tutorial-1/</id>
    <published>2019-06-12T01:07:19.000Z</published>
    <updated>2020-05-05T03:43:31.444Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>可能是全网最早的 SwiftUI 中文教程？</p></blockquote><p>这篇文章来源于苹果官方的教程，相当于是我自己学习过程的一个记录。这个系列教程会跟着官方教程构造一个新的项目，还会加入一些 WWDC 的东西作为补充，可能偶尔会有一些自由发挥的部分。（不过我这里是做不出官方教程那种酷炫的动画了…）</p><a id="more"></a><h2 id="全新的编码体验">全新的编码体验！</h2><p>目前（2019.6.5）要体验到这个新东西，需要用到 <strong>Xcode 11 beta</strong>，而如果要体验新的预览机制和对画布上的预览进行操作，还需要把系统更新到 <strong>macOS Catalina 10.15 beta</strong>， 看来这个系列的新功能提供了系统层面的支持。</p><blockquote><p>话说回来，下了 iPadOS 之后用 iTunes 死活升不上去，报错说 macOS 有软件要更新，但总更新失败，最后下载 Xcode 11 beta 让它跑完 install components 那一步就可以成功升级 iPad 了…告诉我不是一个人…</p></blockquote><p>让我们先用新鲜热辣的 Xcode 11 beta 创建一个项目吧！</p><p>前面的步骤身为 iOS 开发的同学们应该很熟悉了，这里要创建的是 Xcode project -&gt; Single View App（playground 我还没试过，也许也被“强化”过了？），然后在取名字的那一步稍作停留，瞧瞧我在打勾区发现了什么：<strong>Use SwiftUI</strong>！当然选择钩上它！</p><p><img src="/uploads/swiftui-serial-tutorial-1/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A72019-06-10%E4%B8%8B%E5%8D%889.55.44.png" alt></p><p>完事之后我们就可以看到熟悉又带点陌生的编辑器界面了。点开默认提供给我们的 <em>ContentView.swift</em>，可以看到里面已经写好了两个 <code>struct</code>：<br><img src="/uploads/swiftui-serial-tutorial-1/F31CF147-5F01-422B-8ECB-C9AEFC274150.png" alt></p><hr><p>先打个岔，看看编辑区域右边新加入的 Minimap 界面，这虽然是一个在代码编辑器中比较常见的功能，但苹果一出手，还是给改进了一番：</p><ol><li>当鼠标在 Minimap 移动时，会像上图那样高亮并在左边把对应方法或变量名凸显出来，此时点击任意一块高亮区域都可以跳转到对应的代码位置</li><li>鼠标放在 Minimap 上时，按住 Command 键，所有的方法和变量名都会凸显出来（上图其实是按下了 Command 后的状态），重要的代码结构一目了然</li></ol><blockquote><p>苹果的每次大更新，着重宣传的主要变化，在我都尝试一遍之后就没什么感觉了，反而是这些小地方特别打动我</p></blockquote><hr><p>言归正传，看回代码。</p><p>这两个是 SwiftUI 默认提供的结构体，其中遵循 <code>View</code> 协议的那个定义了我们的界面内容和布局，而遵循 <code>PreviewProvider</code> 协议的那个则负责处理这个界面的预览。</p><p>那什么是预览？我们可以先把旁边的所谓预览窗口跑起来，点击右上角的 <em>Resume</em>（这个版本的 Xcode 默认会显示下图这个界面，没有的话，也可以在 <em>Editor</em> 里面打开它）：<br><img src="/uploads/swiftui-serial-tutorial-1/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A72019-06-10%E4%B8%8B%E5%8D%8810.22.22.png" alt></p><p>这时，Xcode 会把我们的项目运行起来，就跟平时点 <em>Run</em> 跑到模拟器上一样。有所不同的是，这次的模拟器直接显示成了 Xcode 的一个子界面，我们甚至可以直接操作这个模拟器里的视图，就像操作 xib 和 storyboard 一样！</p><p><img src="/uploads/swiftui-serial-tutorial-1/38B1BE43-FECA-471C-A845-FBFB8E5FA2C0.png" alt></p><blockquote><p>仔细看，点选了界面上的文案之后，左侧编辑器里相应的视图代码也被高亮了起来，是不是有一种根据按钮事件找 IBAction 代码的感觉？</p></blockquote><p>尝试修改一下代码里 <code>Text</code> 中的内容，会发现模拟器里的显示也实时更新了！对这个更加强大的模拟器，苹果给它起了个名字叫 <strong>画布（Canvas）</strong>。</p><h2 id="自定义文本视图">自定义文本视图</h2><p>那既然 <strong>画布</strong> 有着跟 Storyboard 相似的体验，那是不是意味着我们也可以直接改动界面上的元素？答案是肯定的，所有功能都隐藏在 Command + 左键点击里：<br><img src="/uploads/swiftui-serial-tutorial-1/AA6AA015-7832-46DD-83E7-063BC1631D83.png" alt></p><p>点击后会出现一个内容丰富的弹出框，这些操作会根据点击的视图不同而不同。</p><p>我们可以通过 <em>Inspect…</em> 来修改视图的一些基本元素：<br><img src="/uploads/swiftui-serial-tutorial-1/D0D9CEBC-7A12-4479-9541-34C80D177817.png" alt></p><blockquote><p>图上应该能看出来，这个弹出框是可以滚动的，它已经可以取代原来我们常用的 Attributes Inspector。实际上，如果你在这个时候点开右侧边栏，会发现 Attributes Inspector 的内容跟这里是完全一致的</p></blockquote><p>我们来把它的字体改为 <em>Large Title</em>，可以看到代码部分也跟着界面一起改变了：<br><img src="/uploads/swiftui-serial-tutorial-1/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A72019-06-10%E4%B8%8B%E5%8D%8810.38.09.png" alt></p><p>按照这个规律，我们通过手写代码来改个字体颜色试试：<br><img src="/uploads/swiftui-serial-tutorial-1/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A72019-06-10%E4%B8%8B%E5%8D%8810.40.22.png" alt></p><p>这种链式调用的语法是不是跟用 OC 实现的 AutoLayout 开源库 <a href="https://github.com/SnapKit/Masonry" target="_blank" rel="noopener">Masonry</a> 很像呢？苹果把这些方法叫做 <em>修饰器(modifiers)</em>，它们会在旧视图的基础上构造一个新视图返回出来，这使得上述的链式调用成为可能。</p><blockquote><p>如果我们再从刚才的 <em>Inspect…</em> 里把字体颜色改为 <em>inherited</em>，就会发现 Xcode 把我们刚加上的 <code>.color(.red)</code> 又给删掉了，这波操作让写代码有意思了不少啊。</p></blockquote><h2 id="把视图都叠起来吧">把视图都叠起来吧</h2><p>在前面的内容里，我们通过 SwiftUI 来描述了我们想要的视图样式，但这只是单一的视图。当视图多起来的时候，我们可以通过 <em>stacks</em> 把视图在竖直方向、水平方向或从前往后组合起来。</p><p>注意力继续回到我们的新朋友画布上，这次我们加快一点速度，先对刚刚的文本进行 <em>Embed in VStack</em> 的操作：<br><img src="/uploads/swiftui-serial-tutorial-1/32BB01AF-9406-41A2-8CA6-61F10F511D3A.png" alt></p><p>然后通过 Command + shift + L 调出视图库界面：<br><img src="/uploads/swiftui-serial-tutorial-1/73CBCF80-9712-48AA-9049-AD8641FC0269.png" alt></p><p>从里面拖一个 <code>Text</code> 到编辑器里（对，没错，就是编辑器，它会自动变成代码），放到我们之前操作的 <code>Text</code> 之下。现在我们的代码应该变成这个样子了：<br><img src="/uploads/swiftui-serial-tutorial-1/54973458-B739-467A-A6E9-B28081FEC640.png" alt></p><blockquote><p>从视图库拖组件出来这一步，我们有两种选择：一种是拖到代码里，另一种是拖到 Canvas 上。大家可以尝试一下拖到界面上会有什么样的效果。</p></blockquote><p>稍后我们再回过头来看这个 <code>VStack</code> 是什么。现在让我们继续快进，加入两个没见过的新组件 <code>HStack</code> 和 <code>Spacer</code>，通过给 <code>VStack</code> 加上参数来进行布局，还要再通过修饰器美化一下界面，最后 <code>ContentView</code> 的内容应该是这个样子的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span> : <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span>(alignment: .leading) &#123;</span><br><span class="line">            <span class="type">Text</span>(“<span class="type">Hello</span> <span class="type">SwiftUI</span>”)</span><br><span class="line">                .font(.largeTitle)</span><br><span class="line">                <span class="type">HStack</span> &#123;</span><br><span class="line">                    <span class="type">Text</span>(“<span class="type">First</span> <span class="type">Description</span>”)</span><br><span class="line">                        .font(.subheadline)</span><br><span class="line">                    <span class="type">Spacer</span>()</span><br><span class="line">                    <span class="type">Text</span>(“<span class="type">Second</span> <span class="type">Description</span>”)</span><br><span class="line">                        .font(.subheadline)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .padding()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相应的，我们的界面也成了这样：<br><img src="/uploads/swiftui-serial-tutorial-1/33A162A9-B3E2-4938-80DD-A7B752AC2098.png" alt></p><h2 id="幕后发生了什么？">幕后发生了什么？</h2><p>刚才的代码里，起到容器作用的是 <code>VStack</code> 和 <code>HStack</code>，顾名思义，它们分别是竖直方向上和水平方向上的层叠视图（Vertical &amp; Horizontal），用法跟我们早就认识的 <code>StackView</code> 相同。</p><p>到目前为止，有过前端开发经验的同学们应该能发现，这不就是 JSX 的语法吗？</p><p>我们知道，在实现一个新界面的时候，通常包含着“用基本组件就能实现”的常规部分和“要把奇技淫巧发挥到极致”的出彩部分。SwiftUI 的出现就是为了简化常规 UI 的开发过程，让开发者能够把精力都放在激动人心的部分。</p><blockquote><p>—— 摘自 WWDC</p></blockquote><p>为了达到这个目的，一个首要的改变就是：<strong>把命令式的视图逻辑转变为声明式的</strong>。这样做的好处在于：</p><ol><li>提高了组件的复用性</li><li>代码更清晰易懂，在编写的过程中也更符合直觉</li><li>隐藏了背后复杂的部分，让 SwiftUI 帮我们料理好一切</li></ol><p>这样转变之后，整个视图层级的代码看起来就清晰了许多（对比一下用单纯的 Swift 来实现会有多少代码），然而这种转变的背后其实都是我们熟悉的 Swift 语法。举个例子，<code>VStack</code> 本身就是一个 <code>View</code>，它的实现是这样的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">VStack</span>&lt;<span class="title">Content</span>: <span class="title">View</span>&gt; : <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(</span><br><span class="line">        alignment: <span class="type">HorizontalAlignment</span> = .center,</span><br><span class="line">        spacing: <span class="type">Length?</span> = <span class="literal">nil</span>,</span><br><span class="line">        @<span class="type">ViewBuilder</span> content: () -&gt; <span class="type">Content</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>alignment</code> 和 <code>spacing</code> 是两个布局用的属性，我们在之前的例子里就设置了 <code>VStack(alignment: .leading)</code>，这可以让内部的元素左对齐；而 <code>content</code> 属性则是一个闭包，它将返回另外一个视图，里面包含了所有要显示在 <code>VStack</code> 里的子视图。</p><p><code>VStack</code> 和 <code>HStack</code> 在 SwiftUI 里被用到时候，其实就是调用了它的构造方法，因为前两个参数要么是有默认值的，要么是可选的，所以只需要关注最后一个闭包参数；而这个闭包参数作为参数列表里的最后一员，可以写作结尾闭包的样子，于是就有了我们上面例子中的写法。</p><p>剩下的 <code>Spacer()</code> 和 <code>.padding()</code> 就只不过是 SwiftUI 提供给我们的又一个常规组件和修饰器而已了。</p><h2 id="小结">小结</h2><p>写到这里，仅仅涵盖了官方教程第一章里的前3部分，外加一点来自 WWDC 视频里的内容。我还会继续补充，努力把整个教程都覆盖掉。</p><p>不过这就足以让我们看到它的好玩之处了，至少写了一段时间 React Native 的我，看到这似曾相识的语法，着实感觉欣喜。苹果在为开发者打造工具上下的功夫，恐怕在历史所有科技型企业上也是数一数二的了。</p><h2 id="参考链接">参考链接</h2><p><a href="https://developer.apple.com/tutorials/swiftui/creating-and-combining-views" target="_blank" rel="noopener">SwiftUI | Creating and Combining Views</a><br><a href="https://developer.apple.com/videos/play/wwdc2019/216/" target="_blank" rel="noopener">SwiftUI Essentials - WWDC 2019 - Videos - Apple Developer</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;可能是全网最早的 SwiftUI 中文教程？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这篇文章来源于苹果官方的教程，相当于是我自己学习过程的一个记录。这个系列教程会跟着官方教程构造一个新的项目，还会加入一些 WWDC 的东西作为补充，可能偶尔会有一些自由发挥的部分。（不过我这里是做不出官方教程那种酷炫的动画了…）&lt;/p&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://davidleee.com/tags/Swift/"/>
    
      <category term="SwiftUI" scheme="http://davidleee.com/tags/SwiftUI/"/>
    
      <category term="Catalina" scheme="http://davidleee.com/tags/Catalina/"/>
    
      <category term="VStack" scheme="http://davidleee.com/tags/VStack/"/>
    
      <category term="HStack" scheme="http://davidleee.com/tags/HStack/"/>
    
  </entry>
  
  <entry>
    <title>NSTextField(1) —— macOS 输入框概览</title>
    <link href="http://davidleee.com/2019/04/12/nstextfield-for-macos/"/>
    <id>http://davidleee.com/2019/04/12/nstextfield-for-macos/</id>
    <published>2019-04-12T07:15:04.000Z</published>
    <updated>2020-05-05T03:43:31.444Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是 macOS 开发系列的第四篇文章 —— NSTextField。<br>最常见的控件之一，却不一定是你最熟悉的控件之一。</p></blockquote><a id="more"></a><p>将近半年没发文了，这段时间过得真是充实得过分，以至于完全没有时间好好整理一下手边可以写的内容。最近好不容易有点时间可以把存货整理整理，发现当时写的好多东西都已经过时了！赶紧收拾干净先发一篇上来，不然指不定哪天连整个主题都没用了…</p><p>咱们直接进入正题！</p><h2 id="nstextfield">NSTextField</h2><p>一个完整的 TextField 是由两个类组成的：<a href="https://developer.apple.com/documentation/appkit/nstextfieldcell" target="_blank" rel="noopener">NSTextFieldCell</a>，干了绝大多数脏活累活的一个类，和 <a href="https://developer.apple.com/documentation/appkit/nstextfield" target="_blank" rel="noopener">NSTextField</a>，作为 NSTextFieldCell 的容器而存在。所有 NSTextFieldCell 里的方法在 NSTextField 里面都有对应的存在（有点像 UIView 对 Layer 的封装）。</p><p>对于绝大多数情况来说，我们直接用 NSTextField 就足够了（那这篇文章不久没什么作用了吗？！）。如果你想要对自己的输入框有更多的掌控权，那可能还需要了解一个叫 <a href="https://developer.apple.com/documentation/appkit/nscontrol" target="_blank" rel="noopener">NSControl</a> 的家伙。</p><h2 id="nscontrol">NSControl</h2><p>正如 iOS 里的 <a href="https://developer.apple.com/documentation/uikit/uicontrol" target="_blank" rel="noopener">UIControl</a>，<a href="https://developer.apple.com/documentation/appkit/nscontrol" target="_blank" rel="noopener">NSControl</a> 是一个抽象类，必须通过子类继承来使用。但是跟比较纯粹的 UIControl 不同，NSControl 除了支持 Target/Action 机制和一些常见的属性设置之外，还加上了支持文字编辑的一系列代理方法。</p><p>举个两组最常用的例子：</p><h3 id="controltextdidxxx">controlTextDidxxx(_:)</h3><p>这么多方法里面，比较好用的当属 <code>did</code> 系列方法了：</p><ol><li><a href="https://developer.apple.com/documentation/objectivec/nsobject/1428934-controltextdidbeginediting?language=objc" target="_blank" rel="noopener"><code>controlTextDidBeginEditing(_:)</code></a></li><li><a href="https://developer.apple.com/documentation/objectivec/nsobject/1428847-controltextdidendediting?language=objc" target="_blank" rel="noopener"><code>controlTextDidEndEditing(_:)</code></a></li><li><a href="https://developer.apple.com/documentation/objectivec/nsobject/1428982-controltextdidchange?language=objc" target="_blank" rel="noopener"><code>controlTextDidChange(_:)</code></a></li></ol><p>这三个方法虽然已经在官方文档里被标记为 “macOS 10.0-10.14 Deprecated”了，<s>但它们仍然在勤勤恳恳地工作着</s>。<s>鉴于 macOS 的 10.14 还没出来</s>（2018.8），<s>我们但用无妨</s>。2019年4月再看，系统版本已经到10.14以上了，是时候考虑正式换成下面的方法了。</p><blockquote><p>上面三个方法的链接都是 Objective-C 版本的，被 Deprecated 的也是这个版本的方法。在 Swift 版的文档里，在 NSControlTextEditingDelegate 里已经加入这三个方法<s>的 Beta 版</s>了（2019.4 Beta 标识已经去掉了）：<a href="https://developer.apple.com/documentation/appkit/nscontroltexteditingdelegate/3005176-controltextdidbeginediting" target="_blank" rel="noopener">controlTextDidBeginEditing(<em>:)</em></a>、 <a href="https://developer.apple.com/documentation/appkit/nscontroltexteditingdelegate/3005177-controltextdidchange" target="_blank" rel="noopener">controlTextDidChange(:)</a>、 <a href="https://developer.apple.com/documentation/appkit/nscontroltexteditingdelegate/3005178-controltextdidendediting" target="_blank" rel="noopener">controlTextDidEndEditing(_:)</a>。方法签名看起来是一样的，估计新方法的正式版出来之后也可以无缝迁移。</p></blockquote><p>顾名思义，它们代表了输入过程中的三个状态，不过有一点要注意的是：每次出现 didEnd 并不一定会有一个对应的 didBegin。因为 didBegin 表示的是用户<strong>开始输入</strong>的状态，也就是说，单单是光标在控件上面闪烁着是不算数的，一定要用户敲下第一个字符的时候才会回调 <code>controlTextDidBeginEditing(_:)</code>。</p><p>而相对的，didEnd 表示<strong>结束编辑</strong>，只要用户选中输入框之后点击了输入框以外的地方，都会被算作“结束”，即使他从头到尾都没有输入过一个字。</p><p>这三个方法传入的参数都是 <code>Notification</code> 类型，说明它们其实都是系统通知的回调方法，只要实现了这个方法，系统就会自动帮你注册这三个消息的监听器。</p><blockquote><p>虽然参数是个 <code>Notification</code> ，但它会把触发消息的输入框作为 object 属性一起传进来，可以做的事情就相当多了。</p></blockquote><h3 id="nscontroltexteditingdelegate">NSControlTextEditingDelegate</h3><p>这个代理是专门为了编辑操作而设计的，除了<s>还在 Beta 版的</s>三个 did 系列方法外（2019.4 Beta 标识已经去掉了），还有分工明确的另外7个方法，一共10个。这部分在现在的项目里还没怎么接触，就只是把文档搬过来方便大家参考。</p><p>验证：</p><ul><li><a href="https://developer.apple.com/documentation/appkit/nscontroltexteditingdelegate/1428873-control" target="_blank" rel="noopener">control(_:isValidObject:)</a></li><li><a href="https://developer.apple.com/documentation/appkit/nscontroltexteditingdelegate/1428941-control" target="_blank" rel="noopener">control(_:didFailToValidatePartialString:errorDescription:)</a></li></ul><p>格式化文本：</p><ul><li><a href="https://developer.apple.com/documentation/appkit/nscontroltexteditingdelegate/1428883-control" target="_blank" rel="noopener">control(_:didFailToFormatString:errorDescription:)</a></li></ul><p>文本编辑响应：</p><ul><li><a href="https://developer.apple.com/documentation/appkit/nscontroltexteditingdelegate/1428865-control" target="_blank" rel="noopener">control(_:textShouldBeginEditing:)</a></li><li><a href="https://developer.apple.com/documentation/appkit/nscontroltexteditingdelegate/1428984-control" target="_blank" rel="noopener">control(_:textShouldEndEditing:)</a></li></ul><p>自动补全：</p><ul><li><a href="https://developer.apple.com/documentation/appkit/nscontroltexteditingdelegate/1428925-control" target="_blank" rel="noopener">control(_:textView:completions:forPartialWordRange:indexOfSelectedItem:)</a></li></ul><p>按键事件响应：</p><ul><li><a href="https://developer.apple.com/documentation/appkit/nscontroltexteditingdelegate/1428898-control" target="_blank" rel="noopener">control(_:textView:doCommandBy:)</a></li></ul><p>成员方法 <s>Beta</s>:</p><ul><li><a href="https://developer.apple.com/documentation/appkit/nscontroltexteditingdelegate/3005176-controltextdidbeginediting" target="_blank" rel="noopener">controlTextDidBeginEditing(_:)</a></li><li><a href="https://developer.apple.com/documentation/appkit/nscontroltexteditingdelegate/3005177-controltextdidchange" target="_blank" rel="noopener">controlTextDidChange(_:)</a></li><li><a href="https://developer.apple.com/documentation/appkit/nscontroltexteditingdelegate/3005178-controltextdidendediting" target="_blank" rel="noopener">controlTextDidEndEditing(_:)</a></li></ul><h2 id="总结">总结</h2><p>没有错！到这里就结束了！（因为实在是没什么存货…）希望这篇文章能起到入门和索引的作用。</p><p>有了这些内容，应该大概能知道怎么去控制输入框的内容，也可以避免一些简单的坑了。</p><p>如果没人注意到标题里的“(1)”的话，我就在这里打住了…不然我可能会把打造一个真实情景下使用的输入框的过程讲一讲。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这是 macOS 开发系列的第四篇文章 —— NSTextField。&lt;br&gt;
最常见的控件之一，却不一定是你最熟悉的控件之一。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://davidleee.com/tags/Swift/"/>
    
      <category term="macOS" scheme="http://davidleee.com/tags/macOS/"/>
    
      <category term="NSTextField" scheme="http://davidleee.com/tags/NSTextField/"/>
    
      <category term="NSControl" scheme="http://davidleee.com/tags/NSControl/"/>
    
  </entry>
  
  <entry>
    <title>又一篇 iOS Extension 入门（3/3）— Today 小组件</title>
    <link href="http://davidleee.com/2018/11/15/yet-another-ios-extension-article-3/"/>
    <id>http://davidleee.com/2018/11/15/yet-another-ios-extension-article-3/</id>
    <published>2018-11-15T08:12:27.000Z</published>
    <updated>2020-05-05T03:43:31.446Z</updated>
    
    <content type="html"><![CDATA[<p>昨天通过两篇文章介绍了 iOS Extension 的基础，并尝试制作了一个分享扩展，让我们的应用可以接收到从其他应用分享过来的数据，还实现了跨沙盒的应用扩展与载体间的通信。</p><p>看上面这段话就觉得内容挺多的吧…所以专门把 Extension 界的当红选手 —— Today 小组件单独放在这一篇文章里面讲，作为这个 iOS Extension 入门系列的收尾～</p><p>让我们马上进入正题！</p><a id="more"></a><h2 id="啥是-today-小组件">啥是 Today 小组件</h2><p>展示在 Today 界面（手机主页最左屏）里的应用扩展统称为“小组件”（Widget）。小组件存在的目的是向用户快速展示<strong>当下</strong>最重要的信息，并提供一些简易的任务处理功能，比如“把任务标记为完成”之类的。</p><blockquote><p>官方建议： Today 小组件负责的任务最好在单次操作内就能完成，如果你发现这个任务需要多个步骤，那 Today 小组件也许不是最适合的扩展点。具体扩展点参见 <a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/index.html#//apple_ref/doc/uid/TP40014214-CH20-SW3" target="_blank" rel="noopener">官方扩展点列表</a> 或者这个系列文章的第一篇（<a href="/2018/11/14/yet-another-ios-extension-article/" title="又一篇 iOS Extension 入门（1/3）— 基础 & 分享扩展">又一篇 iOS Extension 入门（1/3）— 基础 & 分享扩展</a>）里的翻译版。</p></blockquote><h3 id="划重点">划重点</h3><p>iOS 和 macOS 平台上都有 Today 小组件，在开发过程中需要注意的地方是相同的：</p><ul><li>确保内容是最新的</li><li>谨慎地对待用户交互</li><li>性能调优</li></ul><blockquote><p>从交互上来说，务必避免在小组件里放滚动列表，因为用户很难区分小组件内部的滚动和整个小组件列表的滚动</p></blockquote><p><strong>在 iOS 上</strong>：小组件不允许键盘输入，所以一切针对小组件的设置都应该在载体应用内完成。以“股市”为例，用户可以直接在小组件上切换显示的单位，但是股票列表的编辑需要在载体应用里进行。<br><strong>在 macOS 上</strong>：载体应用可以不做任何功能，小组件可以提供一个配置入口。还是以“股市”为例，小组件里可以直接搜索、添加和删除特定股票。</p><h2 id="来做一个-today-小组件吧">来做一个 Today 小组件吧</h2><p>就像创建分享扩展那样，首先要在项目配置里添加一个 Target（复习<a href="/2018/11/14/yet-another-ios-extension-article/" title="系列文章第一篇">系列文章第一篇</a>），如果想要共享数据的话，还需要配置一下 Capabilities -&gt; App Groups（复习<a href="/2018/11/14/yet-another-ios-extension-article-2/" title="系列文章第二篇">系列文章第二篇</a>）。</p><p>Xcode 依旧贴心地为我们创建了一个目录，随便点开看看，可以发现 <em>Info.plist</em> 里关于 <code>NSExtension</code> 的内容有所不同，其中的 <code>NSExtensionActivationRule</code> 字段已经没有了，因为 Today 小组件的开关是用户自己选择操作的，不需要我们开发者去判断。</p><h3 id="界面">界面</h3><blockquote><p>为了实现最好的效果，建议使用 AutoLayout 去做界面的布局。</p></blockquote><p>Today 小组件的宽度是固定的，高度上有延伸的空间以显示更多的内容。Xcode 创建的 IB 模版里已经用上了 AutoLayout，并用上了标准的四周间隔，我们可以通过 <code>widgetMarginInsetsForProposedMarginInsets:</code> 方法来获取到这些间隔以便计算。</p><blockquote><p>模版里的 VC 已经实现了 <code>NSWidgetProviding</code> 协议，上述方法就是在这个协议里定义的。</p></blockquote><p>界面部分最值得一提的就是右上角的“展开/折叠”了。这个按钮默认情况下并不会显示，需要我们添加一些代码来实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">    extensionContext?.widgetLargestAvailableDisplayMode = .expanded</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">widgetActiveDisplayModeDidChange</span><span class="params">(<span class="number">_</span> activeDisplayMode: NCWidgetDisplayMode, withMaximumSize maxSize: CGSize)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">if</span> activeDisplayMode == .expanded &#123;</span><br><span class="line">        preferredContentSize = <span class="type">CGSize</span>(width: maxSize.width, height: <span class="number">200</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        preferredContentSize = maxSize</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>告诉 <code>extensionContext</code> 我们的小组件是支持展开的，这个属性的默认值是 <code>.compact</code></li><li>用户点击“展开/折叠”的回调，如果不进行处理，小组件的高度不会发生变化</li><li>修改小组件的高度，这里的 <code>maxSize</code> 是系统限制的当前模式下的最大尺寸，使用 iPhone XR 模拟器测试时，<code>.compact</code> 模式下是 <code>(398, 110)</code>，<code>.expanded</code> 模式下是 <code>(398, 748)</code>。可见，苹果限制了折叠状态下最大高度为 110，超出部分会直接截掉；而展开状态下，最大高度为设备的高度。</li></ol><p>界面部分就没什么了，剩下的该是具体问题具体分析。接下来轮到功能逻辑的部分。</p><h3 id="跳转到载体应用">跳转到载体应用</h3><p>实际上，小组件还是通过 Universal Link 的机制来唤起载体应用的，与应用间跳转没有什么区别，只不过需要通过 <code>extensionContext</code> 来调用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唤起 URL Schemes 为 davidleee 的应用</span></span><br><span class="line">extensionContext?.<span class="keyword">open</span>(<span class="type">URL</span>(string: <span class="string">"davidleee://"</span>)!, completionHandler: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>需要注意的是，如果你的小组件要打开第三方的应用，在提交 App Store 审核的时候需要特别说明一下，否则会被打回。</p><blockquote><p>关于 Universal Link 的官方文档在这里：<a href="https://developer.apple.com/ios/universal-links/" target="_blank" rel="noopener">Universal Links - Apple Developer</a>，我也写过一篇文章记录了可能存在的一些坑，感兴趣的可以瞅瞅：<a href="/2017/01/04/universal-link-problems/" title="Universal Link（iOS）踩坑">Universal Link（iOS）踩坑</a></p></blockquote><h3 id="数据更新">数据更新</h3><p>既然 Today 小组件的目的就是为用户提供最新鲜的数据，那么数据更新的部分就一定不能马虎。</p><p>在 Xcode 帮我们创建的 <code>TodayViewController</code> 里面，我们可以看到一个叫  <code>widgetPerformUpdate(completionHandler:)</code> 的方法，在它的描述里能看到这么一句话：</p><p><em>This method is called to give a widget an opportunity to update its contents and redraw its view prior to an operation such as a snapshot.</em></p><p>苹果设计这个 API 是为了把数据的更新统一放到一个地方去。如果我们实现了这个方法，系统就会在合适的时候调用这个方法（比如系统想要给你的小组件进行 snapshot 之前），给我们一次更新数据的机会，并且这个机会不一定出现在小组件显示出来的时候，在后台的情况下也有可能触发这个回调。</p><p>于是我们就有两个拉数据的机会：</p><ul><li>在 <code>viewDidLoad</code> 里面</li><li>在 <code>widgetPerformUpdate(completionHandler:)</code> 里面</li></ul><blockquote><p>实验发现，小组件只要不可见的时间稍微长一点点，比如滚动出了屏幕，或离开 Today 视图一小会，它就会被重新初始化，也就是说 <code>viewDidLoad</code> 的调用会比想象中更频繁。但这并不意味着我们可以完全依赖 <code>viewDidLoad</code> 来做数据更新。</p></blockquote><p>在 SO 上的<a href="https://stackoverflow.com/questions/25168950/what-is-the-purpose-of-widgetperformupdatewithcompletionhandler-in-ios-8-today-w" target="_blank" rel="noopener">这个讨论</a>里，对数据更新的时机进行了更多的讨论，总结起来就是两点：</p><ol><li>苹果希望你在整个生命周期里尽可能早的地方进行数据更新，所以 <code>viewDidLoad</code> 要用</li><li><code>viewDidLoad</code> 还不够，那就用上 <code>widgetPerformUpdate(completionHandler:)</code>，毕竟前者并不会在后台情况下被调用</li></ol><h2 id="总结一下">总结一下</h2><p>Today 小组件就是一个用来展示<strong>小块</strong>数据和处理<strong>简单</strong>任务的地方。</p><p>注意上面那句话加粗的两个词，这给小组件定下了一个主基调：敏捷，所以凡是逻辑越写越复杂的时候，都该停下来想一想：这些逻辑是不是应该挪到载体应用里面去做？</p><blockquote><p>用这个理由去怼产品经理吧，就说是那个估值超万亿的苹果的产品经理说的～</p></blockquote><h2 id="参考文章">参考文章</h2><ul><li><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/Today.html#//apple_ref/doc/uid/TP40014214-CH11-SW1" target="_blank" rel="noopener">App Extension Programming Guide: Today</a></li><li><a href="https://medium.com/nine9devtw/ios-today-extension-swift-%E6%95%99%E5%AD%B8%E7%AD%86%E8%A8%98-5361446d1950" target="_blank" rel="noopener">iOS today extension (swift) 教學筆記 – 碼農勤耕田 – Medium</a></li><li><a href="https://stackoverflow.com/questions/25168950/what-is-the-purpose-of-widgetperformupdatewithcompletionhandler-in-ios-8-today-w" target="_blank" rel="noopener">ios8 - What is the purpose of widgetPerformUpdateWithCompletionHandler in iOS 8 Today Widget? - Stack Overflow</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天通过两篇文章介绍了 iOS Extension 的基础，并尝试制作了一个分享扩展，让我们的应用可以接收到从其他应用分享过来的数据，还实现了跨沙盒的应用扩展与载体间的通信。&lt;/p&gt;
&lt;p&gt;看上面这段话就觉得内容挺多的吧…所以专门把 Extension 界的当红选手 —— Today 小组件单独放在这一篇文章里面讲，作为这个 iOS Extension 入门系列的收尾～&lt;/p&gt;
&lt;p&gt;让我们马上进入正题！&lt;/p&gt;
    
    </summary>
    
    
      <category term="Universal Link" scheme="http://davidleee.com/tags/Universal-Link/"/>
    
      <category term="ios" scheme="http://davidleee.com/tags/ios/"/>
    
      <category term="Today Extension" scheme="http://davidleee.com/tags/Today-Extension/"/>
    
      <category term="Widget" scheme="http://davidleee.com/tags/Widget/"/>
    
  </entry>
  
  <entry>
    <title>又一篇 iOS Extension 入门（2/3）— 与容器沟通</title>
    <link href="http://davidleee.com/2018/11/14/yet-another-ios-extension-article-2/"/>
    <id>http://davidleee.com/2018/11/14/yet-another-ios-extension-article-2/</id>
    <published>2018-11-14T10:01:12.000Z</published>
    <updated>2020-05-05T03:43:31.446Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="/2018/11/14/yet-another-ios-extension-article/" title="上一篇文章">上一篇文章</a>里，我们了解到了 iOS Extension 的基础和怎么制作一个简单的分享扩展，然而，限于篇幅原因，这个分享操作止于用户点下 “Post” 的那一刻了。<br>接下来，就让我们一起看看怎么把用户分享的数据给到载体应用，让这次分享溜得飞起。</p><a id="more"></a><h2 id="app-groups">App Groups</h2><p>我们都知道 iOS 的应用是跑在一个属于自己的沙盒里面的，为了实现应用间的数据共享，苹果提供了一个叫 App Groups 的概念。只有当应用属于同一个 App Groups 的时候，才能访问到共享的数据存储区域。</p><p>我们可以在载体应用的项目配置 Capabilities -&gt; App Groups 里创建一个应用分组：<br><img src="/uploads/yet-another-ios-extension-article-2/77534A33-46E6-4381-B6EC-4AA09E726A6A.png" alt></p><p>然后在应用扩展的项目配置 Capabilities -&gt; App Groups 里会出现我们刚刚新建的应用分组，直接钩上就可以了。</p><p>这样我们就等于分配了一个共享空间给这哥俩，为我们接下来的数据共享做好准备了。</p><h2 id="共享空间">共享空间</h2><p>做完上面的准备之后，我们就可以通过三种方式去访问共享空间，它们分别是 <code>UserDefaults</code>、<code>FileManager</code> 和 <code>CoreData</code>。</p><h3 id="userdefaults">UserDefaults</h3><p><code>UserDefaults</code> 有一个带参数的初始化方法，通过这个方法我们可以访问到一个共享的用户配置空间。在上一篇文章里，我们成功把 Safari 分享出来的一个 URL 打印了出来，现在我们把它放到共享空间去，让载体应用也可以获取到这个链接：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">attachment.loadItem(forTypeIdentifier: kUTTypeURL <span class="keyword">as</span> <span class="type">String</span>, options: <span class="literal">nil</span>) &#123; (item, error) <span class="keyword">in</span></span><br><span class="line">                        <span class="keyword">if</span> error == <span class="literal">nil</span> &#123;</span><br><span class="line">                            <span class="keyword">let</span> userDefaults = <span class="type">UserDefaults</span>(suiteName: <span class="string">"group.com.davidleee.SharePlayground"</span>)</span><br><span class="line">                            userDefaults?.<span class="keyword">set</span>(item, forKey: <span class="string">"share-url"</span>)</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"url from userdefault: \(userDefaults?.value(forKey: "</span>share-url<span class="string">"))"</span>)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>通过传入之前设置好的应用分组 ID，我们告诉 <code>UserDefault</code> 接下来要访问一个特定的共享空间，接着就像平常那样使用它即可。</p><blockquote><p>上面的打印输出的是一堆 data，以为 <code>URL</code> 在保存到 <code>UserDefaults</code> 的时候会被序列化，想看到原来的 <code>URL</code> 对象的话还要再反序列化一下才行。</p></blockquote><h3 id="filemanager">FileManager</h3><p>与 <code>UserDefaults</code> 类似，<code>FileManager</code> 也有一个特殊的获取方法，我们看看把刚刚的 URL 写到一个文本文件里应该是什么样子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> groupPath = <span class="type">FileManager</span>.<span class="keyword">default</span>.containerURL(forSecurityApplicationGroupIdentifier: <span class="string">"group.com.davidleee.SharePlayground"</span>)</span><br><span class="line">                            <span class="keyword">if</span> <span class="keyword">let</span> url = item <span class="keyword">as</span>? <span class="type">URL</span>, <span class="keyword">let</span> filePath = groupPath?.appendingPathComponent(<span class="string">"url.txt"</span>)  &#123;</span><br><span class="line">                                <span class="keyword">try</span>? url.absoluteString.write(to: filePath, atomically: <span class="literal">true</span>, encoding: .utf8)</span><br><span class="line">                            &#125;</span><br><span class="line">                            </span><br><span class="line">                            <span class="keyword">if</span> <span class="keyword">let</span> filePath = groupPath?.appendingPathComponent(<span class="string">"url.txt"</span>) &#123;</span><br><span class="line">                                <span class="keyword">try</span>? <span class="built_in">print</span>(<span class="string">"content of file: \(String(contentsOf: filePath, encoding: .utf8))"</span>)</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="coredata">CoreData</h3><p>好吧，CoreData 的共享空间其实跟 <code>FileManager</code> 是同一个，只是从写文件变成写数据库，再把数据库的文件放到共享空间而已。这个就不贴代码了，CoreData 里的类名是真的长…</p><h2 id="总结一下">总结一下</h2><p>感觉这篇文章跟应用扩展都没什么关系了…毕竟 App Goups 是 iOS 平台上一个比较通用的数据共享技术。</p><p>App Groups 的引入让 iOS 应用间数据共享成为可能，这不仅可以用在应用扩展和载体应用之间，还可以用在自家的多个独立应用之间，真可谓是沙盒墙上透过来的一道亮光。</p><h2 id="参考文章">参考文章</h2><ul><li><a href="https://my.oschina.net/vimfung/blog/707448" target="_blank" rel="noopener">iOS扩展开发攻略(一) - Share Extension - vimfung的开源部落 - 开源中国</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;/2018/11/14/yet-another-ios-extension-article/&quot; title=&quot;上一篇文章&quot;&gt;上一篇文章&lt;/a&gt;里，我们了解到了 iOS Extension 的基础和怎么制作一个简单的分享扩展，然而，限于篇幅原因，这个分享操作止于用户点下 “Post” 的那一刻了。&lt;br&gt;
接下来，就让我们一起看看怎么把用户分享的数据给到载体应用，让这次分享溜得飞起。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ios" scheme="http://davidleee.com/tags/ios/"/>
    
      <category term="App Groups" scheme="http://davidleee.com/tags/App-Groups/"/>
    
      <category term="Extension" scheme="http://davidleee.com/tags/Extension/"/>
    
      <category term="UserDefaults" scheme="http://davidleee.com/tags/UserDefaults/"/>
    
      <category term="FileManager" scheme="http://davidleee.com/tags/FileManager/"/>
    
      <category term="CoreData" scheme="http://davidleee.com/tags/CoreData/"/>
    
  </entry>
  
  <entry>
    <title>又一篇 iOS Extension 入门（1/3）— 基础 &amp; 分享扩展</title>
    <link href="http://davidleee.com/2018/11/14/yet-another-ios-extension-article/"/>
    <id>http://davidleee.com/2018/11/14/yet-another-ios-extension-article/</id>
    <published>2018-11-14T08:00:50.000Z</published>
    <updated>2020-05-05T03:43:31.446Z</updated>
    
    <content type="html"><![CDATA[<p>应用扩展（App Extension）让你应用的功能和内容都得到了更大的延伸，这让用户在使用其他应用的时候有机会与你的应用发生交互。在这个大家都极力争夺注意力的时代，应用扩展无疑为我们打开了一扇新的大门。</p><a id="more"></a><h2 id="什么是应用扩展？">什么是应用扩展？</h2><p>应用扩展与应用本身是有不同的。尽管在上架应用扩展的时候，你必须以一个普通的应用为载体（Containing App），但是它实际上是一个独立的二进制文件，而且并不依赖于载体应用来运行。</p><p>具体来说，应用扩展分为了十多个类别，你可以通过它们来实现各种各样的功能。下面是官方文档里介绍扩展点（Extension Point）的表格，我调整了一下格式：<br><img src="/uploads/yet-another-ios-extension-article/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-13%20%E4%B8%8B%E5%8D%8812.05.50.png" alt></p><p>我们创建的每一个应用扩展都必须与上表的其中一个扩展点相对应，不允许出现一个应用扩展对应多个扩展点的情况。换句话说，每个应用扩展的职责都应该是单一的，我们应该给用户提供快速、线性、聚焦的体验。</p><h2 id="应用扩展是怎么工作的？">应用扩展是怎么工作的？</h2><h3 id="生命周期">生命周期</h3><p>应用扩展的生命周期有别于一般的应用。应用扩展通常会在另一个应用的使用过程中被唤起，这个应用被称为宿主应用（Host App），宿主应用定义了与应用扩展交流的上下文，并通过发送请求的方式把应用扩展给启动起来。一般来说，应用扩展在完成宿主应用请求的任务之后，生命周期就结束了。<br><img src="/uploads/yet-another-ios-extension-article/app_extensions_lifecycle_2x.png" alt></p><blockquote><p>注意区分“载体应用”和“宿主应用”。载体应用是这个应用扩展的容器，在我们实现应用扩展的时候一并开发出来的；“宿主应用”指的是实际使用过程中调起我们的应用扩展的那个应用。</p></blockquote><p>在上图第2步里，系统在启动了我们的应用扩展之后，会在应用扩展和宿主应用之间建立一条通信通道，用于传递宿主应用定义好的上下文和相关信息。</p><p>应用扩展根据宿主应用发来的请求，执行相应的任务，这些任务可能是立即返回的，也可能通过一个后台进程去完成。但无论是哪种方式，在应用扩展跑完自己的代码逻辑之后，系统就会立马把它结束掉。</p><h3 id="通信">通信</h3><p>上面提到应用扩展和宿主应用之间的通信方式，一个完整的通信关系是这样的：<br><img src="/uploads/yet-another-ios-extension-article/simple_communication_2x.png" alt></p><p>应用扩展不会直接跟载体应用打交道，因为大多数情况下，应用扩展在工作的时候，载体应用甚至都还没有被启动。</p><p>在特殊情况下，比如 Today 小组件，扩展可以向系统提出启动载体应用的申请（通过调用 <code>NSExtensionContext</code> 的 <code>openURL:completionHandler:</code> 方法）。这时，应用扩展与载体应用就可以通过一个私有的共享容器来传递数据了，如下图所示：<br><img src="/uploads/yet-another-ios-extension-article/detailed_communication_2x.png" alt></p><blockquote><p>从系统层面上看，这已经涉及到进程间通信了，但苹果提供的高级 API 很好地屏蔽了这一点，所以我们完全不用考虑这些事情。</p></blockquote><h3 id="应用扩展的-禁忌">应用扩展的“禁忌”</h3><p>因为应用扩展与一般应用的设计是不同的，所以虽然开发起来差不多，但有些 API 是应用扩展无法使用的：</p><ul><li>不能访问 <code>sharedApplication</code></li><li>不能使用头文件里宏定义了 <code>NS_EXTENSION_UNAVAILABLE</code> 的框架，比如 HealthKit 和 EventKit UI 框架</li><li>不能访问摄像头和麦克风，除非它是 iMessage 应用</li><li>不能执行耗时过长的任务，具体限制与平台相关，但是它可以通过 <code>NSURLSession</code> 对象来实现数据上传和下载，最终的结果会给到载体应用</li><li>不能接收 AirDrop 数据，但是它可以发送</li></ul><h2 id="创建应用扩展">创建应用扩展</h2><p>因为每一个扩展点都对应了一个特定的应用场景，所以创建应用扩展的第一步是选择正确的扩展点（可以回到文章开头部分查看扩展点表格）。</p><p>在 File -&gt; New -&gt; Target 里面，找到 Application Extension 模块，在里面选择想要实现的扩展点。这里我选了分享扩展作为例子：<br><img src="/uploads/yet-another-ios-extension-article/7AA6705E-C543-4011-A638-E171E66F8E54.png" alt></p><p>给你的应用扩展起个美美的名字之后，它就会出现在项目配置的侧边栏里了，同时，Xcode 还为我们新建的应用扩展添加了一个 Scheme，让我们可以直接调式扩展而不用启动载体应用：<br><img src="/uploads/yet-another-ios-extension-article/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-13%20%E4%B8%8B%E5%8D%885.45.59.png" alt></p><p>直接运行应用扩展，Xcode 会让你选一个应用来作为应用扩展的宿主：<br><img src="/uploads/yet-another-ios-extension-article/A1A7864C-EA2B-4823-A33D-91656F91569A.png" alt></p><p>分享扩展的兼容性很好，我们选 Safari 来尝试分享一个网页好了：<br><img src="/uploads/yet-another-ios-extension-article/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-13%20%E4%B8%8B%E5%8D%885.48.58.png" alt><br>随便打开一个网页，点击下面的分享按钮，可以看到我们的应用扩展已经出现在分享列表里面了！</p><blockquote><p>应用扩展的图标会跟载体应用的图标一致</p></blockquote><h2 id="talk-is-cheap">Talk is Cheap!</h2><p>创建了应用扩展之后，会发现项目结构里多了一个属于应用扩展的位置：<br><img src="/uploads/yet-another-ios-extension-article/65CB2068-CB5B-4443-A46B-3D8DC3DD5F30.png" alt></p><p>看起来就像一个普通的应用项目的结构，但 <em>Info.plist</em> 里有一个不同点，就是这里的 <code>NSExtension</code> 字典：<br><img src="/uploads/yet-another-ios-extension-article/125ED1F7-CCA8-4D23-9218-5D8212E2D5D8.png" alt><br>看名字都挺好懂的，其中的 <code>NSExtensionAttributes</code> 用来配置一些通用参数，比如支持的媒体类型等等。默认情况下，<code>NSExtensionActivationRule</code> 是一个 <code>String</code> 类型，这个值就是让系统在所有分享场景里都显示我们的应用扩展（我全都要！）。更真实的场景应该是只支持特定的文件类型，这时可以把它改成 <code>Dictionary</code> 类型：<br><img src="/uploads/yet-another-ios-extension-article/D7E348AB-33CD-4DC6-9F54-2005AE2BA66E.png" alt></p><p>上图的设置表示：我们支持分享图片、视频、文件和网页链接，后面的数字表示：一次分享中支持带上多少个这种类型的附件。</p><blockquote><p>除图片和视频外的文件类型，都包括在 File 的范围里面，所以上面的配置几乎涵盖了所有的文件分享场景了</p></blockquote><h3 id="响应请求">响应请求</h3><p>在 Xcode 创建好的 <code>ShareViewController</code> 里，我们可以通过 <code>extensionContext</code> 来拿到宿主应用想要传达给我们的信息：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> items = <span class="keyword">self</span>.extensionContext?.inputItems</span><br></pre></td></tr></table></figure><p>这是一个 <a href="https://developer.apple.com/documentation/foundation/nsextensionitem" target="_blank" rel="noopener">NSExtensionItem</a> 数组，每一个 <code>NSExtensionItem</code> 都带有一系列属性，例如标题、内容、附件、用户信息。</p><p>系统会回调 <code>didSelectPost</code> 或 <code>didSelectCancel</code> 以通知我们用户操作的结果，在这两个回调方法里，我们需要调用 <code>completeRequest(returningItems:completionHandler:)</code> 返回一系列 <code>NSExtensionItem</code> 对象给宿主应用，或者调用 <code>cancelRequest(withError:)</code> 返回一个错误。</p><h3 id="获取附件">获取附件</h3><p>从 <code>NSExtensionItems</code> 里能直接获取到的信息是远远不够的，真正的大部头都在 <code>attachments</code> 这个属性里。这是一个 <a href="https://developer.apple.com/documentation/foundation/nsitemprovider" target="_blank" rel="noopener">NSItemProvider</a> 类型的数组，自此我们就基本看到了整个 <code>NSExtensionContext</code> 的构成了，借用一张其他博客的图片：<br><img src="/uploads/yet-another-ios-extension-article/221150_8LYD_222120.png" alt></p><p>好，回到正题。拿到 <code>NSItemProvider</code> 之后，会发现要从这个类里面拿东西并不简单。</p><p>继续上面的例子，我们打算在用户点击 “Post” 按钮之后，获取从 Safari 分享过来的 URL，完整的代码是这样的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didSelectPost</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// This is called after the user selects Post. Do the upload of contentText and/or NSExtensionContext attachments.</span></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> items = extensionContext?.inputItems <span class="keyword">as</span>? [<span class="type">NSExtensionItem</span>] <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items &#123;</span><br><span class="line">        <span class="keyword">for</span> attachment <span class="keyword">in</span> item.attachments ?? [] &#123;</span><br><span class="line">            <span class="comment">// 3</span></span><br><span class="line">            <span class="keyword">if</span> attachment.hasItemConformingToTypeIdentifier(kUTTypeURL <span class="keyword">as</span> <span class="type">String</span>) &#123;</span><br><span class="line">                <span class="comment">// 4</span></span><br><span class="line">                attachment.loadItem(forTypeIdentifier: kUTTypeURL <span class="keyword">as</span> <span class="type">String</span>, options: <span class="literal">nil</span>) &#123; (item, error) <span class="keyword">in</span></span><br><span class="line">                                                                                            <span class="keyword">if</span> error == <span class="literal">nil</span> &#123;</span><br><span class="line">                                                                                                <span class="built_in">print</span>(<span class="string">"found an url: \(item)"</span>)</span><br><span class="line">                                                                                            &#125;</span><br><span class="line">                                                                                           &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inform the host that we're done, so it un-blocks its UI. Note: Alternatively you could call super's -didSelectPost, which will similarly complete the extension context.</span></span><br><span class="line">    <span class="keyword">self</span>.extensionContext!.completeRequest(returningItems: [], completionHandler: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>inputItems</code> 是一个 <code>[Any]</code> 类型的数组，所以在使用之前需要转换一下</li><li>如果允许用户分享的时候多选的话，需要逐层遍历 <code>items</code> 和 <code>attachments</code></li><li>判断附件的类型，附件类型使用 <a href="https://developer.apple.com/library/archive/documentation/Miscellaneous/Reference/UTIRef/Articles/System-DeclaredUniformTypeIdentifiers.html#//apple_ref/doc/uid/TP40009259-SW1" target="_blank" rel="noopener">UTI（Uniform Type Identifier）</a> 来表示，在 iOS 平台使用的时候需要先执行 <code>import MobileCoreService</code></li><li>读取指定类型的附件内容，回调过来的 <code>item</code> 是 <code>NSSecureCoding?</code> 类型的，这里只简单打印了一下，真正使用的时候还需要补充一些额外处理</li></ol><h2 id="性能要求">性能要求</h2><p>应用扩展对于用户来说应该是敏捷而且轻量的小工具，所以它的启动速度务必要保持在1秒以内，系统会自动关闭启动耗时太长的应用扩展。</p><p>对于 Widget 来说，界面上通常会一次显示多个，所以 Widget 的内存使用要求是最严格的（大概是16 MB），一旦超出了限制，会显示 “Unable to Load” 的字样：<br><img src="/uploads/yet-another-ios-extension-article/TodayWidgetUnableToLoad.jpg" alt></p><p>其他类型的应用扩展对内存的要求会松一点，但还是比一般应用要严格，比如自定义键盘要求 48 MB 以下，分享扩展要求 120 MB 以下，实际情况可能跟设备相关。</p><p>另外，应用扩展是公用同一个主线程的，所以不要在应用扩展的逻辑里做可能会阻塞主线程的操作。同理，GPU 也是这样一个共享资源，如果一个应用扩展需要执行大量绘图逻辑，系统会倾向于把它结束掉。</p><p>总而言之，开销大的操作都应该在载体应用里做，而不是让应用扩展去负责。</p><h2 id="总结一下">总结一下</h2><p>本文介绍了什么是应用扩展，并介绍了一个简单的分享扩展是怎么实现的。文章大体是来源于官方的文档，虽然文档已经被苹果归档了，但是文中的代码都是我写完用模拟器验证后得来的（2018年11月14日），大家可以直接拿走按需服用 :)</p><blockquote><p>没想到只是介绍了一些基础就写了这么多。其实我还打算讲讲分享之后怎么跟载体应用交互，还想要看看今日小组件（Today Widget）怎么整…只好放到后面的文章里去了。  我发誓在这周之内把这两部分内容都给补上来！</p><p>你们看，我写完了：</p><ul><li><a href="/2018/11/14/yet-another-ios-extension-article-2/" title="又一篇 iOS Extension 入门（2/3）— 与容器沟通">又一篇 iOS Extension 入门（2/3）— 与容器沟通</a></li><li><a href="/2018/11/15/yet-another-ios-extension-article-3/" title="又一篇 iOS Extension 入门（3/3）— Today 小组件">又一篇 iOS Extension 入门（3/3）— Today 小组件</a></li></ul></blockquote><h2 id="参考文章">参考文章</h2><ul><li><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/index.html#//apple_ref/doc/uid/TP40014214-CH20-SW1" target="_blank" rel="noopener">App Extension Programming Guide: App Extensions Increase Your Impact</a></li><li><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/Share.html#//apple_ref/doc/uid/TP40014214-CH12-SW1" target="_blank" rel="noopener">App Extension Programming Guide: Share</a></li><li><a href="https://my.oschina.net/vimfung/blog/707448" target="_blank" rel="noopener">iOS扩展开发攻略(一) - Share Extension - vimfung的开源部落 - 开源中国</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;应用扩展（App Extension）让你应用的功能和内容都得到了更大的延伸，这让用户在使用其他应用的时候有机会与你的应用发生交互。在这个大家都极力争夺注意力的时代，应用扩展无疑为我们打开了一扇新的大门。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ios" scheme="http://davidleee.com/tags/ios/"/>
    
      <category term="App Groups" scheme="http://davidleee.com/tags/App-Groups/"/>
    
      <category term="Extension" scheme="http://davidleee.com/tags/Extension/"/>
    
      <category term="Share" scheme="http://davidleee.com/tags/Share/"/>
    
      <category term="NSExtensionItem" scheme="http://davidleee.com/tags/NSExtensionItem/"/>
    
      <category term="NSItemProvider" scheme="http://davidleee.com/tags/NSItemProvider/"/>
    
  </entry>
  
  <entry>
    <title>怎么在命令行给 macOS 设置开机启动任务</title>
    <link href="http://davidleee.com/2018/11/07/login-items-for-macos/"/>
    <id>http://davidleee.com/2018/11/07/login-items-for-macos/</id>
    <published>2018-11-07T08:16:12.000Z</published>
    <updated>2020-05-05T03:43:31.443Z</updated>
    
    <content type="html"><![CDATA[<p>最近通过 docker + nginx 在 一台 Mac mini 上面配了个简易文件系统，好让其他人能方便地下载一些预先写好的配置文件，这部分就不细说了。文件系统跑起来之后，考虑到便利性，想要再添加一个开机自启动的逻辑，让这个文件系统在电脑重启之后也能自己跑起来。</p><p>在 Linux 系统下面，我们可以通过 <code>systemctl</code>  或者直接修改 <em>rc.local</em> 文件<br>来实现启动项的添加。但是这一套在 macOS 上面玩不转了，因为我们需要通过一个完全不一样的机制—— <strong>Launch Daemon</strong> 来实现这个功能。</p><a id="more"></a><h2 id="要做的事情">要做的事情</h2><p>因为 macOS 的启动项是通过一个 plist 去配置的，配置一个脚本远比配置一段要执行的命令行指令要简单，所以这里采用脚本的方式去实现。</p><p>于是我们要做的事情只有两步：</p><ol><li>创建一个脚本文件去执行 docker-compose 的启动指令</li><li>让这个脚本在系统启动的时候执行（不需要用户登录）</li></ol><h2 id="开始吧">开始吧</h2><h3 id="创建脚本">创建脚本</h3><p>先创建一个脚本文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim startup.sh</span><br></pre></td></tr></table></figure><p>不考虑异常情况，就是简单地进到 docker-compose.yaml 所在的目录，然后执行一下启动命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">cd /Users/davidleee/Desktop/docker-nginx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> make sure it runs</span></span><br><span class="line">while [ $(docker inspect -f '&#123;&#123;.State.Running&#125;&#125;' docker-nginx_nginx_1) != "true" ]</span><br><span class="line">do</span><br><span class="line">  echo "Launching file-service with docker-compose..."</span><br><span class="line">  docker-compose up -d</span><br><span class="line">  sleep 2</span><br><span class="line">done</span><br></pre></td></tr></table></figure><blockquote><p>为了避免我们执行 <code>docker-compose</code> 的时候 docker 自己还没有跑起来，所以用一个循环去检测我们的服务是不是真的启动了。</p><p>另外还要记得把上面的 <code>docker-nginx_nginx_1</code> 改成你真正的的容器名称。</p></blockquote><p>别忘了给脚本加上执行权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x startup.sh</span><br></pre></td></tr></table></figure><h3 id="配置启动项">配置启动项</h3><p>现在我们要把上面的脚本添加到 <strong>Launch Daemon</strong> 里面去。</p><p>在此之前，让我们先理清一些概念。</p><p>macOS 通过一系列的 plist 文件来配置启动项，这些 plist 根据存放位置的不同而分为 <strong>Launch Daemon</strong> 和 <strong>Launch Agent</strong>。它们的区别在于，Agent 是在用户登录之后以该用户的身份去执行的任务，而 Daemon 是以根用户或 <code>UserName</code> 里指定的用户去执行的任务。</p><p>它们一般存放在这两个地方：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/Library/LaunchDaemons</span><br><span class="line"></span><br><span class="line">/Library/LaunchAgents/</span><br></pre></td></tr></table></figure><p>我们这次的任务需要用到 root 权限，所以我们将会在 LaunchDaemons 里创建一个配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /Library/LaunchDaemons/com.file-service.plist</span><br></pre></td></tr></table></figure><p>然后在里面填上以下内容：（注释部分可以去掉咯）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">plist</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//Apple//DTD PLIST 1.0//EN"</span> <span class="meta-string">" [http://www.apple.com/DTDs/PropertyList-1.0.dtd](http://www.apple.com/DTDs/PropertyList-1.0.dtd) "</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plist</span> <span class="attr">version</span>=<span class="string">"1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Launch Daemon 不一定有权限访问所有需要的环境变量</span></span><br><span class="line"><span class="comment">在没有权限的时候，启动项执行会失败，所以我们在这里配置一下脚本需要的环境变量 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>EnvironmentVariables<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">key</span>&gt;</span>PATH<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">string</span>&gt;</span>/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>Label<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 习惯上，我们会用一个 identifier 样式的名字来作为启动项的名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>com.file-service<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>Program<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 要执行的脚本的绝对路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>/Users/davidleee/Desktop/docker-nginx/startup.sh<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这个 key 告诉系统在启动的时候执行我们的脚本</span></span><br><span class="line"><span class="comment">  对于 daemons 来说是系统启动之后，对于 agent 来说则是用户登录之后 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>RunAtLoad<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 判断是按需启动我们的启动项，还是永远运行下去</span></span><br><span class="line"><span class="comment">现在我们自己跑的是自己的脚本，按需启动就可以了 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>KeepAlive<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">false</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>LaunchOnlyOnce<span class="tag">&lt;/<span class="name">key</span>&gt;</span>        </span><br><span class="line">    <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在调试脚本的时候很好用，可以指定脚本正常/错误输出的路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>StandardOutPath<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>/tmp/startup.stdout<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>StandardErrorPath<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>/tmp/startup.stderr<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>UserName<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 执行脚本的用户 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>davidleee<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plist</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后就是把这个 plist 加载到 launchctl 里面去了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># `-w` 会把 plist 永久添加到 Launch Daemon 里面</span></span><br><span class="line">sudo launchctl load -w /Library/LaunchDaemons/com.file-service.plist</span><br><span class="line"></span><br><span class="line"><span class="comment"># ...如果你不想让它自启动了</span></span><br><span class="line">sudo launchctl unload -w /Library/LaunchDaemons/com.file-service.plist</span><br></pre></td></tr></table></figure><h2 id="写在最后">写在最后</h2><p>在执行完上面的 <code>launchctl load</code> 指令之后，plist 里面配置的脚本会马上被执行，你可以通过 <code>launchctl start</code> 和 <code>launchctl stop</code> 来控制它的开关，不过我们这里只是执行了一个脚本，并不会像其他应用那样长驻，所以其实也就没有“开关”一说了。</p><h2 id="参考文章">参考文章</h2><ul><li><a href="https://medium.com/@fahimhossain_16989/adding-startup-scripts-to-launch-daemon-on-mac-os-x-sierra-10-12-6-7e0318c74de1" target="_blank" rel="noopener">Adding Startup Scripts to Launch Daemon on Mac OS X Sierra 10.12.6</a></li><li><a href="https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingLaunchdJobs.html" target="_blank" rel="noopener">Creating Launch Daemons and Agents</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近通过 docker + nginx 在 一台 Mac mini 上面配了个简易文件系统，好让其他人能方便地下载一些预先写好的配置文件，这部分就不细说了。文件系统跑起来之后，考虑到便利性，想要再添加一个开机自启动的逻辑，让这个文件系统在电脑重启之后也能自己跑起来。&lt;/p&gt;
&lt;p&gt;在 Linux 系统下面，我们可以通过 &lt;code&gt;systemctl&lt;/code&gt;  或者直接修改 &lt;em&gt;rc.local&lt;/em&gt; 文件&lt;br&gt;
来实现启动项的添加。但是这一套在 macOS 上面玩不转了，因为我们需要通过一个完全不一样的机制—— &lt;strong&gt;Launch Daemon&lt;/strong&gt; 来实现这个功能。&lt;/p&gt;
    
    </summary>
    
    
      <category term="macOS" scheme="http://davidleee.com/tags/macOS/"/>
    
      <category term="Launch Daemons" scheme="http://davidleee.com/tags/Launch-Daemons/"/>
    
      <category term="Launch Agent" scheme="http://davidleee.com/tags/Launch-Agent/"/>
    
      <category term="plist" scheme="http://davidleee.com/tags/plist/"/>
    
      <category term="launchctl" scheme="http://davidleee.com/tags/launchctl/"/>
    
  </entry>
  
  <entry>
    <title>SVG 从“完全不懂”到“足够开个入门分享”</title>
    <link href="http://davidleee.com/2018/10/25/SVG-from-nothing-to-something/"/>
    <id>http://davidleee.com/2018/10/25/SVG-from-nothing-to-something/</id>
    <published>2018-10-25T07:08:10.000Z</published>
    <updated>2020-05-05T03:43:31.442Z</updated>
    
    <content type="html"><![CDATA[<p>最近需要在 React-Native 项目里实现一个填满特定图形的效果，找很久都没发现能满足需求的开源库，于是就打算用 SVG 自己怼一个。好在这方面教程还不少，虽然不能一步到位，但几篇文章加一起也能把效果实现出来，于是在这里把入门过程记录一下，希望帮后来者省点功夫。</p><a id="more"></a><h2 id="svg-是个啥？">SVG 是个啥？</h2><p>SVG（Scalable Vector Graphics） 是一种基于 XML 语法的图像格式。跟基于像素处理的图片格式不同，它是基于对图像形状的描述来实现的，本质上是一个文本文件，体积上较小，而且在放大的时候也不会失真。</p><p>因为 SVG 是基于 XML 语法的，所以对于前端开发者来说，写起来应该比较顺手；对于 React-Native 的项目，因为 JSX 的关系，用起 SVG 来也是没有“语言障碍”的。</p><h2 id="svg-长什么样？">SVG 长什么样？</h2><p>直接上源码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">'100'</span> <span class="attr">height</span>=<span class="string">"100"</span> <span class="attr">viewBox</span>=<span class="string">"0 0 100 100"</span> <span class="attr">version</span>=<span class="string">"1.1"</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/2000/svg"</span> <span class="attr">xmlns:xlink</span>=<span class="string">"http://www.w3.org/1999/xlink"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">defs</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">clipPath</span> <span class="attr">id</span>=<span class="string">"heart"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">"M81.495,13.923c-11.368-5.261-26.234-0.311-31.489,11.032C44.74,13.612,29.879,8.657,18.511,13.923  C6.402,19.539,0.613,33.883,10.175,50.804c6.792,12.04,18.826,21.111,39.831,37.379c20.993-16.268,33.033-25.344,39.819-37.379  C99.387,33.883,93.598,19.539,81.495,13.923z"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">clipPath</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">defs</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">'0'</span> <span class="attr">y</span>=<span class="string">'0'</span> <span class="attr">fill</span>=<span class="string">'rgb(217,217,217)'</span> <span class="attr">width</span>=<span class="string">"100%"</span> <span class="attr">height</span>=<span class="string">"100%"</span> <span class="attr">clip-path</span>=<span class="string">"url(#heart)"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">'0%'</span> <span class="attr">y</span>=<span class="string">"50%"</span> <span class="attr">fill</span>=<span class="string">'red'</span> <span class="attr">width</span>=<span class="string">"100%"</span> <span class="attr">height</span>=<span class="string">"100%"</span> <span class="attr">clip-path</span>=<span class="string">"url(#heart)"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这张 SVG 图渲染出来是这样的：<br><img src="/uploads/SVG-from-nothing-to-something/57D524DA-6FD7-4538-A238-B002D099D91A.png" alt></p><blockquote><p>直接把上面的代码保存为文本，就可以用浏览器打开并显示了。macOS 的用户还可以直接空格预览。</p></blockquote><p>配合一些参数的改变，做动画也是分分钟的事情。对于之前没有怎么用过 SVG 的我来说，简直是打开了新世界的大门。</p><p>接下来就让我们一起探究一下上面这个图是怎么来的。</p><h2 id="svg-显示原理">SVG 显示原理</h2><p>根据上面的例子，我们可以大胆猜测一下： <code>&lt;path&gt;</code> 标签下 <code>d</code> 属性的值就是用来描绘这个心形的外框路径的。既然描绘路径已经是确定的了，那一张 SVG 图片是怎么实现缩放不失真的特性的呢？<br>要回答这个问题，就要让我们先了解一下 SVG 的一些基本显示原理。</p><h3 id="the-svg-canvas">The SVG Canvas</h3><p>假设我们要将一个 SVG 图形绘制到一张画布（Canvas）上，概念上这张画布应该是无限大的，这样我们的图形才可以是任意大小。然而，实际上 SVG 图片是显示在一个有限的区域里的，就像我们透过窗户看窗外的风景一样，这个有限区域被称为“观察孔”（Viewport）。</p><h3 id="the-viewport">The Viewport</h3><p>“观察孔”指的是 SVG 图片可见的那一部分，想象我们透过窗户看窗外的风景，这个窗子就是外面风景的观察孔。</p><blockquote><p>类似的，我们在浏览网页的时候面对的也是这种情况，网页的大小通常比浏览器的窗口要大，这时候浏览器就是这个网页的观察孔了。</p></blockquote><p>我们通过设置 <code>&lt;svg&gt;</code> 标签的 <code>width</code> 和 <code>height</code> 属性来确定这张 SVG 的观察孔大小，对于上面的心形来说，观察孔是 100x100 的正方形：</p><figure class="highlight svg"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- the viewport will be 100px by 100px --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"100"</span> <span class="attr">height</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- SVG content drawn onto the SVG canvas --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>在 SVG 里，数值的单位是可选的。在我们不主动提供的时候，默认会以 <code>px</code> 为单位。可选的单位有 <code>em</code>、<code>ex</code>、<code>px</code>、<code>pt</code>、<code>pc</code>、<code>cm</code>、<code>mm</code>、<code>in</code> 和百分比。</p></blockquote><h3 id="坐标系统">坐标系统</h3><p>在观察孔的大小确定下来之后，SVG 就会建立一套初始的坐标系统：以最左上角为 <code>(0, 0)</code> 点，x 轴和 y 轴分别向右和向下延伸（就像移动客户端和网页显示里那样）。在这个基础上，我们刚刚创建的观察孔也就有了属于自己的一套位置标识：<code>(x: 0, y: 0, width: 100, height: 100)</code>。</p><h2 id="the-viewbox">The <code>viewbox</code></h2><p>在了解了上述知识之后，我们就可以来说说 <code>viewbox</code> 这个属性了。</p><p>我们可以把 <code>viewbox</code> 理解为“真正的坐标系统”，因为它决定了 SVG 图形是怎么绘制到画布上的。一个 SVG 图形的大小可以与观察孔不一样，它可能会完整地显示出来，也可能会被观察孔裁减掉一部分。</p><blockquote><p>就像一张普通图片一样，当你需要把图形完整地放进一个视图里面时，可以调节图片的拉伸模式，一边让图片的大小更为合理。SVG 里对应的属性是 <code>preserveAspectRatio</code>。</p></blockquote><p><code>viewbox</code>  会一次性设置4个参数：</p><figure class="highlight svg"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">viewbox</span>=<span class="string">"&lt;min-x&gt; &lt;min-y&gt; &lt;width&gt; &lt;height&gt;"</span>&gt;</span><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中，<code>&lt;min-x&gt;</code> 和 <code>&lt;min-y&gt;</code> 不能设置为负数，<code>&lt;width&gt;</code> 和 <code>&lt;height&gt;</code> 设置为 0 的话，元素就压根不会绘制了。</p><p>所以说，<code>viewbox=&quot;0 0 100 100&quot;</code> 就做了下面几件事情：</p><ol><li>在画布上划分出来一个 100x100 大小的区域，放在 (0, 0) 点上</li><li>把 SVG 图形缩放成合适这个区域的样子</li><li>将整个区域（包括里面的图形）放大到铺满整个观察孔</li><li>将这个坐标系统<strong>按比例</strong>映射到到初始坐标系统上</li></ol><p>那对于上面的爱心图片来说，我们尝试调整一下 <code>viewbox</code> 的原点，将它设置为 <code>viewbox=&quot;50 50 100 100&quot;</code> 试试：<br><img src="/uploads/SVG-from-nothing-to-something/353B4442-E68D-4F8A-8D53-CE5EEED21F36.png" alt><br>可以看到，就像地图软件一样，镜头往画面的右下方移动了一段。这也相当于把整个画面往左上方推了过去一点，我们可以通过设置画布的 <code>transform</code> 属性来实现相同的效果：<code>transform=&quot;translate(-50 -50)&quot;</code>。</p><blockquote><p>当设计师给你一张 SVG 图片的时候，其中的图案路径可能是按照一定的大小和位移来绘制的，比如从(10, 10) 点开始画的一张 40x40 的图，这时候你的 <code>viewbox</code> 就应该设置为 <code>viewbox=&quot;10 10 40 40&quot;</code> ，让图片放到最合适的坐标系统上。</p></blockquote><h2 id="小结">小结</h2><p>上面的例子演示了一张 SVG 图的常规操作，限于篇幅原因，还有一些有意思的情况没有展示到，比如当 <code>viewbox</code> 里设置的宽高比与我们在 <code>&lt;svg&gt;</code> 标签里设置的宽高比不一样会发生什么呢？这种情况下，就需要我们去了解一下 <code>preserveAspectRatio</code> 属性了。</p><p>在参考文章 <a href="https://www.sarasoueidan.com/blog/svg-coordinate-systems/" target="_blank" rel="noopener">Understanding SVG Coordinate Systems and Transformations (Part 1) </a> 里，有对这方面更详细的解释，而且作者还提供了非常直观的在线预览工具，相信会对偏向于使用图像思维的同学们更有帮助。</p><h2 id="参考文章">参考文章</h2><ul><li><a href="https://www.sarasoueidan.com/blog/svg-coordinate-systems/" target="_blank" rel="noopener">Understanding SVG Coordinate Systems and Transformations (Part 1) </a></li><li><a href="http://www.ruanyifeng.com/blog/2018/08/svg.html" target="_blank" rel="noopener">SVG 图像入门教程 - 阮一峰的网络日志</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近需要在 React-Native 项目里实现一个填满特定图形的效果，找很久都没发现能满足需求的开源库，于是就打算用 SVG 自己怼一个。好在这方面教程还不少，虽然不能一步到位，但几篇文章加一起也能把效果实现出来，于是在这里把入门过程记录一下，希望帮后来者省点功夫。&lt;/p&gt;
    
    </summary>
    
    
      <category term="svg" scheme="http://davidleee.com/tags/svg/"/>
    
      <category term="xml" scheme="http://davidleee.com/tags/xml/"/>
    
      <category term="markup" scheme="http://davidleee.com/tags/markup/"/>
    
      <category term="react-native" scheme="http://davidleee.com/tags/react-native/"/>
    
      <category term="viewbox" scheme="http://davidleee.com/tags/viewbox/"/>
    
      <category term="clippath" scheme="http://davidleee.com/tags/clippath/"/>
    
  </entry>
  
  <entry>
    <title>CSS 句法</title>
    <link href="http://davidleee.com/2018/10/19/CSS-syntax/"/>
    <id>http://davidleee.com/2018/10/19/CSS-syntax/</id>
    <published>2018-10-19T11:54:42.000Z</published>
    <updated>2020-05-05T03:43:31.441Z</updated>
    
    <content type="html"><![CDATA[<p>CSS 是声明型语言，这让它的句法（syntax）非常直白易懂。</p><p>除此之外，它还有很好的错误恢复机制，它能避免在错误发生时把所有东西都弄得一团乱：比如说在它碰到不认识的声明时，它会直接忽略掉这个东西。但从另一方面来说，这也让错误更难被发现了。</p><p>借着最近前端同事事务繁忙的机会，我这客户端工程师赶鸭子上架怼了一个静态网页出来，顺便产下了两篇副产品，都与 CSS 基础相关，这是第二篇（第一篇在此： <a href="/2018/10/19/How-CSS-works/" title="CSS 是怎么运作的">CSS 是怎么运作的</a>），希望对其他可能有相同需要的同志送上一些帮助。</p><a id="more"></a><h2 id="名词解释">名词解释</h2><p>正如<a href="/2018/10/19/How-CSS-works/" title="上一篇文章">上一篇文章</a>里说到的，CSS 是由选择器和一组属性组成的。其中，属性部分是由一系列的键值对组成，在 CSS 的世界里，它们有着自己的名字：</p><ul><li>属性（Properties）：以“说人话”的方式表明这个玩意儿是干什么的</li><li>值（Values）：每个属性都会有对应的值，表示你想要怎么修改这个东西</li></ul><p>这样的一组“属性-值”的组合，我在前面直接称呼为“键值对”了，但它在 CSS 世界里的本名其实是 <strong>CSS 声明（CSS declaration）</strong>。<br>被一对大括号包裹起来的一组 CSS 声明被称为 <strong>CSS 声明块（CSS declaration blocks）</strong>。<br>最后，一个 CSS 声明块会跟一个选择器搭配起来，称为 <strong>CSS 规则（CSS Rulesets/Rules）</strong>。</p><h3 id="css-声明">CSS 声明</h3><p>把 CSS 属性设置为一个特定的值，可以说是 CSS 这门语言的最核心功能了。需要注意的是，属性和值都是区分大小写的，它们之间用 “:” 来分隔。</p><p>目前，CSS 世界里一共有<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Reference" target="_blank" rel="noopener">300 种不同的属性</a>，每种属性都有其对应的可选值。</p><blockquote><p>在 CSS 语法里（包括其他 web 标准中），美式拼写是唯一的拼写标准。比如说，在需要设置颜色的时候，<code>color</code> 永远优于 <code>colour</code>。</p></blockquote><h3 id="css-声明块">CSS 声明块</h3><p>CSS 声明以代码块的形式存在，用一对大括号括起来。</p><blockquote><p>CSS 声明块可以是空的（里面不带任何声明）</p></blockquote><p>CSS 声明块里的不同声明是通过 “;” 来分隔的。</p><blockquote><p>实际上，最后一组声明是可以不用分号结尾的，但是好好的干嘛要逼死强迫症呢？</p></blockquote><h3 id="css-选择器和规则">CSS 选择器和规则</h3><p>在写好了声明块之后，我们还需要告诉浏览器这些属性要用到哪里去，这就需要在这个声明块前面加上一个前缀——选择器了。</p><p>选择器可以是非常复杂的：你可以把一个声明块应用到好几个选择器上，通过逗号分隔；你还可以链式地构造一个指向性更明确的选择器，比如：选择一个类名是 “abc” 的元素，它要在 <code>&lt;article&gt;</code> 标签下，而且只有鼠标移动到它上面的时候才生效。</p><p>一个元素可能被多个选择器看上，所以同一个属性可能会被改变多次，CSS 会通过层叠算法（cascade algorithm）来判断这些属性修改的优先级。</p><blockquote><p>对于同一个声明块，在使用复杂选择器的时候（比如存在多个选择器），如果其中的某一项选择有误，那么其他的选择器是不会被影响的，该怎么工作还是怎么工作。</p></blockquote><h3 id="css-语句">CSS 语句</h3><p>除了上面看到的声明块之外， CSS 里还有一些其他类型的语句：</p><ul><li><strong>At-规则</strong> 用来传达元数据、条件信息或其他描述性信息。比如说：<ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@charset" target="_blank" rel="noopener">@charset</a>  和  <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@import" target="_blank" rel="noopener">@import</a>  (元数据)</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@media" target="_blank" rel="noopener">@media</a>  或者  <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@document" target="_blank" rel="noopener">@document</a>  (条件信息，也叫内部语法)</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face" target="_blank" rel="noopener">@font-face</a>  (描述性信息)<br>完整的写法是这样的：</li></ul></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">'custom.css'</span>; <span class="comment">/* 从另一个 css 文件中引入规则 */</span></span><br></pre></td></tr></table></figure><ul><li><strong>内部语法（Nested statements）</strong> 是 at-规则 的一个子集，这类规则只会在特定条件下才会生效：<ul><li><code>@media</code> 运行设备符合某些条件时才执行</li><li><code>@supports</code> 浏览器支持某些测试特性的时候才执行</li><li><code>@document</code> 当前页面符合某些条件时才执行<br>举个例子：</li></ul></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width:</span> <span class="number">801px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">800px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述针对 <code>body</code> 的规则，只在设备宽度大于 800px 的时候才会生效。</p><h2 id="小结">小结</h2><p>分两篇叙述的 CSS 相关知识就讲完了。这两篇文章的主要目的是把我们领进前端世界的大门，读完之后，我们应该可以实现一些简单的静态页面了！<sub>（小声说：虽然具体怎么用还需要自己去谷歌百度一下）</sub>当然，前端的魅力还远不止如此，要想把 CSS 玩出花儿来，还需要持续的磨练。</p><p>我这个半吊子的前端工程师总算是把整个静态页面的需求给怼出来啦！接下来如果有时间的话，我会再把页面里用到的一些 JS 实现的逻辑也拉出来溜一溜。要是这下一篇文章真的有诞生之日的话，那读到完整三个部分的同学们就会在前端界六得飞起<sub>（假的）</sub>了！</p><h2 id="参考文章">参考文章</h2><p><a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Introduction_to_CSS/Syntax" target="_blank" rel="noopener">CSS syntax - Learn web development | MDN</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSS 是声明型语言，这让它的句法（syntax）非常直白易懂。&lt;/p&gt;
&lt;p&gt;除此之外，它还有很好的错误恢复机制，它能避免在错误发生时把所有东西都弄得一团乱：比如说在它碰到不认识的声明时，它会直接忽略掉这个东西。但从另一方面来说，这也让错误更难被发现了。&lt;/p&gt;
&lt;p&gt;借着最近前端同事事务繁忙的机会，我这客户端工程师赶鸭子上架怼了一个静态网页出来，顺便产下了两篇副产品，都与 CSS 基础相关，这是第二篇（第一篇在此： &lt;a href=&quot;/2018/10/19/How-CSS-works/&quot; title=&quot;CSS 是怎么运作的&quot;&gt;CSS 是怎么运作的&lt;/a&gt;），希望对其他可能有相同需要的同志送上一些帮助。&lt;/p&gt;
    
    </summary>
    
    
      <category term="css" scheme="http://davidleee.com/tags/css/"/>
    
      <category term="html" scheme="http://davidleee.com/tags/html/"/>
    
      <category term="web" scheme="http://davidleee.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>CSS 是怎么运作的</title>
    <link href="http://davidleee.com/2018/10/19/How-CSS-works/"/>
    <id>http://davidleee.com/2018/10/19/How-CSS-works/</id>
    <published>2018-10-19T11:28:35.000Z</published>
    <updated>2020-05-05T03:43:31.441Z</updated>
    
    <content type="html"><![CDATA[<p>CSS 全称 Cascading Style Sheets，网页内容（HTML）会被浏览器转换为 DOM（Document Object Model）以供显示，而 CSS 就是作用在 DOM 上以改变它们的样式、布局或行为等。对于前端工程师来说，这是很常见的基本操作了，但是对其他不常敲网页代码的程序员来说，却可能会有些陌生。</p><p>借着最近前端同事事务繁忙的机会，我这客户端工程师赶鸭子上架怼了一个静态网页出来，顺便产下了两篇副产品，都与 CSS 基础相关，这是第一篇，希望能对其他可能有相同需要的同志送上一些帮助。</p><a id="more"></a><blockquote><p>文章的内容基本是翻译 MDN 文档来的，怕有什么遗漏的同学可以直接翻到文末看官文，也欢迎指出本文的错误 :)</p></blockquote><h2 id="css-是怎么作用到-html-上的？">CSS 是怎么作用到 HTML 上的？</h2><p>网页浏览器会把 CSS 规则应用到文档上，以改变文档内容的表现形式，一个单一的 CSS 规则是由下面这两个东西组成的：</p><ol><li>一组属性（Properties）：这些参数会更新 HTML 的内容，让它在显示的时候与众不同</li><li>一个选择器（Selector）：用来挑选要作用到哪个元素上</li></ol><p>一个 CSS 规则约定了某个元素长什么样，一个包含了一组 CSS 规则（Rulesets/Rules）的 <code>stylesheet</code> 就定义了一个网页的长相。</p><h3 id="举个例子">举个例子</h3><p>来看一个简单的 HTML 文档，这个例子里包含了 <code>&lt;h1&gt;</code> 和 <code>&lt;p&gt;</code> 标签，而 <code>stylesheet</code> 则是通过 <code>&lt;link&gt;</code> 元素实现的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>My CSS experiment<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"style.css"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is my first CSS example<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后看两个 CSS 的规则：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">  <span class="attribute">background-color</span>: yellow;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这两个 CSS 规则是写在 <em>style.css</em> 文件里的，跟上面的 <em>.html</em> 文件放在一起就可以通过相对路径引用到</p></blockquote><p>大括号签名的标签（<code>h1</code> 和 <code>p</code>）就是选择器，它告诉浏览器这些规则要作用在什么标签上；而大括号里的键值对就约定了这些标签的内容的显示规则。</p><h2 id="原理呢？">原理呢？</h2><p>浏览器在处理网页的时候，会分两步走：</p><ol><li>把 HTML 和 CSS 转换为 DOM，DOM 会把内容和样式融合到一起</li><li>把 DOM 的内容显示出来<br><img src="/uploads/How-CSS-works/D90AF498-F58B-4AEF-91B9-9E38F4863B92.png" alt="DOM"></li></ol><h2 id="介绍一下-dom">介绍一下 DOM</h2><p>一个 DOM 的内容是以树状结构保存的。每个通过 markup 语言表述的元素、属性、文字等会变成 DOM 节点保存在树上。</p><h3 id="dom-的真面目">DOM 的真面目</h3><p>假设我们有一段 HTML 代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  Let's use:</span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Cascading<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Style<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Sheets<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将它转换为 DOM 之后，这个 DOM 会是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">P</span><br><span class="line">├─ &quot;Let&apos;s use:&quot;</span><br><span class="line">├─ SPAN</span><br><span class="line">|  └─ &quot;Cascading&quot;</span><br><span class="line">├─ SPAN</span><br><span class="line">|  └─ &quot;Style&quot;</span><br><span class="line">└─ SPAN</span><br><span class="line">   └─ &quot;Sheets&quot;</span><br></pre></td></tr></table></figure><p>现在来加一个 CSS 约束试试：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">  <span class="attribute">background-color</span>: lime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>emmm…还是跟刚刚一样的 DOM，不过这些 CSS 约束会被加到 <code>span</code> 选择器上面去，于是渲染出来的样子就不一样了。</p><h2 id="三种使用-css-的方法">三种使用 CSS 的方法</h2><h3 id="外部-stylesheet">外部 stylesheet</h3><p>就是上面例子里用到的方法，CSS 约束是写在一个单独的 <em>.css</em> 文件里的</p><h3 id="内部-stylesheet">内部 stylesheet</h3><p>即直接通过 <code>&lt;style&gt;</code> 标签来定义元素的长相，这个 <code>&lt;style&gt;</code> 需要写在 <code>&lt;head&gt;</code> 标签下才会生效：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>My CSS experiment<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">      h1 &#123;</span><br><span class="line">        color: blue;</span><br><span class="line">        background-color: yellow;</span><br><span class="line">        border: 1px solid black;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      p &#123;</span><br><span class="line">        color: red;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is my first CSS example<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个例子跟之前的例子是同样效果的。</p><h3 id="内联样式">内联样式</h3><p>对于只想改变单独一个标签元素的情况下，可以通过标签的 <code>style</code> 属性实现：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>My CSS experiment<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">"color: blue;background-color: yellow;border: 1px solid black;"</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"color:red;"</span>&gt;</span>This is my first CSS example<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然而这种做法并没有很受待见，因为这样定义的样式没办法复用，你可能需要在好几个文档里面写上同样的几个样式，维护成本大大升高了。</p><p>另一方面，把 HTML 语法跟 CSS 语法混合在一起，看起来就不那么清晰易懂了，建议是把不同类型的代码分开，保持纯粹。</p><h2 id="小结">小结</h2><p>到这里，我们已经不止能写 HTML 网页了，还能通过 CSS 给这简陋的网页披上华丽丽的外衣。在下一篇文章里，我们会继续深入学习 CSS 的句法，距离踏入前端世界的大门又要近一些了！</p><h2 id="参考文章">参考文章</h2><p><a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Introduction_to_CSS/How_CSS_works" target="_blank" rel="noopener">How CSS works - Learn web development | MDN</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSS 全称 Cascading Style Sheets，网页内容（HTML）会被浏览器转换为 DOM（Document Object Model）以供显示，而 CSS 就是作用在 DOM 上以改变它们的样式、布局或行为等。对于前端工程师来说，这是很常见的基本操作了，但是对其他不常敲网页代码的程序员来说，却可能会有些陌生。&lt;/p&gt;
&lt;p&gt;借着最近前端同事事务繁忙的机会，我这客户端工程师赶鸭子上架怼了一个静态网页出来，顺便产下了两篇副产品，都与 CSS 基础相关，这是第一篇，希望能对其他可能有相同需要的同志送上一些帮助。&lt;/p&gt;
    
    </summary>
    
    
      <category term="css" scheme="http://davidleee.com/tags/css/"/>
    
      <category term="html" scheme="http://davidleee.com/tags/html/"/>
    
      <category term="web" scheme="http://davidleee.com/tags/web/"/>
    
      <category term="dom" scheme="http://davidleee.com/tags/dom/"/>
    
  </entry>
  
  <entry>
    <title>关于 macOS 输入框你需要了解的一些基础</title>
    <link href="http://davidleee.com/2018/09/11/the-basic-of-macos-text-view-system/"/>
    <id>http://davidleee.com/2018/09/11/the-basic-of-macos-text-view-system/</id>
    <published>2018-09-11T06:48:40.000Z</published>
    <updated>2020-05-05T03:43:31.445Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是 macOS 开发系列的第三篇文章 —— 文本输入系统基础。</p><p>电脑的文字编辑功能比手机上的强大（难搞）真不是吹！</p></blockquote><a id="more"></a><h2 id="认识输入框">认识输入框</h2><blockquote><p>The Macintosh operating system has provided sophisticated text handling and typesetting capabilities from its beginning. In fact, these features sparked the desktop publishing revolution. —— Apple</p></blockquote><p>在 macOS 的世界里，要显示或者编辑文字主要会用到两个控件，一个是 <a href="https://developer.apple.com/documentation/appkit/nstextview" target="_blank" rel="noopener">NSTextView</a>，另一个是 <a href="https://developer.apple.com/documentation/appkit/nstextfield" target="_blank" rel="noopener">NSTextField</a>。</p><blockquote><p>虽然控件库里面有个叫 Label 的东西，但是拖出来之后就会发现，它其实也是一个  <a href="https://developer.apple.com/documentation/appkit/nstextfield" target="_blank" rel="noopener">NSTextField</a></p></blockquote><p>它们的继承关系是这样的：<br><img src="/uploads/the-basic-of-macos-text-view-system/7004648D-1B33-476E-8788-8D894D8B08E9.png" alt></p><p>NSTextView 是苹果花了大心血打造的一个“满足几乎所有显示和管理文字需求”的一个控件，也是 macOS 引以为傲的文字编辑系统的主心骨；NSTextField 则相当于一个简化版的 NSTextView，在大多数情况下它可以满足字数较少的输入需求。</p><p>正如我们在 iOS 开发里常做的那样，在需要用户输入的地方，通常是直接展示一个 Text 相关的控件，然后通过 delegate 方法来控制输入的内容；又或者继承一个官方的控件，然后在内部直接实现想要的内容控制逻辑。</p><p>在 macOS 上，这个流程也是大致相同的。</p><blockquote><p>以前写过一篇简单介绍 NSTextView 用法的文章（ <a href="/2017/09/11/Windows-in-macOS/" title="20分钟手把手教你写 macOS 文本编辑器">20分钟手把手教你写 macOS 文本编辑器</a>），等不及的童鞋们可以在这篇文章里过过瘾。</p></blockquote><h2 id="文本输入的幕后玩家">文本输入的幕后玩家</h2><p>虽然从使用上来看，跟开发者直接打交道的就是 NSTextView 和 NSTextField 这两个类，最多再加上它们带着的一些协议/代理，但是继续往深了看，会发现有一个未知的世界在支撑这这一切。</p><h3 id="field-editor">Field Editor</h3><p>macOS 上有一个叫 Field Editor 的概念。</p><p>在输入框获得焦点的时候，系统会实例化一个 NSTextView 作为 Field Editor，并把它作为 first responder 插入到这个输入框的事件响应链当中。如此一来，Field Editor 会负责处理所有的用户输入事件，在这个过程中，获得焦点的输入框会作为 Field Editor 的代理，以便对文本的内容进行控制处理。</p><p><img src="/uploads/the-basic-of-macos-text-view-system/field_editor_2x.png" alt></p><blockquote><p>这就是为什么 NSWindow 的 <code>firstResponder</code> 返回的是一个不可见的对象，而不是我们获取了焦点的输入框，因为这个对象就是上面说的 Field Editor。</p></blockquote><p>Field Editor 是同一个窗口里所有输入框共用的，所以在我们用 Tab 键切换输入框的时候，Field Editor 就会切换事件响应的对象。另一方面，这个机制也确保了同一个窗口中只能有一个控件去响应用户输入事件。不过，我们也可以实现自定义的 Field Editor 来推翻上面说的这些功能。</p><blockquote><p>虽然 Field Editor 一般会是一个 NSTextView 的实例，但是它们对 Tab 和 Return 的事件处理是不同的。对于 Field Editor 来说，这两个键盘事件是“结束编辑”的意思。</p></blockquote><h3 id="nstextinputcontext">NSTextInputContext</h3><p>这是外界和文本输入系统之间沟通的桥梁。</p><p>在用户进行输入的时候，<code>keyDown</code> 消息会被传递到获取了焦点的输入框里，输入框接下来会调用 <a href="https://developer.apple.com/documentation/appkit/nstextinputcontext" target="_blank" rel="noopener">NSTextInputContext</a> 的 <code>handleEvent</code> 方法，以便让 NSTextInputContext 告诉自己需要怎么处理这个用户事件。而作为响应，NSTextInputContext 会把处理结果通过 <a href="https://developer.apple.com/documentation/appkit/nstextinputclient" target="_blank" rel="noopener">NSTextInputClient</a> 这个协议告知输入框。</p><p><img src="/uploads/the-basic-of-macos-text-view-system/F200783C-8569-4396-BC36-4DAD92E810DF.png" alt></p><p>从上图可以看到，NSTextInputContext 会跟一个叫 Key-bindings dictionary 的字典保持密切联系。这个字典默认来自于 AppKit 内部的一个文件（<em>/System/Library/Frameworks/AppKit.framework/Resources/StandardKeyBinding.dict</em>），里面保存了系统默认定义好的所有快捷键，只有当用户输入的值在这个字典里找不到匹配的键值对时，这次输入才会作为普通字符回调给输入框，否则 NSTextInputContext 就会在这里把这次输入拦截下来，并让输入框执行相应的特殊操作。</p><blockquote><p>我们可以通过修改 <em>~/Library/KeyBindings/DefaultKeyBinding.dict</em> 里的值来覆盖默认的快捷键</p></blockquote><h2 id="小结">小结</h2><p>到此为止，macOS 文本编辑系统的一些内在机理已经了解地差不多了。在往后使用 NSTextView 和 NSTextField 的过程中，碰到一些不明觉厉的问题也能有个大概的问题排查方向了。（不过也仅限于“大概方向”了）</p><p>好吧，我知道这篇文章偏理论了一些，大多数情况下也不会用到。更多详细的说明可以在文章里提供的各种链接上找到。</p><p>在后续的文章里，还会讲到 NSTextField 实际应用上的一些内容。NSTextView 因为暂时没有用上，所以可能会等有机会研究清楚些再讲咯。</p><h2 id="参考文章">参考文章</h2><p><a href="https://developer.apple.com/library/archive/documentation/TextFonts/Conceptual/CocoaTextArchitecture/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009459-CH1-SW1" target="_blank" rel="noopener">About the Cocoa Text System</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这是 macOS 开发系列的第三篇文章 —— 文本输入系统基础。&lt;/p&gt;
&lt;p&gt;电脑的文字编辑功能比手机上的强大（难搞）真不是吹！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="macOS" scheme="http://davidleee.com/tags/macOS/"/>
    
      <category term="AppKit" scheme="http://davidleee.com/tags/AppKit/"/>
    
      <category term="NSTextField" scheme="http://davidleee.com/tags/NSTextField/"/>
    
      <category term="Cocoa" scheme="http://davidleee.com/tags/Cocoa/"/>
    
      <category term="NSTextView" scheme="http://davidleee.com/tags/NSTextView/"/>
    
      <category term="Text System" scheme="http://davidleee.com/tags/Text-System/"/>
    
      <category term="Field Editor" scheme="http://davidleee.com/tags/Field-Editor/"/>
    
  </entry>
  
  <entry>
    <title>react-navigation-redux-helpers 从 v1 到 v2</title>
    <link href="http://davidleee.com/2018/09/10/upgrade-react-navigation-redux-helpers-to-v2/"/>
    <id>http://davidleee.com/2018/09/10/upgrade-react-navigation-redux-helpers-to-v2/</id>
    <published>2018-09-10T08:40:21.000Z</published>
    <updated>2020-05-05T03:43:31.445Z</updated>
    
    <content type="html"><![CDATA[<p>在使用 <a href="https://reactnavigation.org" target="_blank" rel="noopener">React Navigation</a> 的项目中，想要集成 redux 就必须要引入 <a href="https://github.com/react-navigation/react-navigation-redux-helpers" target="_blank" rel="noopener">react-navigation-redux-helpers</a> 这个库。最近整理第三方库的时候，发现这两个库的版本都比较旧了，在尝试更新的时候踩了一些坑，于是就有了这篇文章。</p><a id="more"></a><h2 id="navigator">Navigator</h2><p>升级之后，配置上唯一的不同在于 v2 版本中干掉了 <code>createReduxBoundAddListener(Key)</code> 方法，取而代之的是 <code>reduxifyNavigator(Navigator, Key)</code>。</p><p>在 v1 版本中，我们需要把前者构造出来的 <code>addListener</code> 作为参数传给 AppNavigator：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  StackNavigator,</span><br><span class="line">  addNavigationHelpers,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'react-navigation'</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  createReduxBoundAddListener</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'react-navigation-redux-helpers'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> AppNavigator = StackNavigator(AppRouteConfigs)</span><br><span class="line"><span class="keyword">const</span> addListener = createReduxBoundAddListener(<span class="string">"root"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;AppNavigator navigation=&#123;addNavigationHelpers(&#123;</span><br><span class="line">        dispatch: <span class="keyword">this</span>.props.dispatch,</span><br><span class="line">        state: <span class="keyword">this</span>.props.nav,</span><br><span class="line">        addListener, <span class="comment">// --&gt; 就是这里</span></span><br><span class="line">      &#125;)&#125; /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在 v2 版本中，使用新方法可以简化上述步骤：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  createStackNavigator, <span class="comment">// new creator of StackNavigator</span></span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'react-navigation'</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  reduxifyNavigator</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'react-navigation-redux-helpers'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> AppNavigator = createStackNavigator(AppRouteConfigs)</span><br><span class="line"><span class="keyword">const</span> App = reduxifyNavigator(AppNavigator, <span class="string">"root"</span>) <span class="comment">// --&gt; 干净清爽！</span></span><br></pre></td></tr></table></figure><h2 id="mapstatetoprops">mapStateToProps</h2><p>原来 <code>state.nav</code> 对应的 <code>props</code> 键叫 “nav”，现在改为 “state” 了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// v1</span></span><br><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state</span>) =&gt;</span> (&#123;</span><br><span class="line">  nav: state.nav</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// v2</span></span><br><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state</span>) =&gt;</span> (&#123;</span><br><span class="line">  state: state.nav, <span class="comment">// nav -&gt; state</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>另外，之前为了处理 Android 返回按钮的问题，可能会自定义一个类包裹着上面构造出来的 AppNavigator，然后通过 react-redux 的 <code>connect</code> 方法把 <code>mapStateToProps</code> 给作用到这个自定义的类上去，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReduxNavigation</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* additional setup for back button handling */</span></span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">/* more setup code here! this is not a runnable snippet */</span>*</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">AppNavigator</span> <span class="attr">navigation</span>=<span class="string">&#123;navigation&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps)(ReduxNavigation)</span><br></pre></td></tr></table></figure><p>经测试发现，在 v2 版本里，这种操作会报 “undefined is not an object(evaluating ‘state.routes’)” 的错误，猜测可能跟 Props 的键值变化有关。把 <code>connect</code> 的调用提前，让它先作用到 AppNavigator 再包裹到自定义类里面即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ConnectedNavigator = connect(mapStateToProps)(AppNavigator)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReduxNavigation</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* additional setup for back button handling */</span></span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">/* more setup code here! this is not a runnable snippet */</span>*</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ConnectedNavigator</span> <span class="attr">navigation</span>=<span class="string">&#123;navigation&#125;/</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ReduxNavigation</span><br></pre></td></tr></table></figure><h2 id="full-example">Full Example</h2><p>对于同一个 Navigator， <code>reduxifyNavigator</code> 如果在 <code>connect</code> 之后调用，会报重复定义<code>navigation</code> 属性的错误。所以加上前面的配置过程，完整的例子应该长这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* importing the whole world */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> AppNavigator = createStackNavigator(AppRouteConfigs)</span><br><span class="line"><span class="comment">// 下面两句顺序不能变</span></span><br><span class="line"><span class="keyword">const</span> App = reduxifyNavigator(AppNavigator, <span class="string">"root"</span>)</span><br><span class="line"><span class="keyword">const</span> ConnectedNavigator = connect(mapStateToProps)(App)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReduxNavigation</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* additional setup for back button handling */</span></span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">/* more setup code here! this is not a runnable snippet */</span>*</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ConnectedNavigator</span>/&gt;</span></span> <span class="comment">// 不需要 `navigation` 参数了</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ReduxNavigation</span><br></pre></td></tr></table></figure><h2 id="参考文章">参考文章</h2><p><a href="https://reactnavigation.org/docs/en/redux-integration.html" target="_blank" rel="noopener">Redux integration · React Navigation</a><br><a href="https://v1.reactnavigation.org/docs/redux-integration.html" target="_blank" rel="noopener">Redux integration · React Navigation (v1)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用 &lt;a href=&quot;https://reactnavigation.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;React Navigation&lt;/a&gt; 的项目中，想要集成 redux 就必须要引入 &lt;a href=&quot;https://github.com/react-navigation/react-navigation-redux-helpers&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;react-navigation-redux-helpers&lt;/a&gt; 这个库。最近整理第三方库的时候，发现这两个库的版本都比较旧了，在尝试更新的时候踩了一些坑，于是就有了这篇文章。&lt;/p&gt;
    
    </summary>
    
    
      <category term="react-native" scheme="http://davidleee.com/tags/react-native/"/>
    
      <category term="react-navigation" scheme="http://davidleee.com/tags/react-navigation/"/>
    
      <category term="redux" scheme="http://davidleee.com/tags/redux/"/>
    
      <category term="react-navigation-redux-helpers" scheme="http://davidleee.com/tags/react-navigation-redux-helpers/"/>
    
  </entry>
  
  <entry>
    <title>让人眼花缭乱的 macOS 菜单</title>
    <link href="http://davidleee.com/2018/08/22/how-menus-work/"/>
    <id>http://davidleee.com/2018/08/22/how-menus-work/</id>
    <published>2018-08-22T09:44:37.000Z</published>
    <updated>2020-05-05T03:43:31.443Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是 macOS 开发系列的第二篇文章——让人眼花缭乱的 macOS 菜单。</p><p>这有什么好说的，你不要骗我！手机上的菜单都是我用自定义视图撸出来的！</p></blockquote><a id="more"></a><h2 id="菜单的类型">菜单的类型</h2><p>在 macOS 开发中，所谓“菜单”并不只是一个自定义视图了（虽然自定义视图也可以实现），在 AppKit 里面名字直接叫“菜单”的类就占了两席之地，分别是 <a href="https://developer.apple.com/documentation/appkit/nsmenu" target="_blank" rel="noopener">NSMenu</a> 和 <a href="https://developer.apple.com/documentation/appkit/nsmenuitem" target="_blank" rel="noopener">NSMenuItem</a>。</p><p>在实际应用中，菜单对应了 5 种表现形式：</p><ul><li><p>应用的菜单栏，在屏幕的最上方<br><img src="/uploads/how-menus-work/D54DBE49-05EB-4638-AEC3-FA37D500ECC7.png" alt></p></li><li><p>弹出菜单，可以出现在当前窗口中的任何地方<br><img src="/uploads/how-menus-work/3D50179E-F77C-4A53-85E5-9296B53895D7.png" alt></p></li><li><p>状态栏，从屏幕上方的菜单栏右边开始向左延伸<br><img src="/uploads/how-menus-work/WX20180821-170602@2x.png" alt></p></li><li><p>“上下文菜单”（Contextual Menus），点击右键或 “control + 左键” 触发<br><img src="/uploads/how-menus-work/56863C68-CAB1-4BCE-B0DD-82C7E4C03F5F.png" alt></p></li><li><p>Dock 菜单，对程序坞（Dock）的应用图片点击右键或 “control + 左键” 触发<br><img src="/uploads/how-menus-work/4948EFFA-1E19-4922-AB52-5FD4518F4268.png" alt></p></li></ul><p>看着挺多，但是用起来倒是挺简单方便的。下面就把这几个新玩具都拉出来溜一溜～</p><h2 id="应用菜单栏-application-menu">应用菜单栏（Application Menu）</h2><p>这个菜单栏在上一篇文章（<a href="/2018/08/21/storyboard-in-macos/" title="不一样的 macOS Storyboard">不一样的 macOS Storyboard</a>）里已经纠结过了。</p><p>概括一下：每个应用初始化的时候就自带了一个应用菜单栏，如果是使用 Storyboard 开发的项目，在 “Main.storyboard” 里面就可以直接对这个菜单栏进行各种各样功能上的调整了（也就限于逻辑，样子大概是改不动了，只能用系统控件…）</p><h2 id="弹出菜单-pop-up-menu">弹出菜单（Pop-up Menu）</h2><p>这种菜单的含义比较宽泛，所有在当前窗口里面出现的、带有“弹出”感觉的菜单都可以属于这一类。从视觉上大致可以分成两种：对话框型 &amp; 按钮型。</p><h3 id="对话框型">对话框型</h3><p>这中文名是我自己取的…因为它长得像呀！它就是上面类型介绍里的图片所示的样子，对应的类是 <a href="https://developer.apple.com/documentation/appkit/nspopover" target="_blank" rel="noopener">NSPopover</a>。</p><p>这玩意儿在 iOS 9 和更老的版本中有类似的用法叫 <a href="https://developer.apple.com/documentation/uikit/uipopovercontroller" target="_blank" rel="noopener">UIPopoverController</a>，在 iOS 9 之后就变成了 UIViewController 的一种展现方式了，具体参见 <a href="https://developer.apple.com/documentation/uikit/uipopoverpresentationcontroller" target="_blank" rel="noopener">UIPopoverPresentationController</a>。</p><p>NSPopover 用起来跟上面说的几个类也是差不多的，只是它本身不是一个 ViewController，所以在展示之前需要先设置 <code>contentViewController</code> 以负责界面的显示。</p><p>更多风骚的用法还是参考官方文档为好 -  <a href="https://developer.apple.com/documentation/appkit/nspopover" target="_blank" rel="noopener">NSPopover</a>。</p><h3 id="按钮型">按钮型</h3><p>顾名思义，这是个看起来很像按钮的菜单，打开系统偏好设置 -&gt; 通用，就能见到大把的按钮型弹出菜单，它们对应的类是 <a href="https://developer.apple.com/documentation/appkit/nspopupbutton" target="_blank" rel="noopener">NSPopUpButton</a>。</p><p>在 xib 或者 storyboard 里面拖一个出来，能看到它跟普通按钮相比多出了这么一些独有的配置：<br><img src="/uploads/how-menus-work/A7088EFE-96C5-4124-BA69-05E917716EB1.png" alt></p><p>其中 “Type” 部分有两个可选值：Pop up &amp; Pull Down，它们最直观的区别在于按钮后面跟着的蓝色部分，前者是上下箭头，后者则只有一个向下的箭头：<br><img src="/uploads/how-menus-work/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%884.40.57.png" alt></p><p>当然，它们在列表展开方式和使用场景上也是不一样的，想要追究其中细节的童鞋们，推荐一篇官方文档：<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MenuList/Articles/ManagingPopUpItems.html#//apple_ref/doc/uid/20000274-BAJDEEJA" target="_blank" rel="noopener">Managing Pop-Up Buttons and Pull-Down Lists</a></p><h2 id="状态栏-status-bar">状态栏（Status Bar）</h2><p>作为一个中规中矩的菜单，状态栏菜单也是由两个部件组成的：<a href="https://developer.apple.com/documentation/appkit/nsstatusbar" target="_blank" rel="noopener">NSStatusBar</a> &amp; <a href="https://developer.apple.com/documentation/appkit/nsstatusitem" target="_blank" rel="noopener">NSStatusItem</a>，从名字就能看出它们的关系了，具体用法也是看文档咯。</p><blockquote><p>额外推荐一篇很详细的文章：<a href="https://www.raywenderlich.com/450-menus-and-popovers-in-menu-bar-apps-for-macos" target="_blank" rel="noopener">Menus and Popovers in Menu Bar Apps for macOS | Ray Wenderlich</a></p></blockquote><p>根据官方的说法，状态栏的位置稀缺，不保证你应用的菜单在上面一直是可用的，所以建议把它放在最后考虑（是的，甚至在 Dock Menu 之后）。做事比较克制的微信只把它用来显示未读消息条数，点击回调也只是打开微信主窗口而已。</p><p>而且苹果还建议我们提供一个隐藏的选项，在必要时给用户隐藏掉我们状态栏图标的机会。</p><p>Emmm….虽然苹果的话我们也不一定听就是了…</p><h2 id="上下文菜单-contextual-menus">“上下文菜单”（Contextual Menus）</h2><p>也就是俗称的右键菜单？</p><blockquote><p>macOS 上还可以用 control + 左键触发</p></blockquote><p>它跟应用菜单栏一样，是通过最常见的菜单样式来展现的，对应的类是： <a href="https://developer.apple.com/documentation/appkit/nsmenu" target="_blank" rel="noopener">NSMenu</a> &amp; <a href="https://developer.apple.com/documentation/appkit/nsmenuitem" target="_blank" rel="noopener">NSMenuItem</a>。</p><p>唯一不同的是，它不是通过点击一个什么按钮去触发的，而是通过重载 NSView 的 <code>defaultMenu</code> 属性来实现的，我们只需要定义好菜单的样子和内部逻辑，打开/收起菜单这样的琐事就交给系统去做好了。</p><p>在 xib 或 storyboard 里，把菜单链接到其他视图的 Outlets -&gt; menu 上面，同样能实现右键触发的效果：<br><img src="/uploads/how-menus-work/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%885.16.55.png" alt></p><p>话说上图这个界面本身也是一个 Contextual Menu 呢。</p><h2 id="dock-菜单-dock-menu">Dock 菜单（Dock Menu）</h2><p>阿哈！这也是个普普通通的 Menu，通过实现 <a href="https://developer.apple.com/documentation/appkit/nsdocktileplugin" target="_blank" rel="noopener">NSDockTilePlugIn</a> 这个协议里的 <code>dockMenu()</code> 方法就可以返回一个我们自定义的菜单啦。</p><p>我们还可以通过它来自定我们的应用图标在 Dock 上面的样子，比如加个角标或者改一下图标颜色什么的，不过在这样做之前，我们还需要看看这个类 <a href="https://developer.apple.com/documentation/appkit/nsdocktile" target="_blank" rel="noopener">NSDockTile</a>。这就超纲了啊，不说了不说了。</p><h2 id="总结">总结</h2><p>虽说自定义视图和显隐逻辑也可以实现菜单的功能，但是 AppKit 已经为我们封装了好几个类，让我们可以方便快捷地怼出一个功能丰富的应用了，它们是：</p><ul><li><a href="https://developer.apple.com/documentation/appkit/nsmenu" target="_blank" rel="noopener">NSMenu</a> &amp; <a href="https://developer.apple.com/documentation/appkit/nsmenuitem" target="_blank" rel="noopener">NSMenuItem</a></li><li><a href="https://developer.apple.com/documentation/appkit/nspopover" target="_blank" rel="noopener">NSPopover</a> &amp; <a href="https://developer.apple.com/documentation/appkit/nspopupbutton" target="_blank" rel="noopener">NSPopUpButton</a></li><li><a href="https://developer.apple.com/documentation/appkit/nsstatusbar" target="_blank" rel="noopener">NSStatusBar</a> &amp; <a href="https://developer.apple.com/documentation/appkit/nsstatusitem" target="_blank" rel="noopener">NSStatusItem</a></li><li><a href="https://developer.apple.com/documentation/appkit/nsdocktile" target="_blank" rel="noopener">NSDockTile</a> &amp; <a href="https://developer.apple.com/documentation/appkit/nsdocktileplugin" target="_blank" rel="noopener">NSDockTilePlugIn</a></li></ul><p>除了一些特殊的应用之外，我们的主要功能应该是在窗口里面提供的，而菜单通常都是些锦上添花的东西。不过在有余力的时候，为我们的用户增添一分“意外之喜”也是极好的吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这是 macOS 开发系列的第二篇文章——让人眼花缭乱的 macOS 菜单。&lt;/p&gt;
&lt;p&gt;这有什么好说的，你不要骗我！手机上的菜单都是我用自定义视图撸出来的！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://davidleee.com/tags/Swift/"/>
    
      <category term="macOS" scheme="http://davidleee.com/tags/macOS/"/>
    
      <category term="AppKit" scheme="http://davidleee.com/tags/AppKit/"/>
    
      <category term="NSMenus" scheme="http://davidleee.com/tags/NSMenus/"/>
    
      <category term="NSPopover" scheme="http://davidleee.com/tags/NSPopover/"/>
    
      <category term="NSPopupButton" scheme="http://davidleee.com/tags/NSPopupButton/"/>
    
      <category term="Dock" scheme="http://davidleee.com/tags/Dock/"/>
    
      <category term="NSDockTile" scheme="http://davidleee.com/tags/NSDockTile/"/>
    
      <category term="NSStatusBar" scheme="http://davidleee.com/tags/NSStatusBar/"/>
    
  </entry>
  
  <entry>
    <title>不一样的 macOS Storyboard</title>
    <link href="http://davidleee.com/2018/08/21/storyboard-in-macos/"/>
    <id>http://davidleee.com/2018/08/21/storyboard-in-macos/</id>
    <published>2018-08-21T01:12:40.000Z</published>
    <updated>2020-05-05T03:43:31.444Z</updated>
    
    <content type="html"><![CDATA[<p>从 iOS 转来 macOS 阵营已经有几个月了，断断续续踩了一些这样那样的坑，特此写一个系列记录下来。这个系列碰到的问题都是已经找到了解决方法的，希望对其他人也能有些帮助。</p><blockquote><p>这是 macOS 开发系列的第一篇文章。</p><p>从项目开始的地方讲起 —— Storyboard。</p></blockquote><a id="more"></a><h2 id="main-storyboard">Main.Storyboard</h2><p>新建 macOS 项目的时候，如果勾上了 “Use Storyboards” 的话，工程里会自带了一个 “Main.storyboard”。</p><p>打开看看，发现跟 iOS 项目中的样子大同小异，不同的地方在于，原来的 “Navigation Controller” 在这里变成了 “Window Controller”，而且上面还多了一个没见过的 “Main Menu”。（关于菜单的内容会在第三篇文章里讲到）</p><p><img src="/uploads/storyboard-in-macos/4BB6559C-64F4-421D-A8D5-6427C96EF774.png" alt></p><p>如果把应用跑起来，会发现 “Window Controller” 对应的是应用的启动窗口，而 “Main Menu” 对应的是显示在顶部的系统菜单栏。</p><p><img src="/uploads/storyboard-in-macos/6D230E15-056A-495D-8063-96FA6F4E9792.png" alt></p><p>到目前为止，一切都还是合乎逻辑的，直到某天我手贱把 Main.storyboard 删掉了…</p><h2 id="自定义-storyboard">自定义 Storyboard</h2><p>按照我们在 iOS 里学来的经验，这没什么大不了的嘛！</p><p>让我们重新创建一个 Storyboard<br><img src="/uploads/storyboard-in-macos/AAA78593-47E1-4E34-A6FE-34D08C3D5328.png" alt></p><p>拖一个 “Window Controller” 出来，程序入口也要设置上（就是图片中间那个小箭头，位置在 Window Controller -&gt; Attributes Inspector -&gt; “Is Initial Controller”）<br><img src="/uploads/storyboard-in-macos/7BCBD120-A01E-48A9-9146-9A07CD956C81.png" alt></p><p>然后到项目配置里设置一下<br><img src="/uploads/storyboard-in-macos/35E29846-E2B3-4A94-A221-C9CB866FFC42.png" alt></p><p>Done！好像忘了点什么…不过先跑起来看看！<br><img src="/uploads/storyboard-in-macos/7AC50D3E-EF1B-43AE-80CE-0D12D5520CFE.png" alt></p><p>Emmm….菜单栏你怎么了！我的菜单栏呢！</p><h2 id="拯救被误删的-main-storyboard">拯救被误删的 Main.storyboard</h2><p>回到新建的 ”Main.storyboard“ 里瞅瞅，发现跟自带的 Storyboard 相比，少了 “Main Menu“ 这个玩意儿，相应的，在左边的场景列表里，应该要有一个叫 “Application Scene” 的场景。</p><p><img src="/uploads/storyboard-in-macos/BCD3A74F-812C-47F1-992C-E8BA3E1B5EE1.png" alt></p><p>翻遍了控件库，都没有找到任何与 “Application” 和 “Main Menu” 相关的东西，最后在一个 StackOverflow 的问题里找到了答案</p><blockquote><p><a href="https://stackoverflow.com/questions/24418936/create-application-scene-in-blank-os-x-storyboard" target="_blank" rel="noopener">macos - Create Application Scene in blank OS X Storyboard - Stack Overflow</a></p></blockquote><p>简单总结一下就是：即使时隔多年，macOS 上还是不怎么支持让一个不是基于 Storyboard 开发的应用升级到使用 Storyboard 的版本，所以控件库里压根就没有提供 Application Scene。</p><p>难道就没有办法了？</p><p>虽然没有试过在非 Storyboard 项目上集成 Storyboard，但是对于误删的情况还是有救的：（答案也来自于上面的链接里）</p><ol><li>创建一个新的、带 Storyboard 的项目</li><li>查看新项目里的 Main.storyboard 的源码</li><li>将下图 <code>&lt;!--Application--&gt;</code> 注释下面的 <code>&lt;Scene&gt;...&lt;/Scene&gt;</code> 的全部内容都拷贝到我们刚刚新创建的 Storyboard 里面<br><img src="/uploads/storyboard-in-macos/35685F05-E093-4A08-93B4-80332BE704B0.png" alt></li></ol><p>保存后重新打开 Storyboard，你会发现世界又恢复到原本的样子了！我们的菜单栏终于又回来了！</p><p>当然，因为是复制粘贴过来的，菜单栏里的一些信息还是新项目里的样子，在 Storyboard 稍加修改就可以了。</p><h2 id="总结">总结</h2><p>虽说长得差不多，但 macOS 开发里用到的 Storyboard 和 iOS 上的还是有不少的出入。</p><p>比如有时候 IB 里修改了文案，但是跑起来却不一样了，那可能是 Storyboard 生成了国际化配置文件，在里面搜索一下也许会找到元凶：<br><img src="/uploads/storyboard-in-macos/E490581B-53D5-4537-97B2-FC377985545E.png" alt></p><p>而更多的时候，在 IB 里调整了颜色之类的配置是不能直接看到效果的，还是要跑起来验证一下，以实际运行效果为准。</p><p>总而言之，在 macOS 开发过程中使用 Storyboard 需要更多的耐心和实际运行验证，这样的情况也许要到 macOS 支持 UIKit 的时候才能改善了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从 iOS 转来 macOS 阵营已经有几个月了，断断续续踩了一些这样那样的坑，特此写一个系列记录下来。这个系列碰到的问题都是已经找到了解决方法的，希望对其他人也能有些帮助。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这是 macOS 开发系列的第一篇文章。&lt;/p&gt;
&lt;p&gt;从项目开始的地方讲起 —— Storyboard。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://davidleee.com/tags/Swift/"/>
    
      <category term="macOS" scheme="http://davidleee.com/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>小心避开 RxSwift 里的坑（Top Mistakes in RxSwift you want to avoid）</title>
    <link href="http://davidleee.com/2018/04/24/Top-Mistakes-in-RxSwift/"/>
    <id>http://davidleee.com/2018/04/24/Top-Mistakes-in-RxSwift/</id>
    <published>2018-04-24T00:56:05.000Z</published>
    <updated>2020-05-05T03:43:31.442Z</updated>
    
    <content type="html"><![CDATA[<p>每当我们要学习一样新的语言或者框架时，总是会犯下这样那样的错误。这就是人类学习新知识的方法。下文列出了一些使用 RxSwift 过程中常见的错误，供大家参考。</p><a id="more"></a><p>原文链接在文末。</p><h2 id="combinelatest-vs-withlatestfrom">combineLatest vs withLatestFrom</h2><p>前者会在内部的任意一个 Observable 发出消息时发出一个总的消息，所以把两个按钮的 tap 事件 combineLatest 不是一个合理的做法。这种情况就要看看后者的使用方式了。</p><h2 id="observable-应该延迟初始化">Observable 应该延迟初始化</h2><p>当一个 Observable 是为了把耗时操作的结果通知出去时，这个 Observable 本身应该被延迟初始化，这样才能避免在有人 subscribe 之前就在做那个耗时操作。<br>举个栗子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rx_myFunction</span><span class="params">()</span></span> -&gt; <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> someCalculationResult: <span class="type">Int</span> = calculate()</span><br><span class="line">    <span class="keyword">return</span> .just(someCalculationResult)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>calculte()</code> 是一个耗时操作，这样用户在调用这个方法的时候就已经在跑真正的计算了，而我们写这个方法的本意应该是有人 subscribe 的时候才去执行操作。所以上面的方法应该做一下这样的小修改：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rx_myFunction</span><span class="params">()</span></span> -&gt; <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Observable</span>.deferred &#123;</span><br><span class="line">        <span class="keyword">let</span> someCalculationResult: <span class="type">Int</span> = <span class="keyword">self</span>.calculate()</span><br><span class="line">        <span class="keyword">return</span> .just(someCalculationResult)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="disposebag-的错误使用">DisposeBag 的错误使用</h2><p>这玩意儿的作用是把一堆 <code>Disposable</code> 在某个对象 <code>deinit</code> 的时候全部结束掉，所以这个管理对象的选择就尤为重要。</p><p>比如我们在 tableViewCell 里面进行了一些订阅，该用的 DisposeBag 是 cell 本身声明的一个属性，而不应该直接用 VC 里面的那个，因为 cell 会发生重用，所以这里的 Disposable 的管理应该更积极一点：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">dataSource.configureCell = &#123; <span class="number">_</span>, tableView, indexPath, cellViewModel <span class="keyword">in</span></span><br><span class="line"><span class="keyword">let</span> cell: <span class="type">TheCell</span> = tableView.dequeueCell(at: indexPath)</span><br><span class="line">cellViewModel.image</span><br><span class="line">.drive(cell.avatarView.image)</span><br><span class="line">.disposed(by: cell.disposeBag)</span><br><span class="line"><span class="keyword">return</span> cell</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//somewhere in TheCell.swift file</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TheCell</span>: <span class="title">UITableViewCell</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">prepareForReuse</span><span class="params">()</span></span> &#123;</span><br><span class="line">disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="没有在-ui-层使用-drivers">没有在 UI 层使用 drivers</h2><p>Driver 的设计是为了避免线程的混乱，对于 Driver 的订阅的通知都会发生在主线程上，所以可以降低线程问题的概率。具体要看看这个东西的详细用法。</p><h2 id="异常处理">异常处理</h2><p>当 Observable 抛出异常的时候，它会终止整个流程。如果使用了 <code>flatMap</code> 这类转换方法，那抛出异常的时候被终止的是源头的主流程。</p><p>也就是说，如果把一个可能抛出异常的流程绑定到了按钮的点击事件上，一旦这个流程抛出了异常，按钮的点击事件就再也不会响应了。</p><p>解决方法是使用 <code>Observable&lt;Result&lt;User&gt;&gt;</code> 或者 <code>materialize()</code> 之类的方法。</p><h2 id="同一个-observable-订阅多次">同一个 Observable 订阅多次</h2><p>Observable 是不可变的类。每一个处理方法都是返回一个新的 Observable 而不会对原来的那个做任何变动。</p><p>在需要共享某些流程的结果时，可能会对某个 Observable 进行分别处理和订阅，这时候就应该用 <code>share</code> 或者 <code>shareReplay(1)</code> 来避免事件的重复发出：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> items: <span class="type">Observable</span>&lt;[<span class="type">Item</span>]&gt; = itemsProvider.items</span><br><span class="line">.share()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">let</span> <span class="built_in">count</span>: <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt; = items</span><br><span class="line">.<span class="built_in">map</span> &#123; $<span class="number">0</span>.<span class="built_in">count</span> &#125;</span><br><span class="line">    </span><br><span class="line">items.subscribe(onNext: &#123; items <span class="keyword">in</span> </span><br><span class="line"><span class="comment">//do something with items</span></span><br><span class="line">&#125;) </span><br><span class="line">    </span><br><span class="line">numberOfItems.subscribe(onNext: &#123; <span class="built_in">count</span> <span class="keyword">in</span> </span><br><span class="line"><span class="comment">//do something with count</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>如果不加 <code>share()</code>，下面的两次 <code>subscribe</code> 就会触发两次 <code>itemProvider.items</code> 的 <code>get</code> 方法，但是显然我们只需要获取一次就可以满足下面两个订阅了</p></blockquote><h2 id="过度使用-subjects-variables">过度使用 subjects &amp; variables</h2><p>Rx 的世界应该是由“不可变变量”组成的，一旦一个事件已经形成，那么我们不应该对它本身做出任何改动，而是操作事件的流向最终得到我们想要的结果。</p><p>而 Subjects &amp; Variables 正是 Rx 世界里的“可变变量”。</p><p>不是说不能用它们，而是说我们在大多数时候并不需要用上它们。在更多情况下，我们可以用 <code>merge</code> 、<code>concat</code>、<code>publish</code>&amp;<code>refCount</code> 、<code>defer</code> 和其他一些方法去替代这两个玩意儿。</p><ul><li>原文链接：<a href="http://adamborek.com/top-7-rxswift-mistakes/" target="_blank" rel="noopener">Top mistakes in RxSwift you want to avoid - Code in a suit</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每当我们要学习一样新的语言或者框架时，总是会犯下这样那样的错误。这就是人类学习新知识的方法。下文列出了一些使用 RxSwift 过程中常见的错误，供大家参考。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://davidleee.com/tags/Swift/"/>
    
      <category term="Reactive" scheme="http://davidleee.com/tags/Reactive/"/>
    
      <category term="RxSwift" scheme="http://davidleee.com/tags/RxSwift/"/>
    
  </entry>
  
</feed>
