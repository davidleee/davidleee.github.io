<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lee 的笔记本</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://davidleee.com/"/>
  <updated>2020-05-05T03:43:31.445Z</updated>
  <id>http://davidleee.com/</id>
  
  <author>
    <name>Lee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SwiftUI 系列教程（4）—— UIKit 老相好在 SwiftUI 下的实现</title>
    <link href="http://davidleee.com/2019/08/15/swiftui-serial-tutorial-4/"/>
    <id>http://davidleee.com/2019/08/15/swiftui-serial-tutorial-4/</id>
    <published>2019-08-15T00:44:32.000Z</published>
    <updated>2020-05-05T03:43:31.445Z</updated>
    
    <content type="html"><![CDATA[<p>咱们最有意思的第四篇 SwiftUI 教程来啦！为什么说是“最有意思”的呢？因为按照约定，在这篇文章里我们会一起来看看用 SwiftUI 开发界面的快捷便利体现在什么地方。相信这会让许多苹果开发者们耳目一新。</p><blockquote><p>信了苹果教之后，每次有什么更新，我最期待的都是隐藏在大功能下的小细节，不知道有多少人跟我一样？</p></blockquote><a id="more"></a><h2 id="uitableview-uitableviewcell">UITableView &amp; UITableViewCell</h2><p>首先要说的是 UI 中最常见的列表：在萌新们刚开始学习 iOS 开发的时候，列表的实现也许就是其中一个劝退点。虽然 UIKit 的 API 已经做了比较友好的封装，但在这个前提下，开发者还必须要了解 UITableViewDelegate、UITableViewDataSource、Cell 与列表的关系，如果想要构造一个高性能的列表，还需要了解 Cell 的重用等等等等。</p><p>那么在 SwiftUI 里构造一个列表的操作是怎样的呢？我们分三步走：</p><ol><li>单个列表项的布局</li><li>准备数据</li><li>全部塞到一个列表里显示出来</li></ol><h3 id="列表项布局">列表项布局</h3><p>假设我们就构造一个最基础的列表项布局好了，一种 UIKit 直接就支持的显示模式：图片 + 标题 + 详情描述。</p><p>经过前面几篇文章的训练，我们对这种类型的 UI 构造应该熟门熟路了：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HStack</span>() &#123;</span><br><span class="line"><span class="type">Image</span>(systemName: <span class="string">"photo"</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="type">VStack</span>(alignment: .leading) &#123;</span><br><span class="line"><span class="type">Text</span>(<span class="string">"Title"</span>)</span><br><span class="line"><span class="type">Text</span>(<span class="string">"Detail description"</span>)</span><br><span class="line">.font(.subheadline)</span><br><span class="line">.foregroundColor(.secondary) <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>我们这里用了一张名为“photo”的图片，这个图片是 iOS 13 送给我们的，就是那个常见的图片占位符图标</li><li>UIKit 默认的详情描述用的是一种灰色的偏小一点的字体，我们直接用系统提供的属性就能模仿出来</li></ol><p>完成这一步之后，预览会是这个样子的：<br><img src="/uploads/swiftui-serial-tutorial-4/B1BE86B5-7B16-46DF-8DE8-C6AD6B23565D.png" alt></p><p>OK，学习完前面三篇文章之后，这里并没有什么新鲜的知识。下一步是准备数据。</p><h3 id="准备数据">准备数据</h3><p>这一步跟直接用 Swift 来实现没有太多区别，我就直接用 WWDC 视频里的数据结构了：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Room</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id = <span class="type">UUID</span>()</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> capacity: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> hasVideo: <span class="type">Bool</span> = <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> imageName: <span class="type">String</span> &#123; <span class="keyword">return</span> name &#125;</span><br><span class="line">    <span class="keyword">var</span> thumbnailName: <span class="type">String</span> &#123; <span class="keyword">return</span> name + <span class="string">"Thumb"</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> <span class="type">DEBUG</span></span><br><span class="line"><span class="keyword">let</span> testData = [</span><br><span class="line">    <span class="type">Room</span>(name: <span class="string">"Observation Deck"</span>, capacity: <span class="number">6</span>, hasVideo: <span class="literal">true</span>),</span><br><span class="line">    <span class="type">Room</span>(name: <span class="string">"Executive Suite"</span>, capacity: <span class="number">8</span>, hasVideo: <span class="literal">false</span>),</span><br><span class="line">    <span class="type">Room</span>(name: <span class="string">"Charter Jet"</span>, capacity: <span class="number">16</span>, hasVideo: <span class="literal">true</span>),</span><br><span class="line">    <span class="type">Room</span>(name: <span class="string">"Dungeon"</span>, capacity: <span class="number">10</span>, hasVideo: <span class="literal">true</span>),</span><br><span class="line">    <span class="type">Room</span>(name: <span class="string">"Panorama"</span>, capacity: <span class="number">12</span>, hasVideo: <span class="literal">false</span>),</span><br><span class="line">    <span class="type">Room</span>(name: <span class="string">"Oceanfront"</span>, capacity: <span class="number">8</span>, hasVideo: <span class="literal">false</span>),</span><br><span class="line">    <span class="type">Room</span>(name: <span class="string">"Rainbow Room"</span>, capacity: <span class="number">10</span>, hasVideo: <span class="literal">true</span>),</span><br><span class="line">    <span class="type">Room</span>(name: <span class="string">"Pastoral"</span>, capacity: <span class="number">7</span>, hasVideo: <span class="literal">false</span>),</span><br><span class="line">    <span class="type">Room</span>(name: <span class="string">"Elephant Room"</span>, capacity: <span class="number">1</span>, hasVideo: <span class="literal">true</span>)</span><br><span class="line">]</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><blockquote><p>这是我照着手敲的…如果有人知道哪里能弄来 WWDC 视频里的 Demo 项目源文件，请务必告诉我！</p></blockquote><p>到这一步为止还没什么不同，唯一比较不常见的可能是下面的 <code>testData</code>，这是方便我们调试用的假数据。</p><p>为了让 SwiftUI 的 <code>List</code> 能正常使用这个数据结构，我们还需要进行一点点改造：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Room</span>: <span class="title">Identifiable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id = <span class="type">UUID</span>()</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>List</code> 能使用的数据结构必须遵循 SwiftUI 里新加入的 <code>Identifiable</code> 协议，它要求这个数据结构里必须有一个符合 <code>Hashable</code> 协议的变量 <code>id</code>，我们这里用到的 <code>id</code> 是 <code>UUID</code> 类型的，本身已经满足这个要求，所以这里就不需要做更多修改了。</p><h2 id="列表显示">列表显示</h2><p>现在我们把 UI 和数据都准备好了，接下来就让它们组合起来，显示成一个列表！</p><p>对于 <code>List</code> 来说，列表项的默认布局就是水平方向的，所以我们可以直接 Cmd + 鼠标左键点击列表项 UI 里的 <code>HStack</code>，然后选择“Convert to List…”：<br><img src="/uploads/swiftui-serial-tutorial-4/D66F6EDE-FA01-489B-A8D3-4EDC81B5E18A.png" alt></p><blockquote><p>也许是 Xcode 的版本问题，在我这里显示的是“Embed in List”，但是最后的效果也是把选中了的 <code>HStack</code> 替换成了 <code>List</code></p></blockquote><p>得益于 <code>List</code> 构造方法里的数组类型参数，这段 UI 代码看起来就像是一个 for…in 的语句一样！回头看看预览，一个像模像样的列表已经出来了：<br><img src="/uploads/swiftui-serial-tutorial-4/38B4C8E5-0363-4674-AB1D-F078915AAF24.png" alt></p><p>接下来我们把准备好的数据对接上去：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> rooms: [<span class="type">Room</span>] <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line"><span class="type">List</span>(rooms) &#123; room <span class="keyword">in</span> <span class="comment">// 2</span></span><br><span class="line"><span class="type">Image</span>(room.thumbnailName)</span><br><span class="line"><span class="type">VStack</span>(alignment: .leading) &#123;</span><br><span class="line"><span class="type">Text</span>(room.name)</span><br><span class="line"><span class="type">Text</span>(<span class="string">"\(room.capacity) people"</span>)</span><br><span class="line">.font(.subheadline)</span><br><span class="line">.foregroundColor(.secondary)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> <span class="type">DEBUG</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListView_Previews</span>: <span class="title">PreviewProvider</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> previews: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">ListView</span>(rooms: testData) <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><ol><li>先定义一个成员变量来保管数据，这一行为符合单一数据源的原则，这个数据是由调用方负责构建和传入的</li><li>把 <code>List</code> 的参数缓存我们真实的数组，然后把内部的硬编码数据换成传进来的数据</li><li>这里我们能看到预览视图的另一个好处，就是它完全模拟了真实情况下的代码逻辑，所以我们可以直接把上一步准备好的测试数据传进去</li></ol><p><img src="/uploads/swiftui-serial-tutorial-4/ACCBAF94-47D3-43B5-B924-5589A3F68C9D.png" alt></p><p>对比导入数据前后的界面，我们可以发现：默认情况下 Cell 的高度为 44pt，但是当塞进去的内容（比如图片）需要用到的高度大于这个值时，Cell 会自动调整自己的高度以适应内容的大小，并填充合适的间距来美化我们的列表项。这些小细节全都是免费的！</p><blockquote><p>预览里的图片当然是要我们事先导入的，因为跟 SwiftUI 没什么关系，所以这里也就跳过了这一步；而且我也懒得找图片来代替它们了，所以截图里看到的还是之前默认图的样子…</p></blockquote><h2 id="navigationviewcontroller-navigationbar">NavigationViewController &amp; NavigationBar</h2><p>孤零零的一个列表可能还不够有意思，一般来说列表是罗列概要数据用的，为了看到更完整的信息，我们通常会在用户点击列表项的时候跳转到一个详情界面，这就涉及到了界面导航的概念。</p><p>在原来的开发过程里，这时候我们就会实现一个 <code>NavigationViewController</code> 去把我们列表的视图控制器包裹起来，然后通过 push &amp; pop 这样的操作来实现界面的切换。</p><p>一起来看看 SwiftUI 是怎么做的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NavigationView</span> &#123; <span class="comment">// 1</span></span><br><span class="line">    <span class="type">List</span>(rooms) &#123; </span><br><span class="line">  <span class="comment">// 列表项的布局 </span></span><br><span class="line">  &#125;</span><br><span class="line">  .navigationBarTitle(<span class="type">Text</span>(<span class="string">"Rooms"</span>)) <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>我们用一个 <code>NavigationView</code> 把原本 <code>body</code> 里的全部内容包裹起来，就像我们原来用 <code>NavigationViewController</code> 把 <code>UIViewController</code> 包起来一个道理</li><li>然后，我们给 <code>NavigationView</code> 里的最外层子视图（在这里就是 <code>List</code>）加一个修饰器来配置导航栏的标题；注意我们这里传的是一个 <code>View</code>，也就是说它不仅限于显示文字，还可以是各种各样遵循 <code>View</code> 协议的视图</li></ol><p>完成这两步就可以在原有的视图之上显示一个导航栏了，不过还不够，我们要给列表项加上点击事件以便跳转到详情界面：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span>(rooms) &#123; </span><br><span class="line">    <span class="type">NavigationButton</span>(destination: <span class="type">Text</span>(room.name)) &#123;</span><br><span class="line">        <span class="comment">// 列表项的布局</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就只有一步：把原先用于布局列表项的代码用一个 <code>NavigationButton</code> 包起来，同时通过参数来指定这个导航事件的目的地。如例子的代码所示，实现的效果是点击列表项之后跳转到一个新的界面，界面中会居中显示房间的名字：<br><img src="/uploads/swiftui-serial-tutorial-4/IMG_E91EAE65D877-1.jpeg" alt></p><p>在加上 <code>NavigationButton</code> 之后，细心的童鞋们可能已经发现我们列表项的变化了：每一项的尾部都显示了一个小尖角，这是 iOS 里用于表示列表可以“点击查看更多”的常见元素了。</p><p>OK，用 Live Mode 运行一下预览，可以看到 SwiftUI 已经把转场过程中的标题动画处理好了，界面跳转、手势返回，全都丝般顺滑。</p><h2 id="表单">表单</h2><p>两个典型的常用组件我们已经看完了，接下来我们要实现一个更复杂一些的界面。往常要实现这么一个界面，虽说没有太多的智力活，但体力活是肯定少不了的。</p><p>一图胜千言，先来看看效果图：<br><img src="/uploads/swiftui-serial-tutorial-4/00BD9E2A-5EFD-4B06-86E1-E008B2FA3D55.png" alt><br>这种界面在用户注册的过程中也是挺常见的，借用一个前端的概念——它叫做“表单（Form）”。</p><h3 id="环境准备">环境准备</h3><p>接下来的代码里，有些类需要在 Xcode11 beta 4 版本上才能使用（其实我只知道 Beta 1 用不了，但具体哪个版本变化的就不清楚了），建议大家先更新一下 Xcode，不然就只能在文章里过过眼瘾啦。虽说 WWDC 展示的时候那个讲师明明就已经用上了，果然发布会要用特供版本在哪里都是惯例啊。</p><p>顺带一提，这种变化除了更新软件之后上手试试之外，还能在哪里看到呢？答案就是：官方文档！<br><img src="/uploads/swiftui-serial-tutorial-4/1BCC5384-E073-417C-A7AA-DF85A6253099.png" alt><br>在网页上找到你想看的 API 之后，把图示右上角的 “API Changes” 打开，选择要比较的版本（对于 Beta 版的软件，一般不会给出每个版本之间的变化，所以如上所述我也不知道 <code>Form</code> 这位兄弟是什么时候加进来的），然后就能在 “SDKs” 下面看到特定版本的需求是什么时候加进来的了。上面的截图就表示 macOS App 在 Xcode beta 4 版本上是无法使用 <code>Form</code> 的，因为它在 beta 5 才被正式加进来。</p><h3 id="需求梳理">需求梳理</h3><p>让我们用前三篇文章加上上面两个小节的知识，来判断一下要怎么实现它。</p><ol><li>我们要有一个大大的标题在界面左上角，也许是一个 <code>navigationBarTitle</code> 可以搞定的事情</li><li>标题下面的内容样式看起来像是一个 <code>UITableView</code></li><li>这个列表分了好几个 Section，有些 Section 有属于自己的标题、有些却没有</li><li>每一行都有自己的样式，可能要定制好几种 <code>UITableViewCell</code>，而最后一行起到的是按钮的作用，可以真的用按钮去实现，也可以用文字加上列表项点击事件的方式来做</li></ol><h3 id="那就动手吧">那就动手吧！</h3><p>看看上面的需求，每一点都不难，可它们胜在多啊！如果用 UIKit 去实现，光是把界面做出来就已经要花不少代码，更别说界面背后的数据逻辑了。</p><p>于是 SwiftUI 应运而生，这种简单元素组合而成的复杂页面正是它的强项！</p><p>我们直接看最终的界面代码，不过你也不用看得太仔细，我们会在下面把它一点点拆开来讲：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FormView</span> : <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">var</span> userInfo = <span class="type">UserInfo</span>() <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Form</span> &#123; <span class="comment">// 2</span></span><br><span class="line">            <span class="type">Section</span>(header: <span class="type">Text</span>(“账号注册”).font(.title)) &#123; <span class="comment">// 3</span></span><br><span class="line">                <span class="type">TextField</span>(“请输入用户名”, text: $userInfo.name)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Section</span>(header: <span class="type">Text</span>(“种族”).font(.headline)) &#123;</span><br><span class="line">                <span class="type">Picker</span>(selection: $userInfo.race, label: <span class="type">Text</span>(“种族”)) &#123; <span class="comment">// 4</span></span><br><span class="line">                    <span class="type">ForEach</span>(<span class="type">Race</span>.allCases) &#123; race <span class="keyword">in</span> <span class="comment">// 4.1</span></span><br><span class="line">                        <span class="type">Text</span>(race.name).tag(race)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;.pickerStyle(<span class="type">SegmentedPickerStyle</span>())</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Section</span>(header: <span class="type">Text</span>(“口味”).font(.headline)) &#123;</span><br><span class="line">                <span class="type">Toggle</span>(isOn: $userInfo.loveSweet) &#123; <span class="comment">// 5</span></span><br><span class="line">                    <span class="type">Text</span>(“喜好甜食”)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">Toggle</span>(isOn: $userInfo.loveSpicy) &#123;</span><br><span class="line">                    <span class="type">Text</span>(“爱吃辣”)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Section</span>(header: <span class="type">Text</span>(<span class="string">"年龄"</span>).font(.headline)) &#123;</span><br><span class="line">                <span class="type">Stepper</span>(value: $userInfo.age, <span class="keyword">in</span>: <span class="number">1</span>…<span class="number">120</span>)&#123; <span class="comment">// 6</span></span><br><span class="line">                    <span class="type">Text</span>(<span class="string">"年龄：\(userInfo.age)"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Section</span> &#123;</span><br><span class="line">                <span class="type">Button</span>(action: &#123;</span><br><span class="line">                    <span class="built_in">print</span>(“register with info: \(<span class="keyword">self</span>.userInfo)”)</span><br><span class="line">                &#125;) &#123;</span><br><span class="line">                    <span class="type">Text</span>(“<span class="type">Register</span>”)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管有前几篇文章的知识作为铺垫，但这段代码里还是有不少的新面孔啊。</p><h4 id="userinfo">UserInfo</h4><p><code>UserInfo</code> 的类型定义是这样的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UserInfo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> = “”</span><br><span class="line">    <span class="keyword">var</span> loveSweet = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> loveSpicy = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span> = <span class="number">18</span></span><br><span class="line">    <span class="keyword">var</span> race: <span class="type">Race</span> = .<span class="type">Yellow</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它其实就是一个普通的结构体，用来表示这位用户的个人信息。</p><p>在上一篇文章里我们讲过，如果要把一个完整的自定义对象绑定到视图上，那么这个对象的类型就需要遵循 <code>BindableObject</code> 协议。但在这个例子里，我们只是将对象的属性绑定到了视图上，我们只在意这些属性而不是对象这个整体，所以可以直接通过 <code>@State</code> 来进行对象局部的绑定。</p><h4 id="form">Form</h4><p>如前面的文档截图里所述：<code>Form</code> 是一个用于组合一系列数据入口的视图，比如应用的设置页面，或者是例子里的用户信息录入界面。</p><p>话说回来，这么多新玩具，在开发过程中怎么知道有没有可以对症下药的呢？其实它们都整整齐齐码在了原来我们用于挑选 xib 或者 storyboard 组件的地方，我们可以用 Cmd + L 把这个界面弄出来：<br><img src="/uploads/swiftui-serial-tutorial-4/%E6%88%AA%E5%B1%8F2019-08-13%E4%B8%8B%E5%8D%8810.18.33.png" alt></p><h4 id="section">Section</h4><p>顾名思义，这是一个用于分区的控件，它也可以被用在 <code>List</code> 里面，就组成了所谓的 “SectionList”，例如通讯录里按首字母分区的样式。</p><p>例子中的 <code>Section</code> 用于给 <code>Form</code> 里的不同数据进行分类，并提供统一样式的 Header，它显示的内容也可以通过构造方法里的 <code>header</code> 参数来进行修改。</p><h4 id="picker">Picker</h4><p>这是目前为止碰到的最复杂的组件了，它有点类似于 UIKit 里的 <code>PickerView</code>，不过它是更广义的“选择器”，在样式上也会有更多的变化可供选择，比如例子里的 <code>SegmentedPickerStyle</code>（有些样式是平台相关的，在使用的时候要留意编译器的提醒）。</p><p>其实只要明白 <code>$</code> 变量的含义，这个构造方法也很好理解，就是把选择器里选中的内容与 <code>userInfo</code> 对象里的 <code>race</code> 属性绑定起来。</p><h5 id="foreach">ForEach</h5><p>这个写法本质上跟往 <code>List</code> 的构造方法里传一个数组的意思差不多，这样拆开来可以让列表型视图的内容样式更丰富，感兴趣的童鞋们可以详细看看<a href="https://developer.apple.com/videos/play/wwdc2019/204/" target="_blank" rel="noopener">这个视频</a>，这里就不展开讲了。</p><p>其中的 <code>Race</code> 是一个枚举类型，它的实现也很有意思：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Race</span> : <span class="title">CaseIterable</span>, <span class="title">Hashable</span>, <span class="title">Identifiable</span> </span>&#123; <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Yellow</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Black</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">White</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Mixed</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> id: <span class="type">UUID</span> &#123; <span class="type">UUID</span>() &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> .<span class="type">Yellow</span>: <span class="keyword">return</span> <span class="string">"黄种人"</span></span><br><span class="line">            <span class="keyword">case</span> .<span class="type">Black</span>: <span class="keyword">return</span> <span class="string">"黑种人"</span></span><br><span class="line">            <span class="keyword">case</span> .<span class="type">White</span>: <span class="keyword">return</span> <span class="string">"白种人"</span></span><br><span class="line">            <span class="keyword">case</span> .<span class="type">Mixed</span>: <span class="keyword">return</span> <span class="string">"混血"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子里的 <code>Race.allCase</code> 是遵循 <code>CaseIterable</code> 协议带给我们的一个福利，意思是“枚举所有可能的值”，于是我们就可以把它用在需要数组类型参数的地方了。</p><p>而 <code>Hashable</code> 和 <code>Identifiable</code> 是为了让这个枚举的对象可以被作为唯一标识符来使用。之所以这样做，是因为 <code>Picker</code> 的列表项必须要设置 <code>tag</code> 以区分用户的选择，于是例子中就直接用了枚举对象本身来作为选项的 <code>tag</code>。</p><h4 id="toggle">Toggle</h4><p>这个控件看名字就该知道是干嘛用的了，正如 Swift 4.2 之后的布尔值有了一个叫 <code>toggle</code> 的语法糖，这个控件就是用来标识开关状态的，也就是原来的 <code>UISwitch</code>。</p><h4 id="stepper">Stepper</h4><p>直译过来应该叫“步进器”。对于重视用户体验的苹果来说，这样看上去简单，但要正确实现逻辑还需要费点心思的小玩意儿，当然是选择封装成一个系统组件！相信看了前面那些五花八门的组件之后，这个 <code>Stepper</code> 的用法也是不需要再多加解释了。</p><h3 id="小结">小结</h3><p>好了，这短短不到40行的代码（好吧，算上那个结构体和枚举也有60行左右了），就已经实现了我们这一小节开头截图里的那种表单效果。不仅如此，SwiftUI 还默默为我们做了大量的优化工作，我可以拍胸脯说这些代码在效率上也会是远超 UIKit 版本的。</p><h2 id="总结">总结</h2><p>四篇文章下来，这个系列的 SwiftUI 教程也算是告一段落了。显然这仅仅是一个入门教程，更多有意思的新元素还在后面等着你。</p><p>文章里面的例子都是通过 Xcode 的新功能 Canvas 预览和截图出来的，目前它也只有个 iPhone 的外框样式，这难免有点限制了我们的想象，所以我必须要在最后提醒大家一句：</p><p><strong>用 SwiftUI 构建的界面天生就是跨全苹果平台的！</strong></p><p>也就是说，之前例子里的<strong>所有代码放到 macOS 和 watchOS 上都是适用的</strong>！（当然要除掉跟 UIKit 混合的那部分）而且所有界面的样式都会根据平台的不同而自动调整，几乎不需要开发者的介入就可以做到全平台适配！</p><p>写到这的时候我居然感觉挺兴奋的，就像是回到了刚刚接触 Xcode 和在 iOS 5 上做开发的那个年代。那个时候 Android 已经有好些机型要适配，而我只要把应用在我手里的 iPhone 上跑顺就八九不离十了:)</p><h2 id="参考文章">参考文章</h2><ul><li><a href="https://developer.apple.com/videos/play/wwdc2019/204/" target="_blank" rel="noopener">Introducing SwiftUI: Building Your First App - WWDC 2019 - Videos - Apple Developer</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2019/216/" target="_blank" rel="noopener">SwiftUI Essentials - WWDC 2019 - Videos - Apple Developer</a></li><li><a href="https://onevcat.com/2019/06/swift-ui-firstlook-2/" target="_blank" rel="noopener">SwiftUI 的一些初步探索 (二)</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;咱们最有意思的第四篇 SwiftUI 教程来啦！为什么说是“最有意思”的呢？因为按照约定，在这篇文章里我们会一起来看看用 SwiftUI 开发界面的快捷便利体现在什么地方。相信这会让许多苹果开发者们耳目一新。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;信了苹果教之后，每次有什么更新，我最期待的都是隐藏在大功能下的小细节，不知道有多少人跟我一样？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://davidleee.com/tags/Swift/"/>
    
      <category term="SwiftUI" scheme="http://davidleee.com/tags/SwiftUI/"/>
    
      <category term="List" scheme="http://davidleee.com/tags/List/"/>
    
      <category term="NavigationView" scheme="http://davidleee.com/tags/NavigationView/"/>
    
      <category term="NavigationButton" scheme="http://davidleee.com/tags/NavigationButton/"/>
    
      <category term="Form" scheme="http://davidleee.com/tags/Form/"/>
    
      <category term="Picker" scheme="http://davidleee.com/tags/Picker/"/>
    
      <category term="Toggle" scheme="http://davidleee.com/tags/Toggle/"/>
    
      <category term="Section" scheme="http://davidleee.com/tags/Section/"/>
    
      <category term="Stepper" scheme="http://davidleee.com/tags/Stepper/"/>
    
  </entry>
  
  <entry>
    <title>SwiftUI 系列教程（3）—— SwiftUI 数据流</title>
    <link href="http://davidleee.com/2019/07/25/swiftui-serial-tutorial-3/"/>
    <id>http://davidleee.com/2019/07/25/swiftui-serial-tutorial-3/</id>
    <published>2019-07-25T08:41:24.000Z</published>
    <updated>2020-05-05T03:43:31.445Z</updated>
    
    <content type="html"><![CDATA[<p>通过前两篇文章（SwiftUI 系列教程 <a href="/2019/06/12/swiftui-serial-tutorial-1/" title="（1）">（1）</a> 和 <a href="/2019/07/08/swiftui-serial-tutorial-2/" title="（2）">（2）</a>），我们已经看到了 SwiftUI 是怎么运作的了，对于常规的界面元素来说，使用 SwiftUI 确实能带来不小的生产力提升。但是在前面的例子里，我们用到的数据全都是写死的，这跟复杂多变的真实需求可不大一样。这篇文章我们就来了解一下，SwiftUI 里用到的全新的数据流模型。</p><blockquote><p>相比起前两篇实操文，这篇文章可能会比较干，请大家看文章之前先访问一下饮水机。</p></blockquote><a id="more"></a><h2 id="先看看别人家是怎么做的">先看看别人家是怎么做的</h2><h3 id="老东家">老东家</h3><p>学习过斯坦福公开课的小伙伴们应该对下面这张图片很有印象了：<br><img src="/uploads/swiftui-serial-tutorial-3/mvc1.png" alt></p><p>这是 iOS 自出道以来就非常推崇的，可谓是“官方建议”的数据流模型，也就是大家都熟知的 MVC 模式。</p><p>从 GUI 开始兴起以来，基于职责分离的思想，工程师们慢慢把管理用户界面的 View 和管理用户数据的 Model 给区分了开来；而从 Smalltalk 的某个版本开始，为了进一步降低图形应用程序的管理难度，设计出了 MVC 模式。MVC 的出现主要是为了解决这两个问题：</p><ol><li>如何管理响应用户操作的业务逻辑</li><li>View 如何同步 Model 的变化</li></ol><p>解决这两个问题也是大多数为现代图形界面应用程序而诞生的设计模式们的目标，比如 MVVM、MVP。</p><h3 id="隔壁前端家">隔壁前端家</h3><p>因为有着一段不长不短的 React Native 开发经历（目前还在做着），所以从这个角度看过去，比较成熟的方案是 Redux + React Redux。</p><p>Redux 是专为 JavaScript 软件打造的一个可预测状态容器。听起来很厉害的样子，其实主要是做了三个事情：</p><ol><li>把 Model 层的数据统一放到一个地方</li><li>约定只能通过特定的手段去改变数据，除此之外，数据就是只读的</li><li>约定改变数据的操作必须是纯函数</li></ol><p>这样做了之后，我们就可以确定这个数据源是可以真实反应我们的应用状态的，所以叫做“可预测状态容器（Predictable State Container）”。</p><p>然后 React Redux 就好理解了，它的任务是建立一套机制，让上述的状态一一绑定到视图上，实现一条双向更新的通道。</p><blockquote><p>Redux 和 React Redux 都是 Redux 官方出品，所以质量还是比较有保证的。下面这两篇文章应该可以给大家技术选型的时候提供一些支持：<br><a href="https://redux.js.org/introduction/motivation" target="_blank" rel="noopener">Motivation · Redux</a><br><a href="https://react-redux.js.org/introduction/why-use-react-redux" target="_blank" rel="noopener">Why Use React Redux? · React Redux</a></p></blockquote><h2 id="swift-的实现">Swift 的实现</h2><p>如果你觉得 SwiftUI 在构造界面时用到的声明式语法跟 JSX 的相似度很高的话，那在介绍完它的数据绑定逻辑之后，你肯定会再一次把它拿来跟 JavaScript 做比较了。</p><p>SwiftUI 中引入了一个关键字 <code>@State</code> 来作为数据绑定的标识。当一个被绑定的数据被改变时，相关联的视图会重新计算它自己的 <code>body</code> 内容；反过来，当视图主动去改变绑定在数据上的属性时，这个数据也会随之变化。这种双向绑定的机制就像 JSX + Redux + React Redux 的组合拳，只不过 SwiftUI 自己就把这些事情给做了。</p><p>但是，凭什么 SwiftUI 用几个关键字就实现了别人整整两个开源库的功能？其实这得益于 Swift 5.1 的新功能——属性包装（Property Wrappers）。</p><h3 id="深挖一点点">深挖一点点</h3><p>在 2019 年3月份的时候，Swift 核心团队里的成员已经透露出了一个作用类似于 <code>lazy</code> 关键字的新功能，那个时候它被称为“属性代理”（Property Delegates）。</p><p>举个例子，延迟初始化可谓是编程里的一种美德，在 Swift 的世界里，除了直接用 <code>lazy</code>，我们也可以用一个私有属性加上一个作为访问器的 Computed Property 来实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> _lazyProp: <span class="type">Prop?</span></span><br><span class="line"><span class="keyword">var</span> lazyProp: <span class="type">Prop</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> value = _lazyProp &#123; <span class="keyword">return</span> value &#125;</span><br><span class="line">        <span class="keyword">let</span> initialValue = ... <span class="comment">// 初始化数据</span></span><br><span class="line">        _lazyProp = initialValue</span><br><span class="line">        <span class="keyword">return</span> initialValue</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> &#123;</span><br><span class="line">        _lazyProp = newValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如今，Property Wrappers 为我们提供了第三条路可走，不仅如此，它还承诺会为开发者们提供了一种实现类似 <code>lazy</code> 关键字用法的途径。</p><p>在 SwiftUI 的功能提议 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0258-property-wrappers.md" target="_blank" rel="noopener">SE-0258</a> 里可以看到，Property Wrappers 的主要目的就是为了避免开发者重复写出上面那种固定模式的代码。既然这种写法是比较固定的，那么就应该定义出一种机制，来把各种固定写法定义成一个个的工具库。</p><h3 id="官方的解决方案">官方的解决方案</h3><p>还是用 <code>lazy</code> 的例子，怎么用 Property Wrappers 来实现一个同样的功能呢？比如实现一个作用相同的 <code>@Lazy</code> 属性？</p><p>官方给出的解决方案是这样的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@propertyWrapper</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Lazy</span>&lt;<span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> uninitialized(() -&gt; <span class="type">Value</span>)</span><br><span class="line">  <span class="keyword">case</span> initialized(<span class="type">Value</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(wrappedValue: <span class="meta">@autoclosure</span> @escaping () -&gt; <span class="type">Value</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span> = .uninitialized(wrappedValue)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> wrappedValue: <span class="type">Value</span> &#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">get</span> &#123;</span><br><span class="line">      <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> .uninitialized(<span class="keyword">let</span> initializer):</span><br><span class="line">        <span class="keyword">let</span> value = initializer()</span><br><span class="line">        <span class="keyword">self</span> = .initialized(value)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">      <span class="keyword">case</span> .initialized(<span class="keyword">let</span> value):</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> &#123;</span><br><span class="line">      <span class="keyword">self</span> = .initialized(newValue)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此一来，下面这种变量声明</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">Lazy</span> <span class="keyword">var</span> foo = <span class="number">123</span></span><br></pre></td></tr></table></figure><p>就会被展开成这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> _foo: <span class="type">Lazy</span>&lt;<span class="type">Int</span>&gt; = <span class="type">Lazy</span>&lt;<span class="type">Int</span>&gt;(wrappedValue: <span class="number">123</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">var</span> foo: <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">get</span> &#123; <span class="keyword">return</span> _foo.wrappedValue &#125;</span><br><span class="line">  <span class="keyword">set</span> &#123; _foo.wrappedValue = newValue &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>调用了 <code>Lazy</code> 的 <code>init</code> 方法来进行初始化一个私有变量，它的类型是 <code>Lazy&lt;Int&gt;</code></li><li>通过把原变量包装成一个 Computed Value 的方式来对接 <code>wrappedValue</code> 里提供的真正的逻辑实现</li></ol><p>不仅如此，既然 <code>@Lazy</code> 是一个 <code>enum</code> ，那它本身就可以定义五花八门的公开方法，而每一个被 <code>@propertyWrapper</code> 标记的类型都可以通过定义一个 <code>projectedValue</code> 属性来实现一些骚操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@propertyWrapper</span><br><span class="line">enum Lazy&lt;Value&gt; &#123;</span><br><span class="line">    // ... 内容跟前面一样 ...</span><br><span class="line"></span><br><span class="line">    // 定义一个重置的方法，把 @Lazy 标记的变量还原为一个不同的初始值</span><br><span class="line">    public mutating func reset(_ newValue:  @autoclosure @escaping () -&gt; Value) &#123;</span><br><span class="line">        self = .uninitialized(newValue)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public var projectedValue: Self &#123;</span><br><span class="line">        get &#123; self &#125;</span><br><span class="line">        set &#123; self = newValue &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明了 <code>projectedValue</code> 之后 ，我们就自动获得了一个带 <code>$</code> 符号的分身用来访问我们 <code>projectedValue</code> 的 getter，从而调用到里面的方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">Lazy</span> <span class="keyword">var</span> foo = <span class="number">123</span></span><br><span class="line">$foo.reset(<span class="number">456</span>)</span><br></pre></td></tr></table></figure><p>上面那句声明变量的语句，会展开成这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> _foo: <span class="type">Lazy</span>&lt;<span class="type">Int</span>&gt; = <span class="type">Lazy</span>&lt;<span class="type">Int</span>&gt;(wrappedValue: <span class="number">123</span>)</span><br><span class="line"><span class="keyword">var</span> foo: <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">get</span> &#123; <span class="keyword">return</span> _foo.wrappedValue &#125;</span><br><span class="line">  <span class="keyword">set</span> &#123; _foo.wrappedValue = newValue &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 上面跟原来一样，下面是添加了 projectedValue 之后新增的 ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> $foo: <span class="type">Lazy</span>&lt;<span class="type">Int</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">get</span> &#123; _foo.projectedValue &#125;</span><br><span class="line">  <span class="keyword">set</span> &#123; _foo.projectedValue = newValue &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其实给 <code>Lazy</code> 添加 <code>extension</code> 也可以达到类似的目的，不过这时候的方法调用就要通过 <code>_foo</code> 来进行，而不是 <code>$foo</code> 了</p></blockquote><h2 id="说回-swiftui">说回 SwiftUI</h2><p>SwiftUI 的数据流模型是基于下面两点原则来构建的：</p><ol><li>Data Access as a Dependency</li><li>Source of Truth</li></ol><p>我们展开来看：</p><h3 id="data-access-as-a-dependency">Data Access as a Dependency</h3><p>在多数情况下，我们的视图是需要根据某些状态来动态变化显示样式的，比如对于 <code>Switch</code> 来说，改变它的 <code>on</code> 属性可以让它显示当前的开关状态。</p><p>对于这种情况，<code>on</code> 属性就应该作为 <code>Switch</code> 的依赖而存在，否则这个控件除了长得好看就一无是处了。所以在 SwiftUI 里，属性会被描述为视图的依赖，这意味着我们的注意力可以从属性和视图的关联里抽身出来，集中在建立更好的用户体验上。</p><h3 id="source-of-truth">Source of Truth</h3><p>同一组视图里的数据都是来自于同一个数据源的（甚至整个应用的数据都来自于同一个数据源，Redux 就是这么做的）。</p><p>对于开发者来说，数据源的不唯一意味着视图状态的不唯一。可以想象，位于同一视图层级的两个视图要共用某些参数时，数据来源的不唯一会为编程带来多大的麻烦。<br><img src="/uploads/swiftui-serial-tutorial-3/D1B04594-7FAA-4391-AC05-CBC2BF839DD8.png" alt></p><p>SwiftUI 对这种情况的处理是，让父视图作为子视图的唯一数据源：<br><img src="/uploads/swiftui-serial-tutorial-3/4CDDC5EC-0093-46EE-A17A-F38972875AF8.png" alt></p><blockquote><p>做过前端 UI 开发的童鞋们应该很熟悉这套操作了，这就是把 State 上提成 Props 嘛，目的是让子视图尽可能的简单，最好的情况下子视图本身应该是无状态的。</p></blockquote><p>于是我们可以得出，基于这两个原则来实现的数据流模型已经完全不同于我们以往的理解，我们需要重新定义我们所认识的视图：<strong>视图要体现的是一个个独立的状态，而不是一系列连续的事件</strong> 。</p><h2 id="实践出真知">实践出真知</h2><p>说了这么多，我们来实际改造一段代码试试。</p><p>假设我们要实现一个播放器的播放按钮，需求是它要能反应播放状态：</p><ol><li>没有音频播放时，它表现为播放按钮</li><li>在有音频播放时，它表现为暂停按钮</li></ol><p>我们通过给按钮设置不同的图片来区分这两个状态，按照之前的知识，我们能轻松写下这样的代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PlayerView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> isPlaying: <span class="type">Bool</span> = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Button</span>(action: &#123;</span><br><span class="line">            <span class="keyword">self</span>.isPlaying = !<span class="keyword">self</span>.isPlaying</span><br><span class="line">        &#125;) &#123;</span><br><span class="line">            <span class="keyword">self</span>.isPlaying ? <span class="type">Text</span>(<span class="string">"Pause"</span>) : <span class="type">Text</span>(<span class="string">"Play"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等等，我们这个 <code>PlayerControl</code> 是 <code>struct</code> 类型的，不能这样直接改变属性的值：<br><img src="/uploads/swiftui-serial-tutorial-3/29C7C479-1EBA-47FD-B9C5-1037A6FC8E17.png" alt></p><p>其中一个安抚编译器的方法是，用一个临时变量来替代 <code>self</code>，我们顺便把布尔值取反的操作也简化一下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PlayerView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> isPlaying: <span class="type">Bool</span> = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Button</span>(action: &#123;</span><br><span class="line">            <span class="keyword">var</span> tempSelf = <span class="keyword">self</span> <span class="comment">// 安抚编译器</span></span><br><span class="line">            tempSelf.isPlaying.toggle() <span class="comment">// Implemented in Swift 4.2</span></span><br><span class="line">        &#125;) &#123;</span><br><span class="line">            <span class="keyword">self</span>.isPlaying ? <span class="type">Text</span>(<span class="string">"Pause"</span>) : <span class="type">Text</span>(<span class="string">"Play"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，这样一改，那句临时变量赋值语句就成为了夜空中最亮的星，怎么看怎么别扭…</p><p>那接下来就轮到 SwiftUI 里定义的 Property Wrappers 出场了，这段代码可以改写成这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PlayerView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> isPlaying: <span class="type">Bool</span> = <span class="literal">false</span> <span class="comment">// 加上 `@State` 标记</span></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Button</span>(action: &#123;</span><br><span class="line">            <span class="keyword">self</span>.isPlaying.toggle() <span class="comment">// 可以直接改动 `self` 里的变量了</span></span><br><span class="line">        &#125;) &#123;</span><br><span class="line">            <span class="keyword">self</span>.isPlaying ? <span class="type">Text</span>(<span class="string">"Pause"</span>) : <span class="type">Text</span>(<span class="string">"Play"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>似乎…也没太大变化啊，代码量也不见少，只不过是省掉了临时变量了？<br>这是因为，这样的写法还是根据我们的惯常思维来走，回忆一下上面讲到的 SwiftUI 数据模型原则：</p><ol><li>以依赖的形式访问数据</li><li>单一数据源</li></ol><p>例子里的写法貌似符合了“单一数据源”，但是却把“以依赖的形式访问数据”晾在了一边。我们来进一步改造这个例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PlayerView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> isPlaying: <span class="type">Bool</span> = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">PlayButton</span>(isPlaying: $isPlaying) <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PlayButton</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">Binding</span> <span class="keyword">var</span> isPlaying: <span class="type">Bool</span> <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Button</span>(action: &#123;</span><br><span class="line">            <span class="keyword">self</span>.isPlaying.toggle()</span><br><span class="line">        &#125;) &#123;</span><br><span class="line">            <span class="type">Text</span>(isPlaying ? <span class="string">"Pause"</span> : <span class="string">"Play"</span>) <span class="comment">// 3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>使用 <code>@State</code> 标记的变量会自动生成一个以 <code>$</code> 作为前缀的新变量，这个新变量本质上是一个 Computed Value，实现了双向绑定的机制，也就是说当 <code>PlayButton</code> 内部改变了这个变量之后，<code>PlayerView</code> 里的 <code>isPlaying</code> 也会发生相同的变化</li><li>通过声明变量为 <code>@Binding</code>，我们就告诉了编译器这个变量是从外部传入的可以被绑定的参数，相当于 React 里的 <code>Props</code> 声明</li><li>我们将 <code>isPlaying</code> 作为 <code>Text</code> 的依赖来使用，对于 <code>PlayButton</code> 来说，变量的声明和使用都是在一个结构体里面完成的，这就意味着这个视图与 <code>PlayerView</code> 是解偶的</li></ol><blockquote><p><code>@Binding</code> 具有以下两种特性：</p><ol><li>在不持有变量的前提下进行变量的读写</li><li>可以从 <code>@State</code> 变量中推导出来</li></ol></blockquote><p>现在回忆一下，在 SwiftUI 之前我们是怎么实现类似逻辑的？在不知不觉中，我们已经舍弃了 ViewController，让视图直接成为了数据的载体。甚至可以说，在 SwiftUI 里，视图就是为数据服务的。</p><blockquote><p><code>@State</code> 标记的属性一旦变化，会引起依赖它的视图、这个视图的父视图和它的同级视图一起做<strong>必要的</strong>变化。为什么要强调<strong>必要的</strong>？因为相较于繁重的渲染工作来说，对声明式语法描述出来的数据结构进行比较并不消耗什么性能，SwiftUI 会在重新渲染前对视图状态进行比较，尽可能地去避免无谓的绘制，所以不需要担心性能的问题。<br>类似于 <code>React.PureComponent</code> 提供的逻辑。</p></blockquote><h2 id="小结">小结</h2><p>基于这套数据模型实现出来的数据流可以用下面这张图片来表示：<br><img src="/uploads/swiftui-serial-tutorial-3/870E1C27-D2D8-41AD-BBF2-66AABA4BD04A.png" alt><br>要知道，Action 不只可以来自于用户交互，它还可以来自我们自己实现的触发器、消息推送等等，而不管来源是什么，我们实现的逻辑都可以理解并做出同样的处理。</p><p>这样的数据流模式确保了数据的流动永远是单向的，而 State 在这里充当了视图变化的唯一数据源，让视图的更新是可预测和易懂的。</p><blockquote><p>当然，<code>@State</code> 也有它的局限性，比如它无法正确处理我们自己定义的对象类型的属性变化，所以我们还需要 BindableObject 协议来从旁辅助，这里就不继续展开了。</p></blockquote><p>了解了视图基础和数据流模型，相信大家都已经看到了 SwiftUI 的魅力，余下的细节就需要各位开发者在实际应用中发掘了。下一讲就让我们来把这个魅力继续扩大，一起来实际看看 SwiftUI 还给我们的开发带来了哪些好处。</p><h2 id="参考文章">参考文章</h2><ul><li><a href="https://www.linuxidc.com/Linux/2015-10/124622.htm" target="_blank" rel="noopener">界面之下：还原真实的 MVC、MVP、MVVM 模式</a></li><li><a href="https://redux.js.org/introduction/motivation" target="_blank" rel="noopener">Motivation · Redux</a></li><li><a href="https://react-redux.js.org/introduction/why-use-react-redux" target="_blank" rel="noopener">Why Use React Redux? · React Redux</a></li><li><a href="https://developer.apple.com/documentation/swiftui/state_and_data_flow" target="_blank" rel="noopener">State and Data Flow | Apple Developer Documentation</a></li><li><a href="https://nshipster.com/propertywrapper/" target="_blank" rel="noopener">Swift Property Wrappers - NSHipster</a></li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0258-property-wrappers.md" target="_blank" rel="noopener">swift-evolution/0258-property-wrappers.md at master · apple/swift-evolution · GitHub</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2019/226/" target="_blank" rel="noopener">Data Flow Through SwiftUI - WWDC 2019 - Videos - Apple Developer</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过前两篇文章（SwiftUI 系列教程 &lt;a href=&quot;/2019/06/12/swiftui-serial-tutorial-1/&quot; title=&quot;（1）&quot;&gt;（1）&lt;/a&gt; 和 &lt;a href=&quot;/2019/07/08/swiftui-serial-tutorial-2/&quot; title=&quot;（2）&quot;&gt;（2）&lt;/a&gt;），我们已经看到了 SwiftUI 是怎么运作的了，对于常规的界面元素来说，使用 SwiftUI 确实能带来不小的生产力提升。但是在前面的例子里，我们用到的数据全都是写死的，这跟复杂多变的真实需求可不大一样。这篇文章我们就来了解一下，SwiftUI 里用到的全新的数据流模型。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;相比起前两篇实操文，这篇文章可能会比较干，请大家看文章之前先访问一下饮水机。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://davidleee.com/tags/Swift/"/>
    
      <category term="Redux" scheme="http://davidleee.com/tags/Redux/"/>
    
      <category term="SwiftUI" scheme="http://davidleee.com/tags/SwiftUI/"/>
    
      <category term="MVC" scheme="http://davidleee.com/tags/MVC/"/>
    
      <category term="React" scheme="http://davidleee.com/tags/React/"/>
    
      <category term="Property Wrappers" scheme="http://davidleee.com/tags/Property-Wrappers/"/>
    
      <category term="State" scheme="http://davidleee.com/tags/State/"/>
    
      <category term="Binding" scheme="http://davidleee.com/tags/Binding/"/>
    
  </entry>
  
  <entry>
    <title>SwiftUI 系列教程（2）—— 与 UIKit 结合的自定义视图</title>
    <link href="http://davidleee.com/2019/07/08/swiftui-serial-tutorial-2/"/>
    <id>http://davidleee.com/2019/07/08/swiftui-serial-tutorial-2/</id>
    <published>2019-07-08T03:15:32.000Z</published>
    <updated>2020-05-05T03:43:31.444Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="/2019/06/12/swiftui-serial-tutorial-1/" title="上一篇文章">上一篇文章</a>中，我们了解了 SwiftUI 的 <code>Text</code>  组件，并通过 <code>Stack</code> 系列的组件对内容进行了一些简单的布局。在这篇文章里，我们会认识一个全新的图片组件，并且会尝试利用这两篇文章的知识，结合 MapKit 框架，来实现一个简单的地点详情界面。</p><a id="more"></a><blockquote><p>写完第一篇文章之后，本职的开发任务突然进入了紧张的预发布阶段，搞得早就写好的第二篇文章拖了这么久才完成润色和发布，看来“全网最早”要丢了…</p></blockquote><h2 id="自定义图片视图">自定义图片视图</h2><p>首先把一张地标图片放到 <em>Assets.xcassets</em> 里去，我在百度找了张广州塔的照片：<br><img src="/uploads/swiftui-serial-tutorial-2/BF6A8678-F10F-4633-A932-94B781BE73F9.png" alt></p><p>然后，我们要为新的图片视图创建一个新的类，就放在上一篇文章的 <em>ContentView.swift</em> 旁边好了。新建文件的时候，选择 <strong>SwiftUI View</strong>：<br><img src="/uploads/swiftui-serial-tutorial-2/8A140752-2AE7-40E5-B320-F9DF7ADECE5C.png" alt></p><p>取个名字叫 CircleImage，因为我们将要在这里把广州塔裁剪成一个圆。新建的代码内容跟上一章看到的一样，我们把 <code>Text</code> 改成 <code>Image</code>，然后把图片的名字传进去，直接就可以通过预览在画布上看到我们的图片了：<br><img src="/uploads/swiftui-serial-tutorial-2/03DBC394-DA28-4686-87CA-117FCAC32CC6.png" alt></p><p>接下来我们在代码里给它加上一个圆形的裁剪。原来的做法有很多了，最快速的做法应该是操作 <code>clipsToBounds</code> 和 <code>cornerRadius</code>，给图片加上长度等于一半宽高的圆角，这还得要求图片是正方形的才能达到满意的显示效果。</p><p>而在 SwiftUI 里，这就是一句话的事情：<br><img src="/uploads/swiftui-serial-tutorial-2/D1D63EE5-2169-40D0-ACAB-F68AE4EED5EB.png" alt></p><p><code>.clipShape()</code> 给图片加了个裁剪的形状，其中 <code>Circle</code> 类型是一个用来当作遮罩的图形，你也可以给它加上填充色或者描边来单独使用，类似于以往通过 <code>CALayer</code> 去实现的效果。</p><p>但这也太大了，我们的屏幕装不下，我们可以再加两行代码，把图片缩放到一个合适的大小：<br><img src="/uploads/swiftui-serial-tutorial-2/E0470CA5-E465-4D53-8E1A-555C180DED64.png" alt></p><blockquote><p>讲道理，这里设置的宽高应该是一样的，毕竟是个圆嘛…但是我懒得重新截图了，各位童鞋自己调整一下数值就可以了</p></blockquote><p>为了让图片本身在不同背景下都能凸显出来，我们再给它加个描边，这要通过 <code>overlay()</code> 方法去实现；也许再加个阴影吧，用到的是 <code>shadow()</code> 方法；最后出来的效果是这样的：<br><img src="/uploads/swiftui-serial-tutorial-2/1263812F-2159-4AD5-9B21-50A314CFA99C.png" alt></p><p>是不是醒目多啦？</p><blockquote><p>每当做完一个新视图，我就想对比一下用老方法实现同样的效果有什么不同…</p></blockquote><h2 id="在-swiftui-里使用-uikit">在 SwiftUI 里使用 UIKit</h2><p>不知道大家发现了没有，我们在 SwiftUI 里用到的视图全部都是 <code>struct</code>，这意味着它们跟我们原本熟悉的 UIKit 是两套不同的机制，那难道以前开发的视图就完全用不上了吗？</p><p>答案是可以的。</p><p>要在 SwiftUI 里使用 UIView 的子类，只需要把它用一个遵循 <code>UIViewRepresentable</code> 协议的 SwiftUI 视图包裹起来即可。</p><blockquote><p>这里举的是 UIKit 的例子，但同样也适用于 AppKit 和 WatchKit。</p></blockquote><p>我们再来创建一个新的 SwiftUI View 来做我们的地图界面，但这一次，我们要改一下内容视图的协议：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"><span class="keyword">import</span> MapKit <span class="comment">// 引入 MapKit</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MapView</span> : <span class="title">UIViewRepresentable</span> </span>&#123; <span class="comment">// 把这里的协议改掉</span></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(“<span class="type">Hello</span> <span class="type">World!</span>”)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后你会发现 Xcode 在 <code>UIViewRepresentable</code> 这里报错了，因为这个协议下有两个必须实现的方法：</p><ol><li><code>makeUIView(context:)</code> 用来创建我们的 <code>MKMapView</code></li><li><code>updateUIView(_:context:)</code> 用来进行视图的配置，并响应后续可能的变化</li></ol><p>那下面我们就来实现一下。再加新代码之前，可以把已经用不上的 <code>body</code> 部分先删掉了。</p><p>对于 <code>makeUIView(context:)</code>，只需要声明它返回的是 <code>MKMapView</code> 然后直接通过构造方法返回一个空对象就可以了：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeUIView</span><span class="params">(context: UIViewRepresentableContext&lt;MapView&gt;)</span></span> -&gt; <span class="type">MKMapView</span> &#123;</span><br><span class="line">    <span class="type">MKMapView</span>(frame: .zero)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>updateUIView(_:context:)</code> 要做的事情就比较多了，我们一步步说：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateUIView</span><span class="params">(<span class="number">_</span> uiView: MKMapView, context: UIViewRepresentableContext&lt;MapView&gt;)</span></span> &#123;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">let</span> coordinate = <span class="type">CLLocationCoordinate2D</span>(latitude: <span class="number">23.112223</span>, longitude: <span class="number">113.331084</span>)</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">let</span> span = <span class="type">MKCoordinateSpan</span>(latitudeDelta: <span class="number">0.01</span>, longitudeDelta: <span class="number">0.01</span>)</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">let</span> region = <span class="type">MKCoordinateRegion</span>(center: coordinate, span: span)</span><br><span class="line">    uiView.setRegion(region, animated: <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>先把表示广州塔坐标的对象给构造出来（这是我在网上查的，等会预览的时候看看准不准）</li><li>构造一个用来标识地图的缩放等级的对象，数值越小地图拉得越近</li><li>构造坐标区域，并把这个区域设置到我们的地图视图上</li></ol><p>赶紧预览一下看看效果吧！你会发现画布上空白一片…</p><p>那是因为预览默认是静态模式的，它只能完整渲染 SwiftUI 的视图。因为我们现在用到了 UIView 的子类，所以要把预览切换到实时模式（右下角红框里的按钮）：<br><img src="/uploads/swiftui-serial-tutorial-2/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A72019-06-16%E4%B8%8B%E5%8D%887.28.49.png" alt></p><p>emmmm…塔呢？这定位看起来也不是很准啊。</p><h2 id="把一切都组装起来吧">把一切都组装起来吧！</h2><p>先看看预期实现的效果图：<br><img src="/uploads/swiftui-serial-tutorial-2/973ba702-85db-4852-851f-86a94cfca002.png" alt></p><p>然后花一点时间思考一下怎么弄，我们这两篇文章的知识是完全足够了的。</p><p>好啦！公布答案！</p><p>我们会在上一篇文章实现的 <code>ContentView</code> 里直接进行组装，下面来看看分解动作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123; <span class="comment">// 1</span></span><br><span class="line">            <span class="type">MapView</span>() </span><br><span class="line">                .edgesIgnoringSafeArea(.top) <span class="comment">// 2.1</span></span><br><span class="line">                .frame(height: <span class="number">300</span>) <span class="comment">// 2.2</span></span><br><span class="line"></span><br><span class="line">            <span class="type">CircleImage</span>()</span><br><span class="line">                .offset(y: -<span class="number">100</span>)</span><br><span class="line">                .padding(.bottom, -<span class="number">100</span>) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">            <span class="type">VStack</span>(alignment: .leading) &#123;</span><br><span class="line">                <span class="type">Text</span>(“<span class="type">Hello</span> <span class="type">SwiftUI</span>”)</span><br><span class="line">                    .font(.title)</span><br><span class="line">                <span class="type">HStack</span>(alignment: .top) &#123;</span><br><span class="line">                    <span class="type">Text</span>(“<span class="type">First</span> <span class="type">Description</span>”)</span><br><span class="line">                        .font(.subheadline)</span><br><span class="line">                    <span class="type">Spacer</span>()</span><br><span class="line">                    <span class="type">Text</span>(“<span class="type">Second</span> <span class="type">Description</span>”)</span><br><span class="line">                        .font(.subheadline)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .padding()</span><br><span class="line"></span><br><span class="line">            <span class="type">Spacer</span>() <span class="comment">// 4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>先用一个 <code>VStack</code> 把所有内容包裹起来，默认情况下 <code>VStack</code> 的内容布局是居中的，所以我们不需要做修改</li><li>针对 <code>MapView</code> 我们要做两个修改<ol><li><code>edgesIgnoringSafeArea</code> 可以让我们的视图把系统预留给刘海和状态栏的区域也用掉，这样看起来会更自然一点</li><li>对于只设置了 <code>height</code> 的视图，它的宽度会默认占满所有父视图里的可用空间</li></ol></li><li>我们的图片视图本身已经实现了所有效果了，现在只需要调整一下位置即可。需要注意的是，因为这里是通过 <code>offset</code> 移动的，所以为了保持与底部文字的间距，特意加上了一个负的 <code>padding</code> 来抵消掉位移导致的差距</li><li>做完前三步的操作后，这个 <code>VStack</code> 整体是在竖直方向上居中的，所以加上一个 <code>Spacer</code> 把整体有内容的部分顶到最上面（其实也可以通过 <code>HStack</code> 的 <code>alignment</code>来实现，不过那样代码就没有现在的简单优雅了）</li></ol><p>最终成果：<br><img src="/uploads/swiftui-serial-tutorial-2/EF653793-4B81-42D7-9B53-00790EE31E8F.png" alt></p><blockquote><p>如果你发现照着实现出来之后，中间圆形部分特别大的话，别担心，你是对的！<br>因为文章前面的 <code>CircleImage</code> 确实是为了展示而特意设置得比较大的，所以调整一下里面的宽高即可。</p></blockquote><h2 id="小结">小结</h2><p>到这里大家应该对 SwiftUI 的使用比较上手了，但目前为止涉及到的组件还比较少，SwiftUI 光是各种强大的组件就已经够玩很久了。不过我打算在第四篇文章里再集中讲各种有意思的组件使用方式，因为下一篇文章我们要先解决数据来源的问题。</p><p>既然我们的视图组件已经是通过声明式的写法来构建的了，那我们的数据是不是也该换一种方式绑定到视图上呢？在 JS 上我们可以用 react-redux 这样的数据绑定手段，那 SwiftUI 是不是该搭配 RxSwift 来使用了？</p><p>这些问题都将在下一篇文章里为大家解答！</p><h2 id="参考链接">参考链接</h2><p><a href="https://developer.apple.com/tutorials/swiftui/creating-and-combining-views" target="_blank" rel="noopener">SwiftUI | Creating and Combining Views</a><br><a href="https://developer.apple.com/videos/play/wwdc2019/216/" target="_blank" rel="noopener">SwiftUI Essentials - WWDC 2019 - Videos - Apple Developer</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;/2019/06/12/swiftui-serial-tutorial-1/&quot; title=&quot;上一篇文章&quot;&gt;上一篇文章&lt;/a&gt;中，我们了解了 SwiftUI 的 &lt;code&gt;Text&lt;/code&gt;  组件，并通过 &lt;code&gt;Stack&lt;/code&gt; 系列的组件对内容进行了一些简单的布局。在这篇文章里，我们会认识一个全新的图片组件，并且会尝试利用这两篇文章的知识，结合 MapKit 框架，来实现一个简单的地点详情界面。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://davidleee.com/tags/Swift/"/>
    
      <category term="SwiftUI" scheme="http://davidleee.com/tags/SwiftUI/"/>
    
      <category term="Image" scheme="http://davidleee.com/tags/Image/"/>
    
      <category term="UIView" scheme="http://davidleee.com/tags/UIView/"/>
    
      <category term="UIViewRepresentable" scheme="http://davidleee.com/tags/UIViewRepresentable/"/>
    
      <category term="MKMapView" scheme="http://davidleee.com/tags/MKMapView/"/>
    
      <category term="Spacer" scheme="http://davidleee.com/tags/Spacer/"/>
    
  </entry>
  
  <entry>
    <title>SwiftUI 系列教程（1）—— 初识 SwiftUI</title>
    <link href="http://davidleee.com/2019/06/12/swiftui-serial-tutorial-1/"/>
    <id>http://davidleee.com/2019/06/12/swiftui-serial-tutorial-1/</id>
    <published>2019-06-12T01:07:19.000Z</published>
    <updated>2020-05-05T03:43:31.444Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>可能是全网最早的 SwiftUI 中文教程？</p></blockquote><p>这篇文章来源于苹果官方的教程，相当于是我自己学习过程的一个记录。这个系列教程会跟着官方教程构造一个新的项目，还会加入一些 WWDC 的东西作为补充，可能偶尔会有一些自由发挥的部分。（不过我这里是做不出官方教程那种酷炫的动画了…）</p><a id="more"></a><h2 id="全新的编码体验">全新的编码体验！</h2><p>目前（2019.6.5）要体验到这个新东西，需要用到 <strong>Xcode 11 beta</strong>，而如果要体验新的预览机制和对画布上的预览进行操作，还需要把系统更新到 <strong>macOS Catalina 10.15 beta</strong>， 看来这个系列的新功能提供了系统层面的支持。</p><blockquote><p>话说回来，下了 iPadOS 之后用 iTunes 死活升不上去，报错说 macOS 有软件要更新，但总更新失败，最后下载 Xcode 11 beta 让它跑完 install components 那一步就可以成功升级 iPad 了…告诉我不是一个人…</p></blockquote><p>让我们先用新鲜热辣的 Xcode 11 beta 创建一个项目吧！</p><p>前面的步骤身为 iOS 开发的同学们应该很熟悉了，这里要创建的是 Xcode project -&gt; Single View App（playground 我还没试过，也许也被“强化”过了？），然后在取名字的那一步稍作停留，瞧瞧我在打勾区发现了什么：<strong>Use SwiftUI</strong>！当然选择钩上它！</p><p><img src="/uploads/swiftui-serial-tutorial-1/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A72019-06-10%E4%B8%8B%E5%8D%889.55.44.png" alt></p><p>完事之后我们就可以看到熟悉又带点陌生的编辑器界面了。点开默认提供给我们的 <em>ContentView.swift</em>，可以看到里面已经写好了两个 <code>struct</code>：<br><img src="/uploads/swiftui-serial-tutorial-1/F31CF147-5F01-422B-8ECB-C9AEFC274150.png" alt></p><hr><p>先打个岔，看看编辑区域右边新加入的 Minimap 界面，这虽然是一个在代码编辑器中比较常见的功能，但苹果一出手，还是给改进了一番：</p><ol><li>当鼠标在 Minimap 移动时，会像上图那样高亮并在左边把对应方法或变量名凸显出来，此时点击任意一块高亮区域都可以跳转到对应的代码位置</li><li>鼠标放在 Minimap 上时，按住 Command 键，所有的方法和变量名都会凸显出来（上图其实是按下了 Command 后的状态），重要的代码结构一目了然</li></ol><blockquote><p>苹果的每次大更新，着重宣传的主要变化，在我都尝试一遍之后就没什么感觉了，反而是这些小地方特别打动我</p></blockquote><hr><p>言归正传，看回代码。</p><p>这两个是 SwiftUI 默认提供的结构体，其中遵循 <code>View</code> 协议的那个定义了我们的界面内容和布局，而遵循 <code>PreviewProvider</code> 协议的那个则负责处理这个界面的预览。</p><p>那什么是预览？我们可以先把旁边的所谓预览窗口跑起来，点击右上角的 <em>Resume</em>（这个版本的 Xcode 默认会显示下图这个界面，没有的话，也可以在 <em>Editor</em> 里面打开它）：<br><img src="/uploads/swiftui-serial-tutorial-1/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A72019-06-10%E4%B8%8B%E5%8D%8810.22.22.png" alt></p><p>这时，Xcode 会把我们的项目运行起来，就跟平时点 <em>Run</em> 跑到模拟器上一样。有所不同的是，这次的模拟器直接显示成了 Xcode 的一个子界面，我们甚至可以直接操作这个模拟器里的视图，就像操作 xib 和 storyboard 一样！</p><p><img src="/uploads/swiftui-serial-tutorial-1/38B1BE43-FECA-471C-A845-FBFB8E5FA2C0.png" alt></p><blockquote><p>仔细看，点选了界面上的文案之后，左侧编辑器里相应的视图代码也被高亮了起来，是不是有一种根据按钮事件找 IBAction 代码的感觉？</p></blockquote><p>尝试修改一下代码里 <code>Text</code> 中的内容，会发现模拟器里的显示也实时更新了！对这个更加强大的模拟器，苹果给它起了个名字叫 <strong>画布（Canvas）</strong>。</p><h2 id="自定义文本视图">自定义文本视图</h2><p>那既然 <strong>画布</strong> 有着跟 Storyboard 相似的体验，那是不是意味着我们也可以直接改动界面上的元素？答案是肯定的，所有功能都隐藏在 Command + 左键点击里：<br><img src="/uploads/swiftui-serial-tutorial-1/AA6AA015-7832-46DD-83E7-063BC1631D83.png" alt></p><p>点击后会出现一个内容丰富的弹出框，这些操作会根据点击的视图不同而不同。</p><p>我们可以通过 <em>Inspect…</em> 来修改视图的一些基本元素：<br><img src="/uploads/swiftui-serial-tutorial-1/D0D9CEBC-7A12-4479-9541-34C80D177817.png" alt></p><blockquote><p>图上应该能看出来，这个弹出框是可以滚动的，它已经可以取代原来我们常用的 Attributes Inspector。实际上，如果你在这个时候点开右侧边栏，会发现 Attributes Inspector 的内容跟这里是完全一致的</p></blockquote><p>我们来把它的字体改为 <em>Large Title</em>，可以看到代码部分也跟着界面一起改变了：<br><img src="/uploads/swiftui-serial-tutorial-1/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A72019-06-10%E4%B8%8B%E5%8D%8810.38.09.png" alt></p><p>按照这个规律，我们通过手写代码来改个字体颜色试试：<br><img src="/uploads/swiftui-serial-tutorial-1/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A72019-06-10%E4%B8%8B%E5%8D%8810.40.22.png" alt></p><p>这种链式调用的语法是不是跟用 OC 实现的 AutoLayout 开源库 <a href="https://github.com/SnapKit/Masonry" target="_blank" rel="noopener">Masonry</a> 很像呢？苹果把这些方法叫做 <em>修饰器(modifiers)</em>，它们会在旧视图的基础上构造一个新视图返回出来，这使得上述的链式调用成为可能。</p><blockquote><p>如果我们再从刚才的 <em>Inspect…</em> 里把字体颜色改为 <em>inherited</em>，就会发现 Xcode 把我们刚加上的 <code>.color(.red)</code> 又给删掉了，这波操作让写代码有意思了不少啊。</p></blockquote><h2 id="把视图都叠起来吧">把视图都叠起来吧</h2><p>在前面的内容里，我们通过 SwiftUI 来描述了我们想要的视图样式，但这只是单一的视图。当视图多起来的时候，我们可以通过 <em>stacks</em> 把视图在竖直方向、水平方向或从前往后组合起来。</p><p>注意力继续回到我们的新朋友画布上，这次我们加快一点速度，先对刚刚的文本进行 <em>Embed in VStack</em> 的操作：<br><img src="/uploads/swiftui-serial-tutorial-1/32BB01AF-9406-41A2-8CA6-61F10F511D3A.png" alt></p><p>然后通过 Command + shift + L 调出视图库界面：<br><img src="/uploads/swiftui-serial-tutorial-1/73CBCF80-9712-48AA-9049-AD8641FC0269.png" alt></p><p>从里面拖一个 <code>Text</code> 到编辑器里（对，没错，就是编辑器，它会自动变成代码），放到我们之前操作的 <code>Text</code> 之下。现在我们的代码应该变成这个样子了：<br><img src="/uploads/swiftui-serial-tutorial-1/54973458-B739-467A-A6E9-B28081FEC640.png" alt></p><blockquote><p>从视图库拖组件出来这一步，我们有两种选择：一种是拖到代码里，另一种是拖到 Canvas 上。大家可以尝试一下拖到界面上会有什么样的效果。</p></blockquote><p>稍后我们再回过头来看这个 <code>VStack</code> 是什么。现在让我们继续快进，加入两个没见过的新组件 <code>HStack</code> 和 <code>Spacer</code>，通过给 <code>VStack</code> 加上参数来进行布局，还要再通过修饰器美化一下界面，最后 <code>ContentView</code> 的内容应该是这个样子的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span> : <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span>(alignment: .leading) &#123;</span><br><span class="line">            <span class="type">Text</span>(“<span class="type">Hello</span> <span class="type">SwiftUI</span>”)</span><br><span class="line">                .font(.largeTitle)</span><br><span class="line">                <span class="type">HStack</span> &#123;</span><br><span class="line">                    <span class="type">Text</span>(“<span class="type">First</span> <span class="type">Description</span>”)</span><br><span class="line">                        .font(.subheadline)</span><br><span class="line">                    <span class="type">Spacer</span>()</span><br><span class="line">                    <span class="type">Text</span>(“<span class="type">Second</span> <span class="type">Description</span>”)</span><br><span class="line">                        .font(.subheadline)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .padding()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相应的，我们的界面也成了这样：<br><img src="/uploads/swiftui-serial-tutorial-1/33A162A9-B3E2-4938-80DD-A7B752AC2098.png" alt></p><h2 id="幕后发生了什么？">幕后发生了什么？</h2><p>刚才的代码里，起到容器作用的是 <code>VStack</code> 和 <code>HStack</code>，顾名思义，它们分别是竖直方向上和水平方向上的层叠视图（Vertical &amp; Horizontal），用法跟我们早就认识的 <code>StackView</code> 相同。</p><p>到目前为止，有过前端开发经验的同学们应该能发现，这不就是 JSX 的语法吗？</p><p>我们知道，在实现一个新界面的时候，通常包含着“用基本组件就能实现”的常规部分和“要把奇技淫巧发挥到极致”的出彩部分。SwiftUI 的出现就是为了简化常规 UI 的开发过程，让开发者能够把精力都放在激动人心的部分。</p><blockquote><p>—— 摘自 WWDC</p></blockquote><p>为了达到这个目的，一个首要的改变就是：<strong>把命令式的视图逻辑转变为声明式的</strong>。这样做的好处在于：</p><ol><li>提高了组件的复用性</li><li>代码更清晰易懂，在编写的过程中也更符合直觉</li><li>隐藏了背后复杂的部分，让 SwiftUI 帮我们料理好一切</li></ol><p>这样转变之后，整个视图层级的代码看起来就清晰了许多（对比一下用单纯的 Swift 来实现会有多少代码），然而这种转变的背后其实都是我们熟悉的 Swift 语法。举个例子，<code>VStack</code> 本身就是一个 <code>View</code>，它的实现是这样的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">VStack</span>&lt;<span class="title">Content</span>: <span class="title">View</span>&gt; : <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(</span><br><span class="line">        alignment: <span class="type">HorizontalAlignment</span> = .center,</span><br><span class="line">        spacing: <span class="type">Length?</span> = <span class="literal">nil</span>,</span><br><span class="line">        @<span class="type">ViewBuilder</span> content: () -&gt; <span class="type">Content</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>alignment</code> 和 <code>spacing</code> 是两个布局用的属性，我们在之前的例子里就设置了 <code>VStack(alignment: .leading)</code>，这可以让内部的元素左对齐；而 <code>content</code> 属性则是一个闭包，它将返回另外一个视图，里面包含了所有要显示在 <code>VStack</code> 里的子视图。</p><p><code>VStack</code> 和 <code>HStack</code> 在 SwiftUI 里被用到时候，其实就是调用了它的构造方法，因为前两个参数要么是有默认值的，要么是可选的，所以只需要关注最后一个闭包参数；而这个闭包参数作为参数列表里的最后一员，可以写作结尾闭包的样子，于是就有了我们上面例子中的写法。</p><p>剩下的 <code>Spacer()</code> 和 <code>.padding()</code> 就只不过是 SwiftUI 提供给我们的又一个常规组件和修饰器而已了。</p><h2 id="小结">小结</h2><p>写到这里，仅仅涵盖了官方教程第一章里的前3部分，外加一点来自 WWDC 视频里的内容。我还会继续补充，努力把整个教程都覆盖掉。</p><p>不过这就足以让我们看到它的好玩之处了，至少写了一段时间 React Native 的我，看到这似曾相识的语法，着实感觉欣喜。苹果在为开发者打造工具上下的功夫，恐怕在历史所有科技型企业上也是数一数二的了。</p><h2 id="参考链接">参考链接</h2><p><a href="https://developer.apple.com/tutorials/swiftui/creating-and-combining-views" target="_blank" rel="noopener">SwiftUI | Creating and Combining Views</a><br><a href="https://developer.apple.com/videos/play/wwdc2019/216/" target="_blank" rel="noopener">SwiftUI Essentials - WWDC 2019 - Videos - Apple Developer</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;可能是全网最早的 SwiftUI 中文教程？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这篇文章来源于苹果官方的教程，相当于是我自己学习过程的一个记录。这个系列教程会跟着官方教程构造一个新的项目，还会加入一些 WWDC 的东西作为补充，可能偶尔会有一些自由发挥的部分。（不过我这里是做不出官方教程那种酷炫的动画了…）&lt;/p&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://davidleee.com/tags/Swift/"/>
    
      <category term="SwiftUI" scheme="http://davidleee.com/tags/SwiftUI/"/>
    
      <category term="Catalina" scheme="http://davidleee.com/tags/Catalina/"/>
    
      <category term="VStack" scheme="http://davidleee.com/tags/VStack/"/>
    
      <category term="HStack" scheme="http://davidleee.com/tags/HStack/"/>
    
  </entry>
  
  <entry>
    <title>NSTextField(1) —— macOS 输入框概览</title>
    <link href="http://davidleee.com/2019/04/12/nstextfield-for-macos/"/>
    <id>http://davidleee.com/2019/04/12/nstextfield-for-macos/</id>
    <published>2019-04-12T07:15:04.000Z</published>
    <updated>2020-05-05T03:43:31.444Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是 macOS 开发系列的第四篇文章 —— NSTextField。<br>最常见的控件之一，却不一定是你最熟悉的控件之一。</p></blockquote><a id="more"></a><p>将近半年没发文了，这段时间过得真是充实得过分，以至于完全没有时间好好整理一下手边可以写的内容。最近好不容易有点时间可以把存货整理整理，发现当时写的好多东西都已经过时了！赶紧收拾干净先发一篇上来，不然指不定哪天连整个主题都没用了…</p><p>咱们直接进入正题！</p><h2 id="nstextfield">NSTextField</h2><p>一个完整的 TextField 是由两个类组成的：<a href="https://developer.apple.com/documentation/appkit/nstextfieldcell" target="_blank" rel="noopener">NSTextFieldCell</a>，干了绝大多数脏活累活的一个类，和 <a href="https://developer.apple.com/documentation/appkit/nstextfield" target="_blank" rel="noopener">NSTextField</a>，作为 NSTextFieldCell 的容器而存在。所有 NSTextFieldCell 里的方法在 NSTextField 里面都有对应的存在（有点像 UIView 对 Layer 的封装）。</p><p>对于绝大多数情况来说，我们直接用 NSTextField 就足够了（那这篇文章不久没什么作用了吗？！）。如果你想要对自己的输入框有更多的掌控权，那可能还需要了解一个叫 <a href="https://developer.apple.com/documentation/appkit/nscontrol" target="_blank" rel="noopener">NSControl</a> 的家伙。</p><h2 id="nscontrol">NSControl</h2><p>正如 iOS 里的 <a href="https://developer.apple.com/documentation/uikit/uicontrol" target="_blank" rel="noopener">UIControl</a>，<a href="https://developer.apple.com/documentation/appkit/nscontrol" target="_blank" rel="noopener">NSControl</a> 是一个抽象类，必须通过子类继承来使用。但是跟比较纯粹的 UIControl 不同，NSControl 除了支持 Target/Action 机制和一些常见的属性设置之外，还加上了支持文字编辑的一系列代理方法。</p><p>举个两组最常用的例子：</p><h3 id="controltextdidxxx">controlTextDidxxx(_:)</h3><p>这么多方法里面，比较好用的当属 <code>did</code> 系列方法了：</p><ol><li><a href="https://developer.apple.com/documentation/objectivec/nsobject/1428934-controltextdidbeginediting?language=objc" target="_blank" rel="noopener"><code>controlTextDidBeginEditing(_:)</code></a></li><li><a href="https://developer.apple.com/documentation/objectivec/nsobject/1428847-controltextdidendediting?language=objc" target="_blank" rel="noopener"><code>controlTextDidEndEditing(_:)</code></a></li><li><a href="https://developer.apple.com/documentation/objectivec/nsobject/1428982-controltextdidchange?language=objc" target="_blank" rel="noopener"><code>controlTextDidChange(_:)</code></a></li></ol><p>这三个方法虽然已经在官方文档里被标记为 “macOS 10.0-10.14 Deprecated”了，<s>但它们仍然在勤勤恳恳地工作着</s>。<s>鉴于 macOS 的 10.14 还没出来</s>（2018.8），<s>我们但用无妨</s>。2019年4月再看，系统版本已经到10.14以上了，是时候考虑正式换成下面的方法了。</p><blockquote><p>上面三个方法的链接都是 Objective-C 版本的，被 Deprecated 的也是这个版本的方法。在 Swift 版的文档里，在 NSControlTextEditingDelegate 里已经加入这三个方法<s>的 Beta 版</s>了（2019.4 Beta 标识已经去掉了）：<a href="https://developer.apple.com/documentation/appkit/nscontroltexteditingdelegate/3005176-controltextdidbeginediting" target="_blank" rel="noopener">controlTextDidBeginEditing(<em>:)</em></a>、 <a href="https://developer.apple.com/documentation/appkit/nscontroltexteditingdelegate/3005177-controltextdidchange" target="_blank" rel="noopener">controlTextDidChange(:)</a>、 <a href="https://developer.apple.com/documentation/appkit/nscontroltexteditingdelegate/3005178-controltextdidendediting" target="_blank" rel="noopener">controlTextDidEndEditing(_:)</a>。方法签名看起来是一样的，估计新方法的正式版出来之后也可以无缝迁移。</p></blockquote><p>顾名思义，它们代表了输入过程中的三个状态，不过有一点要注意的是：每次出现 didEnd 并不一定会有一个对应的 didBegin。因为 didBegin 表示的是用户<strong>开始输入</strong>的状态，也就是说，单单是光标在控件上面闪烁着是不算数的，一定要用户敲下第一个字符的时候才会回调 <code>controlTextDidBeginEditing(_:)</code>。</p><p>而相对的，didEnd 表示<strong>结束编辑</strong>，只要用户选中输入框之后点击了输入框以外的地方，都会被算作“结束”，即使他从头到尾都没有输入过一个字。</p><p>这三个方法传入的参数都是 <code>Notification</code> 类型，说明它们其实都是系统通知的回调方法，只要实现了这个方法，系统就会自动帮你注册这三个消息的监听器。</p><blockquote><p>虽然参数是个 <code>Notification</code> ，但它会把触发消息的输入框作为 object 属性一起传进来，可以做的事情就相当多了。</p></blockquote><h3 id="nscontroltexteditingdelegate">NSControlTextEditingDelegate</h3><p>这个代理是专门为了编辑操作而设计的，除了<s>还在 Beta 版的</s>三个 did 系列方法外（2019.4 Beta 标识已经去掉了），还有分工明确的另外7个方法，一共10个。这部分在现在的项目里还没怎么接触，就只是把文档搬过来方便大家参考。</p><p>验证：</p><ul><li><a href="https://developer.apple.com/documentation/appkit/nscontroltexteditingdelegate/1428873-control" target="_blank" rel="noopener">control(_:isValidObject:)</a></li><li><a href="https://developer.apple.com/documentation/appkit/nscontroltexteditingdelegate/1428941-control" target="_blank" rel="noopener">control(_:didFailToValidatePartialString:errorDescription:)</a></li></ul><p>格式化文本：</p><ul><li><a href="https://developer.apple.com/documentation/appkit/nscontroltexteditingdelegate/1428883-control" target="_blank" rel="noopener">control(_:didFailToFormatString:errorDescription:)</a></li></ul><p>文本编辑响应：</p><ul><li><a href="https://developer.apple.com/documentation/appkit/nscontroltexteditingdelegate/1428865-control" target="_blank" rel="noopener">control(_:textShouldBeginEditing:)</a></li><li><a href="https://developer.apple.com/documentation/appkit/nscontroltexteditingdelegate/1428984-control" target="_blank" rel="noopener">control(_:textShouldEndEditing:)</a></li></ul><p>自动补全：</p><ul><li><a href="https://developer.apple.com/documentation/appkit/nscontroltexteditingdelegate/1428925-control" target="_blank" rel="noopener">control(_:textView:completions:forPartialWordRange:indexOfSelectedItem:)</a></li></ul><p>按键事件响应：</p><ul><li><a href="https://developer.apple.com/documentation/appkit/nscontroltexteditingdelegate/1428898-control" target="_blank" rel="noopener">control(_:textView:doCommandBy:)</a></li></ul><p>成员方法 <s>Beta</s>:</p><ul><li><a href="https://developer.apple.com/documentation/appkit/nscontroltexteditingdelegate/3005176-controltextdidbeginediting" target="_blank" rel="noopener">controlTextDidBeginEditing(_:)</a></li><li><a href="https://developer.apple.com/documentation/appkit/nscontroltexteditingdelegate/3005177-controltextdidchange" target="_blank" rel="noopener">controlTextDidChange(_:)</a></li><li><a href="https://developer.apple.com/documentation/appkit/nscontroltexteditingdelegate/3005178-controltextdidendediting" target="_blank" rel="noopener">controlTextDidEndEditing(_:)</a></li></ul><h2 id="总结">总结</h2><p>没有错！到这里就结束了！（因为实在是没什么存货…）希望这篇文章能起到入门和索引的作用。</p><p>有了这些内容，应该大概能知道怎么去控制输入框的内容，也可以避免一些简单的坑了。</p><p>如果没人注意到标题里的“(1)”的话，我就在这里打住了…不然我可能会把打造一个真实情景下使用的输入框的过程讲一讲。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这是 macOS 开发系列的第四篇文章 —— NSTextField。&lt;br&gt;
最常见的控件之一，却不一定是你最熟悉的控件之一。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://davidleee.com/tags/Swift/"/>
    
      <category term="macOS" scheme="http://davidleee.com/tags/macOS/"/>
    
      <category term="NSTextField" scheme="http://davidleee.com/tags/NSTextField/"/>
    
      <category term="NSControl" scheme="http://davidleee.com/tags/NSControl/"/>
    
  </entry>
  
  <entry>
    <title>又一篇 iOS Extension 入门（3/3）— Today 小组件</title>
    <link href="http://davidleee.com/2018/11/15/yet-another-ios-extension-article-3/"/>
    <id>http://davidleee.com/2018/11/15/yet-another-ios-extension-article-3/</id>
    <published>2018-11-15T08:12:27.000Z</published>
    <updated>2020-05-05T03:43:31.446Z</updated>
    
    <content type="html"><![CDATA[<p>昨天通过两篇文章介绍了 iOS Extension 的基础，并尝试制作了一个分享扩展，让我们的应用可以接收到从其他应用分享过来的数据，还实现了跨沙盒的应用扩展与载体间的通信。</p><p>看上面这段话就觉得内容挺多的吧…所以专门把 Extension 界的当红选手 —— Today 小组件单独放在这一篇文章里面讲，作为这个 iOS Extension 入门系列的收尾～</p><p>让我们马上进入正题！</p><a id="more"></a><h2 id="啥是-today-小组件">啥是 Today 小组件</h2><p>展示在 Today 界面（手机主页最左屏）里的应用扩展统称为“小组件”（Widget）。小组件存在的目的是向用户快速展示<strong>当下</strong>最重要的信息，并提供一些简易的任务处理功能，比如“把任务标记为完成”之类的。</p><blockquote><p>官方建议： Today 小组件负责的任务最好在单次操作内就能完成，如果你发现这个任务需要多个步骤，那 Today 小组件也许不是最适合的扩展点。具体扩展点参见 <a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/index.html#//apple_ref/doc/uid/TP40014214-CH20-SW3" target="_blank" rel="noopener">官方扩展点列表</a> 或者这个系列文章的第一篇（<a href="/2018/11/14/yet-another-ios-extension-article/" title="又一篇 iOS Extension 入门（1/3）— 基础 & 分享扩展">又一篇 iOS Extension 入门（1/3）— 基础 & 分享扩展</a>）里的翻译版。</p></blockquote><h3 id="划重点">划重点</h3><p>iOS 和 macOS 平台上都有 Today 小组件，在开发过程中需要注意的地方是相同的：</p><ul><li>确保内容是最新的</li><li>谨慎地对待用户交互</li><li>性能调优</li></ul><blockquote><p>从交互上来说，务必避免在小组件里放滚动列表，因为用户很难区分小组件内部的滚动和整个小组件列表的滚动</p></blockquote><p><strong>在 iOS 上</strong>：小组件不允许键盘输入，所以一切针对小组件的设置都应该在载体应用内完成。以“股市”为例，用户可以直接在小组件上切换显示的单位，但是股票列表的编辑需要在载体应用里进行。<br><strong>在 macOS 上</strong>：载体应用可以不做任何功能，小组件可以提供一个配置入口。还是以“股市”为例，小组件里可以直接搜索、添加和删除特定股票。</p><h2 id="来做一个-today-小组件吧">来做一个 Today 小组件吧</h2><p>就像创建分享扩展那样，首先要在项目配置里添加一个 Target（复习<a href="/2018/11/14/yet-another-ios-extension-article/" title="系列文章第一篇">系列文章第一篇</a>），如果想要共享数据的话，还需要配置一下 Capabilities -&gt; App Groups（复习<a href="/2018/11/14/yet-another-ios-extension-article-2/" title="系列文章第二篇">系列文章第二篇</a>）。</p><p>Xcode 依旧贴心地为我们创建了一个目录，随便点开看看，可以发现 <em>Info.plist</em> 里关于 <code>NSExtension</code> 的内容有所不同，其中的 <code>NSExtensionActivationRule</code> 字段已经没有了，因为 Today 小组件的开关是用户自己选择操作的，不需要我们开发者去判断。</p><h3 id="界面">界面</h3><blockquote><p>为了实现最好的效果，建议使用 AutoLayout 去做界面的布局。</p></blockquote><p>Today 小组件的宽度是固定的，高度上有延伸的空间以显示更多的内容。Xcode 创建的 IB 模版里已经用上了 AutoLayout，并用上了标准的四周间隔，我们可以通过 <code>widgetMarginInsetsForProposedMarginInsets:</code> 方法来获取到这些间隔以便计算。</p><blockquote><p>模版里的 VC 已经实现了 <code>NSWidgetProviding</code> 协议，上述方法就是在这个协议里定义的。</p></blockquote><p>界面部分最值得一提的就是右上角的“展开/折叠”了。这个按钮默认情况下并不会显示，需要我们添加一些代码来实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">    extensionContext?.widgetLargestAvailableDisplayMode = .expanded</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">widgetActiveDisplayModeDidChange</span><span class="params">(<span class="number">_</span> activeDisplayMode: NCWidgetDisplayMode, withMaximumSize maxSize: CGSize)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">if</span> activeDisplayMode == .expanded &#123;</span><br><span class="line">        preferredContentSize = <span class="type">CGSize</span>(width: maxSize.width, height: <span class="number">200</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        preferredContentSize = maxSize</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>告诉 <code>extensionContext</code> 我们的小组件是支持展开的，这个属性的默认值是 <code>.compact</code></li><li>用户点击“展开/折叠”的回调，如果不进行处理，小组件的高度不会发生变化</li><li>修改小组件的高度，这里的 <code>maxSize</code> 是系统限制的当前模式下的最大尺寸，使用 iPhone XR 模拟器测试时，<code>.compact</code> 模式下是 <code>(398, 110)</code>，<code>.expanded</code> 模式下是 <code>(398, 748)</code>。可见，苹果限制了折叠状态下最大高度为 110，超出部分会直接截掉；而展开状态下，最大高度为设备的高度。</li></ol><p>界面部分就没什么了，剩下的该是具体问题具体分析。接下来轮到功能逻辑的部分。</p><h3 id="跳转到载体应用">跳转到载体应用</h3><p>实际上，小组件还是通过 Universal Link 的机制来唤起载体应用的，与应用间跳转没有什么区别，只不过需要通过 <code>extensionContext</code> 来调用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唤起 URL Schemes 为 davidleee 的应用</span></span><br><span class="line">extensionContext?.<span class="keyword">open</span>(<span class="type">URL</span>(string: <span class="string">"davidleee://"</span>)!, completionHandler: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>需要注意的是，如果你的小组件要打开第三方的应用，在提交 App Store 审核的时候需要特别说明一下，否则会被打回。</p><blockquote><p>关于 Universal Link 的官方文档在这里：<a href="https://developer.apple.com/ios/universal-links/" target="_blank" rel="noopener">Universal Links - Apple Developer</a>，我也写过一篇文章记录了可能存在的一些坑，感兴趣的可以瞅瞅：<a href="/2017/01/04/universal-link-problems/" title="Universal Link（iOS）踩坑">Universal Link（iOS）踩坑</a></p></blockquote><h3 id="数据更新">数据更新</h3><p>既然 Today 小组件的目的就是为用户提供最新鲜的数据，那么数据更新的部分就一定不能马虎。</p><p>在 Xcode 帮我们创建的 <code>TodayViewController</code> 里面，我们可以看到一个叫  <code>widgetPerformUpdate(completionHandler:)</code> 的方法，在它的描述里能看到这么一句话：</p><p><em>This method is called to give a widget an opportunity to update its contents and redraw its view prior to an operation such as a snapshot.</em></p><p>苹果设计这个 API 是为了把数据的更新统一放到一个地方去。如果我们实现了这个方法，系统就会在合适的时候调用这个方法（比如系统想要给你的小组件进行 snapshot 之前），给我们一次更新数据的机会，并且这个机会不一定出现在小组件显示出来的时候，在后台的情况下也有可能触发这个回调。</p><p>于是我们就有两个拉数据的机会：</p><ul><li>在 <code>viewDidLoad</code> 里面</li><li>在 <code>widgetPerformUpdate(completionHandler:)</code> 里面</li></ul><blockquote><p>实验发现，小组件只要不可见的时间稍微长一点点，比如滚动出了屏幕，或离开 Today 视图一小会，它就会被重新初始化，也就是说 <code>viewDidLoad</code> 的调用会比想象中更频繁。但这并不意味着我们可以完全依赖 <code>viewDidLoad</code> 来做数据更新。</p></blockquote><p>在 SO 上的<a href="https://stackoverflow.com/questions/25168950/what-is-the-purpose-of-widgetperformupdatewithcompletionhandler-in-ios-8-today-w" target="_blank" rel="noopener">这个讨论</a>里，对数据更新的时机进行了更多的讨论，总结起来就是两点：</p><ol><li>苹果希望你在整个生命周期里尽可能早的地方进行数据更新，所以 <code>viewDidLoad</code> 要用</li><li><code>viewDidLoad</code> 还不够，那就用上 <code>widgetPerformUpdate(completionHandler:)</code>，毕竟前者并不会在后台情况下被调用</li></ol><h2 id="总结一下">总结一下</h2><p>Today 小组件就是一个用来展示<strong>小块</strong>数据和处理<strong>简单</strong>任务的地方。</p><p>注意上面那句话加粗的两个词，这给小组件定下了一个主基调：敏捷，所以凡是逻辑越写越复杂的时候，都该停下来想一想：这些逻辑是不是应该挪到载体应用里面去做？</p><blockquote><p>用这个理由去怼产品经理吧，就说是那个估值超万亿的苹果的产品经理说的～</p></blockquote><h2 id="参考文章">参考文章</h2><ul><li><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/Today.html#//apple_ref/doc/uid/TP40014214-CH11-SW1" target="_blank" rel="noopener">App Extension Programming Guide: Today</a></li><li><a href="https://medium.com/nine9devtw/ios-today-extension-swift-%E6%95%99%E5%AD%B8%E7%AD%86%E8%A8%98-5361446d1950" target="_blank" rel="noopener">iOS today extension (swift) 教學筆記 – 碼農勤耕田 – Medium</a></li><li><a href="https://stackoverflow.com/questions/25168950/what-is-the-purpose-of-widgetperformupdatewithcompletionhandler-in-ios-8-today-w" target="_blank" rel="noopener">ios8 - What is the purpose of widgetPerformUpdateWithCompletionHandler in iOS 8 Today Widget? - Stack Overflow</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天通过两篇文章介绍了 iOS Extension 的基础，并尝试制作了一个分享扩展，让我们的应用可以接收到从其他应用分享过来的数据，还实现了跨沙盒的应用扩展与载体间的通信。&lt;/p&gt;
&lt;p&gt;看上面这段话就觉得内容挺多的吧…所以专门把 Extension 界的当红选手 —— Today 小组件单独放在这一篇文章里面讲，作为这个 iOS Extension 入门系列的收尾～&lt;/p&gt;
&lt;p&gt;让我们马上进入正题！&lt;/p&gt;
    
    </summary>
    
    
      <category term="Universal Link" scheme="http://davidleee.com/tags/Universal-Link/"/>
    
      <category term="ios" scheme="http://davidleee.com/tags/ios/"/>
    
      <category term="Today Extension" scheme="http://davidleee.com/tags/Today-Extension/"/>
    
      <category term="Widget" scheme="http://davidleee.com/tags/Widget/"/>
    
  </entry>
  
  <entry>
    <title>又一篇 iOS Extension 入门（2/3）— 与容器沟通</title>
    <link href="http://davidleee.com/2018/11/14/yet-another-ios-extension-article-2/"/>
    <id>http://davidleee.com/2018/11/14/yet-another-ios-extension-article-2/</id>
    <published>2018-11-14T10:01:12.000Z</published>
    <updated>2020-05-05T03:43:31.446Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="/2018/11/14/yet-another-ios-extension-article/" title="上一篇文章">上一篇文章</a>里，我们了解到了 iOS Extension 的基础和怎么制作一个简单的分享扩展，然而，限于篇幅原因，这个分享操作止于用户点下 “Post” 的那一刻了。<br>接下来，就让我们一起看看怎么把用户分享的数据给到载体应用，让这次分享溜得飞起。</p><a id="more"></a><h2 id="app-groups">App Groups</h2><p>我们都知道 iOS 的应用是跑在一个属于自己的沙盒里面的，为了实现应用间的数据共享，苹果提供了一个叫 App Groups 的概念。只有当应用属于同一个 App Groups 的时候，才能访问到共享的数据存储区域。</p><p>我们可以在载体应用的项目配置 Capabilities -&gt; App Groups 里创建一个应用分组：<br><img src="/uploads/yet-another-ios-extension-article-2/77534A33-46E6-4381-B6EC-4AA09E726A6A.png" alt></p><p>然后在应用扩展的项目配置 Capabilities -&gt; App Groups 里会出现我们刚刚新建的应用分组，直接钩上就可以了。</p><p>这样我们就等于分配了一个共享空间给这哥俩，为我们接下来的数据共享做好准备了。</p><h2 id="共享空间">共享空间</h2><p>做完上面的准备之后，我们就可以通过三种方式去访问共享空间，它们分别是 <code>UserDefaults</code>、<code>FileManager</code> 和 <code>CoreData</code>。</p><h3 id="userdefaults">UserDefaults</h3><p><code>UserDefaults</code> 有一个带参数的初始化方法，通过这个方法我们可以访问到一个共享的用户配置空间。在上一篇文章里，我们成功把 Safari 分享出来的一个 URL 打印了出来，现在我们把它放到共享空间去，让载体应用也可以获取到这个链接：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">attachment.loadItem(forTypeIdentifier: kUTTypeURL <span class="keyword">as</span> <span class="type">String</span>, options: <span class="literal">nil</span>) &#123; (item, error) <span class="keyword">in</span></span><br><span class="line">                        <span class="keyword">if</span> error == <span class="literal">nil</span> &#123;</span><br><span class="line">                            <span class="keyword">let</span> userDefaults = <span class="type">UserDefaults</span>(suiteName: <span class="string">"group.com.davidleee.SharePlayground"</span>)</span><br><span class="line">                            userDefaults?.<span class="keyword">set</span>(item, forKey: <span class="string">"share-url"</span>)</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"url from userdefault: \(userDefaults?.value(forKey: "</span>share-url<span class="string">"))"</span>)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>通过传入之前设置好的应用分组 ID，我们告诉 <code>UserDefault</code> 接下来要访问一个特定的共享空间，接着就像平常那样使用它即可。</p><blockquote><p>上面的打印输出的是一堆 data，以为 <code>URL</code> 在保存到 <code>UserDefaults</code> 的时候会被序列化，想看到原来的 <code>URL</code> 对象的话还要再反序列化一下才行。</p></blockquote><h3 id="filemanager">FileManager</h3><p>与 <code>UserDefaults</code> 类似，<code>FileManager</code> 也有一个特殊的获取方法，我们看看把刚刚的 URL 写到一个文本文件里应该是什么样子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> groupPath = <span class="type">FileManager</span>.<span class="keyword">default</span>.containerURL(forSecurityApplicationGroupIdentifier: <span class="string">"group.com.davidleee.SharePlayground"</span>)</span><br><span class="line">                            <span class="keyword">if</span> <span class="keyword">let</span> url = item <span class="keyword">as</span>? <span class="type">URL</span>, <span class="keyword">let</span> filePath = groupPath?.appendingPathComponent(<span class="string">"url.txt"</span>)  &#123;</span><br><span class="line">                                <span class="keyword">try</span>? url.absoluteString.write(to: filePath, atomically: <span class="literal">true</span>, encoding: .utf8)</span><br><span class="line">                            &#125;</span><br><span class="line">                            </span><br><span class="line">                            <span class="keyword">if</span> <span class="keyword">let</span> filePath = groupPath?.appendingPathComponent(<span class="string">"url.txt"</span>) &#123;</span><br><span class="line">                                <span class="keyword">try</span>? <span class="built_in">print</span>(<span class="string">"content of file: \(String(contentsOf: filePath, encoding: .utf8))"</span>)</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="coredata">CoreData</h3><p>好吧，CoreData 的共享空间其实跟 <code>FileManager</code> 是同一个，只是从写文件变成写数据库，再把数据库的文件放到共享空间而已。这个就不贴代码了，CoreData 里的类名是真的长…</p><h2 id="总结一下">总结一下</h2><p>感觉这篇文章跟应用扩展都没什么关系了…毕竟 App Goups 是 iOS 平台上一个比较通用的数据共享技术。</p><p>App Groups 的引入让 iOS 应用间数据共享成为可能，这不仅可以用在应用扩展和载体应用之间，还可以用在自家的多个独立应用之间，真可谓是沙盒墙上透过来的一道亮光。</p><h2 id="参考文章">参考文章</h2><ul><li><a href="https://my.oschina.net/vimfung/blog/707448" target="_blank" rel="noopener">iOS扩展开发攻略(一) - Share Extension - vimfung的开源部落 - 开源中国</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;/2018/11/14/yet-another-ios-extension-article/&quot; title=&quot;上一篇文章&quot;&gt;上一篇文章&lt;/a&gt;里，我们了解到了 iOS Extension 的基础和怎么制作一个简单的分享扩展，然而，限于篇幅原因，这个分享操作止于用户点下 “Post” 的那一刻了。&lt;br&gt;
接下来，就让我们一起看看怎么把用户分享的数据给到载体应用，让这次分享溜得飞起。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ios" scheme="http://davidleee.com/tags/ios/"/>
    
      <category term="App Groups" scheme="http://davidleee.com/tags/App-Groups/"/>
    
      <category term="Extension" scheme="http://davidleee.com/tags/Extension/"/>
    
      <category term="UserDefaults" scheme="http://davidleee.com/tags/UserDefaults/"/>
    
      <category term="FileManager" scheme="http://davidleee.com/tags/FileManager/"/>
    
      <category term="CoreData" scheme="http://davidleee.com/tags/CoreData/"/>
    
  </entry>
  
  <entry>
    <title>又一篇 iOS Extension 入门（1/3）— 基础 &amp; 分享扩展</title>
    <link href="http://davidleee.com/2018/11/14/yet-another-ios-extension-article/"/>
    <id>http://davidleee.com/2018/11/14/yet-another-ios-extension-article/</id>
    <published>2018-11-14T08:00:50.000Z</published>
    <updated>2020-05-05T03:43:31.446Z</updated>
    
    <content type="html"><![CDATA[<p>应用扩展（App Extension）让你应用的功能和内容都得到了更大的延伸，这让用户在使用其他应用的时候有机会与你的应用发生交互。在这个大家都极力争夺注意力的时代，应用扩展无疑为我们打开了一扇新的大门。</p><a id="more"></a><h2 id="什么是应用扩展？">什么是应用扩展？</h2><p>应用扩展与应用本身是有不同的。尽管在上架应用扩展的时候，你必须以一个普通的应用为载体（Containing App），但是它实际上是一个独立的二进制文件，而且并不依赖于载体应用来运行。</p><p>具体来说，应用扩展分为了十多个类别，你可以通过它们来实现各种各样的功能。下面是官方文档里介绍扩展点（Extension Point）的表格，我调整了一下格式：<br><img src="/uploads/yet-another-ios-extension-article/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-13%20%E4%B8%8B%E5%8D%8812.05.50.png" alt></p><p>我们创建的每一个应用扩展都必须与上表的其中一个扩展点相对应，不允许出现一个应用扩展对应多个扩展点的情况。换句话说，每个应用扩展的职责都应该是单一的，我们应该给用户提供快速、线性、聚焦的体验。</p><h2 id="应用扩展是怎么工作的？">应用扩展是怎么工作的？</h2><h3 id="生命周期">生命周期</h3><p>应用扩展的生命周期有别于一般的应用。应用扩展通常会在另一个应用的使用过程中被唤起，这个应用被称为宿主应用（Host App），宿主应用定义了与应用扩展交流的上下文，并通过发送请求的方式把应用扩展给启动起来。一般来说，应用扩展在完成宿主应用请求的任务之后，生命周期就结束了。<br><img src="/uploads/yet-another-ios-extension-article/app_extensions_lifecycle_2x.png" alt></p><blockquote><p>注意区分“载体应用”和“宿主应用”。载体应用是这个应用扩展的容器，在我们实现应用扩展的时候一并开发出来的；“宿主应用”指的是实际使用过程中调起我们的应用扩展的那个应用。</p></blockquote><p>在上图第2步里，系统在启动了我们的应用扩展之后，会在应用扩展和宿主应用之间建立一条通信通道，用于传递宿主应用定义好的上下文和相关信息。</p><p>应用扩展根据宿主应用发来的请求，执行相应的任务，这些任务可能是立即返回的，也可能通过一个后台进程去完成。但无论是哪种方式，在应用扩展跑完自己的代码逻辑之后，系统就会立马把它结束掉。</p><h3 id="通信">通信</h3><p>上面提到应用扩展和宿主应用之间的通信方式，一个完整的通信关系是这样的：<br><img src="/uploads/yet-another-ios-extension-article/simple_communication_2x.png" alt></p><p>应用扩展不会直接跟载体应用打交道，因为大多数情况下，应用扩展在工作的时候，载体应用甚至都还没有被启动。</p><p>在特殊情况下，比如 Today 小组件，扩展可以向系统提出启动载体应用的申请（通过调用 <code>NSExtensionContext</code> 的 <code>openURL:completionHandler:</code> 方法）。这时，应用扩展与载体应用就可以通过一个私有的共享容器来传递数据了，如下图所示：<br><img src="/uploads/yet-another-ios-extension-article/detailed_communication_2x.png" alt></p><blockquote><p>从系统层面上看，这已经涉及到进程间通信了，但苹果提供的高级 API 很好地屏蔽了这一点，所以我们完全不用考虑这些事情。</p></blockquote><h3 id="应用扩展的-禁忌">应用扩展的“禁忌”</h3><p>因为应用扩展与一般应用的设计是不同的，所以虽然开发起来差不多，但有些 API 是应用扩展无法使用的：</p><ul><li>不能访问 <code>sharedApplication</code></li><li>不能使用头文件里宏定义了 <code>NS_EXTENSION_UNAVAILABLE</code> 的框架，比如 HealthKit 和 EventKit UI 框架</li><li>不能访问摄像头和麦克风，除非它是 iMessage 应用</li><li>不能执行耗时过长的任务，具体限制与平台相关，但是它可以通过 <code>NSURLSession</code> 对象来实现数据上传和下载，最终的结果会给到载体应用</li><li>不能接收 AirDrop 数据，但是它可以发送</li></ul><h2 id="创建应用扩展">创建应用扩展</h2><p>因为每一个扩展点都对应了一个特定的应用场景，所以创建应用扩展的第一步是选择正确的扩展点（可以回到文章开头部分查看扩展点表格）。</p><p>在 File -&gt; New -&gt; Target 里面，找到 Application Extension 模块，在里面选择想要实现的扩展点。这里我选了分享扩展作为例子：<br><img src="/uploads/yet-another-ios-extension-article/7AA6705E-C543-4011-A638-E171E66F8E54.png" alt></p><p>给你的应用扩展起个美美的名字之后，它就会出现在项目配置的侧边栏里了，同时，Xcode 还为我们新建的应用扩展添加了一个 Scheme，让我们可以直接调式扩展而不用启动载体应用：<br><img src="/uploads/yet-another-ios-extension-article/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-13%20%E4%B8%8B%E5%8D%885.45.59.png" alt></p><p>直接运行应用扩展，Xcode 会让你选一个应用来作为应用扩展的宿主：<br><img src="/uploads/yet-another-ios-extension-article/A1A7864C-EA2B-4823-A33D-91656F91569A.png" alt></p><p>分享扩展的兼容性很好，我们选 Safari 来尝试分享一个网页好了：<br><img src="/uploads/yet-another-ios-extension-article/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-13%20%E4%B8%8B%E5%8D%885.48.58.png" alt><br>随便打开一个网页，点击下面的分享按钮，可以看到我们的应用扩展已经出现在分享列表里面了！</p><blockquote><p>应用扩展的图标会跟载体应用的图标一致</p></blockquote><h2 id="talk-is-cheap">Talk is Cheap!</h2><p>创建了应用扩展之后，会发现项目结构里多了一个属于应用扩展的位置：<br><img src="/uploads/yet-another-ios-extension-article/65CB2068-CB5B-4443-A46B-3D8DC3DD5F30.png" alt></p><p>看起来就像一个普通的应用项目的结构，但 <em>Info.plist</em> 里有一个不同点，就是这里的 <code>NSExtension</code> 字典：<br><img src="/uploads/yet-another-ios-extension-article/125ED1F7-CCA8-4D23-9218-5D8212E2D5D8.png" alt><br>看名字都挺好懂的，其中的 <code>NSExtensionAttributes</code> 用来配置一些通用参数，比如支持的媒体类型等等。默认情况下，<code>NSExtensionActivationRule</code> 是一个 <code>String</code> 类型，这个值就是让系统在所有分享场景里都显示我们的应用扩展（我全都要！）。更真实的场景应该是只支持特定的文件类型，这时可以把它改成 <code>Dictionary</code> 类型：<br><img src="/uploads/yet-another-ios-extension-article/D7E348AB-33CD-4DC6-9F54-2005AE2BA66E.png" alt></p><p>上图的设置表示：我们支持分享图片、视频、文件和网页链接，后面的数字表示：一次分享中支持带上多少个这种类型的附件。</p><blockquote><p>除图片和视频外的文件类型，都包括在 File 的范围里面，所以上面的配置几乎涵盖了所有的文件分享场景了</p></blockquote><h3 id="响应请求">响应请求</h3><p>在 Xcode 创建好的 <code>ShareViewController</code> 里，我们可以通过 <code>extensionContext</code> 来拿到宿主应用想要传达给我们的信息：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> items = <span class="keyword">self</span>.extensionContext?.inputItems</span><br></pre></td></tr></table></figure><p>这是一个 <a href="https://developer.apple.com/documentation/foundation/nsextensionitem" target="_blank" rel="noopener">NSExtensionItem</a> 数组，每一个 <code>NSExtensionItem</code> 都带有一系列属性，例如标题、内容、附件、用户信息。</p><p>系统会回调 <code>didSelectPost</code> 或 <code>didSelectCancel</code> 以通知我们用户操作的结果，在这两个回调方法里，我们需要调用 <code>completeRequest(returningItems:completionHandler:)</code> 返回一系列 <code>NSExtensionItem</code> 对象给宿主应用，或者调用 <code>cancelRequest(withError:)</code> 返回一个错误。</p><h3 id="获取附件">获取附件</h3><p>从 <code>NSExtensionItems</code> 里能直接获取到的信息是远远不够的，真正的大部头都在 <code>attachments</code> 这个属性里。这是一个 <a href="https://developer.apple.com/documentation/foundation/nsitemprovider" target="_blank" rel="noopener">NSItemProvider</a> 类型的数组，自此我们就基本看到了整个 <code>NSExtensionContext</code> 的构成了，借用一张其他博客的图片：<br><img src="/uploads/yet-another-ios-extension-article/221150_8LYD_222120.png" alt></p><p>好，回到正题。拿到 <code>NSItemProvider</code> 之后，会发现要从这个类里面拿东西并不简单。</p><p>继续上面的例子，我们打算在用户点击 “Post” 按钮之后，获取从 Safari 分享过来的 URL，完整的代码是这样的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didSelectPost</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// This is called after the user selects Post. Do the upload of contentText and/or NSExtensionContext attachments.</span></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> items = extensionContext?.inputItems <span class="keyword">as</span>? [<span class="type">NSExtensionItem</span>] <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items &#123;</span><br><span class="line">        <span class="keyword">for</span> attachment <span class="keyword">in</span> item.attachments ?? [] &#123;</span><br><span class="line">            <span class="comment">// 3</span></span><br><span class="line">            <span class="keyword">if</span> attachment.hasItemConformingToTypeIdentifier(kUTTypeURL <span class="keyword">as</span> <span class="type">String</span>) &#123;</span><br><span class="line">                <span class="comment">// 4</span></span><br><span class="line">                attachment.loadItem(forTypeIdentifier: kUTTypeURL <span class="keyword">as</span> <span class="type">String</span>, options: <span class="literal">nil</span>) &#123; (item, error) <span class="keyword">in</span></span><br><span class="line">                                                                                            <span class="keyword">if</span> error == <span class="literal">nil</span> &#123;</span><br><span class="line">                                                                                                <span class="built_in">print</span>(<span class="string">"found an url: \(item)"</span>)</span><br><span class="line">                                                                                            &#125;</span><br><span class="line">                                                                                           &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inform the host that we're done, so it un-blocks its UI. Note: Alternatively you could call super's -didSelectPost, which will similarly complete the extension context.</span></span><br><span class="line">    <span class="keyword">self</span>.extensionContext!.completeRequest(returningItems: [], completionHandler: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>inputItems</code> 是一个 <code>[Any]</code> 类型的数组，所以在使用之前需要转换一下</li><li>如果允许用户分享的时候多选的话，需要逐层遍历 <code>items</code> 和 <code>attachments</code></li><li>判断附件的类型，附件类型使用 <a href="https://developer.apple.com/library/archive/documentation/Miscellaneous/Reference/UTIRef/Articles/System-DeclaredUniformTypeIdentifiers.html#//apple_ref/doc/uid/TP40009259-SW1" target="_blank" rel="noopener">UTI（Uniform Type Identifier）</a> 来表示，在 iOS 平台使用的时候需要先执行 <code>import MobileCoreService</code></li><li>读取指定类型的附件内容，回调过来的 <code>item</code> 是 <code>NSSecureCoding?</code> 类型的，这里只简单打印了一下，真正使用的时候还需要补充一些额外处理</li></ol><h2 id="性能要求">性能要求</h2><p>应用扩展对于用户来说应该是敏捷而且轻量的小工具，所以它的启动速度务必要保持在1秒以内，系统会自动关闭启动耗时太长的应用扩展。</p><p>对于 Widget 来说，界面上通常会一次显示多个，所以 Widget 的内存使用要求是最严格的（大概是16 MB），一旦超出了限制，会显示 “Unable to Load” 的字样：<br><img src="/uploads/yet-another-ios-extension-article/TodayWidgetUnableToLoad.jpg" alt></p><p>其他类型的应用扩展对内存的要求会松一点，但还是比一般应用要严格，比如自定义键盘要求 48 MB 以下，分享扩展要求 120 MB 以下，实际情况可能跟设备相关。</p><p>另外，应用扩展是公用同一个主线程的，所以不要在应用扩展的逻辑里做可能会阻塞主线程的操作。同理，GPU 也是这样一个共享资源，如果一个应用扩展需要执行大量绘图逻辑，系统会倾向于把它结束掉。</p><p>总而言之，开销大的操作都应该在载体应用里做，而不是让应用扩展去负责。</p><h2 id="总结一下">总结一下</h2><p>本文介绍了什么是应用扩展，并介绍了一个简单的分享扩展是怎么实现的。文章大体是来源于官方的文档，虽然文档已经被苹果归档了，但是文中的代码都是我写完用模拟器验证后得来的（2018年11月14日），大家可以直接拿走按需服用 :)</p><blockquote><p>没想到只是介绍了一些基础就写了这么多。其实我还打算讲讲分享之后怎么跟载体应用交互，还想要看看今日小组件（Today Widget）怎么整…只好放到后面的文章里去了。  我发誓在这周之内把这两部分内容都给补上来！</p><p>你们看，我写完了：</p><ul><li><a href="/2018/11/14/yet-another-ios-extension-article-2/" title="又一篇 iOS Extension 入门（2/3）— 与容器沟通">又一篇 iOS Extension 入门（2/3）— 与容器沟通</a></li><li><a href="/2018/11/15/yet-another-ios-extension-article-3/" title="又一篇 iOS Extension 入门（3/3）— Today 小组件">又一篇 iOS Extension 入门（3/3）— Today 小组件</a></li></ul></blockquote><h2 id="参考文章">参考文章</h2><ul><li><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/index.html#//apple_ref/doc/uid/TP40014214-CH20-SW1" target="_blank" rel="noopener">App Extension Programming Guide: App Extensions Increase Your Impact</a></li><li><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/Share.html#//apple_ref/doc/uid/TP40014214-CH12-SW1" target="_blank" rel="noopener">App Extension Programming Guide: Share</a></li><li><a href="https://my.oschina.net/vimfung/blog/707448" target="_blank" rel="noopener">iOS扩展开发攻略(一) - Share Extension - vimfung的开源部落 - 开源中国</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;应用扩展（App Extension）让你应用的功能和内容都得到了更大的延伸，这让用户在使用其他应用的时候有机会与你的应用发生交互。在这个大家都极力争夺注意力的时代，应用扩展无疑为我们打开了一扇新的大门。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ios" scheme="http://davidleee.com/tags/ios/"/>
    
      <category term="App Groups" scheme="http://davidleee.com/tags/App-Groups/"/>
    
      <category term="Extension" scheme="http://davidleee.com/tags/Extension/"/>
    
      <category term="Share" scheme="http://davidleee.com/tags/Share/"/>
    
      <category term="NSExtensionItem" scheme="http://davidleee.com/tags/NSExtensionItem/"/>
    
      <category term="NSItemProvider" scheme="http://davidleee.com/tags/NSItemProvider/"/>
    
  </entry>
  
  <entry>
    <title>怎么在命令行给 macOS 设置开机启动任务</title>
    <link href="http://davidleee.com/2018/11/07/login-items-for-macos/"/>
    <id>http://davidleee.com/2018/11/07/login-items-for-macos/</id>
    <published>2018-11-07T08:16:12.000Z</published>
    <updated>2020-05-05T03:43:31.443Z</updated>
    
    <content type="html"><![CDATA[<p>最近通过 docker + nginx 在 一台 Mac mini 上面配了个简易文件系统，好让其他人能方便地下载一些预先写好的配置文件，这部分就不细说了。文件系统跑起来之后，考虑到便利性，想要再添加一个开机自启动的逻辑，让这个文件系统在电脑重启之后也能自己跑起来。</p><p>在 Linux 系统下面，我们可以通过 <code>systemctl</code>  或者直接修改 <em>rc.local</em> 文件<br>来实现启动项的添加。但是这一套在 macOS 上面玩不转了，因为我们需要通过一个完全不一样的机制—— <strong>Launch Daemon</strong> 来实现这个功能。</p><a id="more"></a><h2 id="要做的事情">要做的事情</h2><p>因为 macOS 的启动项是通过一个 plist 去配置的，配置一个脚本远比配置一段要执行的命令行指令要简单，所以这里采用脚本的方式去实现。</p><p>于是我们要做的事情只有两步：</p><ol><li>创建一个脚本文件去执行 docker-compose 的启动指令</li><li>让这个脚本在系统启动的时候执行（不需要用户登录）</li></ol><h2 id="开始吧">开始吧</h2><h3 id="创建脚本">创建脚本</h3><p>先创建一个脚本文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim startup.sh</span><br></pre></td></tr></table></figure><p>不考虑异常情况，就是简单地进到 docker-compose.yaml 所在的目录，然后执行一下启动命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">cd /Users/davidleee/Desktop/docker-nginx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> make sure it runs</span></span><br><span class="line">while [ $(docker inspect -f '&#123;&#123;.State.Running&#125;&#125;' docker-nginx_nginx_1) != "true" ]</span><br><span class="line">do</span><br><span class="line">  echo "Launching file-service with docker-compose..."</span><br><span class="line">  docker-compose up -d</span><br><span class="line">  sleep 2</span><br><span class="line">done</span><br></pre></td></tr></table></figure><blockquote><p>为了避免我们执行 <code>docker-compose</code> 的时候 docker 自己还没有跑起来，所以用一个循环去检测我们的服务是不是真的启动了。</p><p>另外还要记得把上面的 <code>docker-nginx_nginx_1</code> 改成你真正的的容器名称。</p></blockquote><p>别忘了给脚本加上执行权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x startup.sh</span><br></pre></td></tr></table></figure><h3 id="配置启动项">配置启动项</h3><p>现在我们要把上面的脚本添加到 <strong>Launch Daemon</strong> 里面去。</p><p>在此之前，让我们先理清一些概念。</p><p>macOS 通过一系列的 plist 文件来配置启动项，这些 plist 根据存放位置的不同而分为 <strong>Launch Daemon</strong> 和 <strong>Launch Agent</strong>。它们的区别在于，Agent 是在用户登录之后以该用户的身份去执行的任务，而 Daemon 是以根用户或 <code>UserName</code> 里指定的用户去执行的任务。</p><p>它们一般存放在这两个地方：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/Library/LaunchDaemons</span><br><span class="line"></span><br><span class="line">/Library/LaunchAgents/</span><br></pre></td></tr></table></figure><p>我们这次的任务需要用到 root 权限，所以我们将会在 LaunchDaemons 里创建一个配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /Library/LaunchDaemons/com.file-service.plist</span><br></pre></td></tr></table></figure><p>然后在里面填上以下内容：（注释部分可以去掉咯）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">plist</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//Apple//DTD PLIST 1.0//EN"</span> <span class="meta-string">" [http://www.apple.com/DTDs/PropertyList-1.0.dtd](http://www.apple.com/DTDs/PropertyList-1.0.dtd) "</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plist</span> <span class="attr">version</span>=<span class="string">"1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Launch Daemon 不一定有权限访问所有需要的环境变量</span></span><br><span class="line"><span class="comment">在没有权限的时候，启动项执行会失败，所以我们在这里配置一下脚本需要的环境变量 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>EnvironmentVariables<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">key</span>&gt;</span>PATH<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">string</span>&gt;</span>/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>Label<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 习惯上，我们会用一个 identifier 样式的名字来作为启动项的名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>com.file-service<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>Program<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 要执行的脚本的绝对路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>/Users/davidleee/Desktop/docker-nginx/startup.sh<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这个 key 告诉系统在启动的时候执行我们的脚本</span></span><br><span class="line"><span class="comment">  对于 daemons 来说是系统启动之后，对于 agent 来说则是用户登录之后 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>RunAtLoad<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 判断是按需启动我们的启动项，还是永远运行下去</span></span><br><span class="line"><span class="comment">现在我们自己跑的是自己的脚本，按需启动就可以了 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>KeepAlive<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">false</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>LaunchOnlyOnce<span class="tag">&lt;/<span class="name">key</span>&gt;</span>        </span><br><span class="line">    <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在调试脚本的时候很好用，可以指定脚本正常/错误输出的路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>StandardOutPath<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>/tmp/startup.stdout<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>StandardErrorPath<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>/tmp/startup.stderr<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>UserName<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 执行脚本的用户 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>davidleee<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plist</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后就是把这个 plist 加载到 launchctl 里面去了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># `-w` 会把 plist 永久添加到 Launch Daemon 里面</span></span><br><span class="line">sudo launchctl load -w /Library/LaunchDaemons/com.file-service.plist</span><br><span class="line"></span><br><span class="line"><span class="comment"># ...如果你不想让它自启动了</span></span><br><span class="line">sudo launchctl unload -w /Library/LaunchDaemons/com.file-service.plist</span><br></pre></td></tr></table></figure><h2 id="写在最后">写在最后</h2><p>在执行完上面的 <code>launchctl load</code> 指令之后，plist 里面配置的脚本会马上被执行，你可以通过 <code>launchctl start</code> 和 <code>launchctl stop</code> 来控制它的开关，不过我们这里只是执行了一个脚本，并不会像其他应用那样长驻，所以其实也就没有“开关”一说了。</p><h2 id="参考文章">参考文章</h2><ul><li><a href="https://medium.com/@fahimhossain_16989/adding-startup-scripts-to-launch-daemon-on-mac-os-x-sierra-10-12-6-7e0318c74de1" target="_blank" rel="noopener">Adding Startup Scripts to Launch Daemon on Mac OS X Sierra 10.12.6</a></li><li><a href="https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingLaunchdJobs.html" target="_blank" rel="noopener">Creating Launch Daemons and Agents</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近通过 docker + nginx 在 一台 Mac mini 上面配了个简易文件系统，好让其他人能方便地下载一些预先写好的配置文件，这部分就不细说了。文件系统跑起来之后，考虑到便利性，想要再添加一个开机自启动的逻辑，让这个文件系统在电脑重启之后也能自己跑起来。&lt;/p&gt;
&lt;p&gt;在 Linux 系统下面，我们可以通过 &lt;code&gt;systemctl&lt;/code&gt;  或者直接修改 &lt;em&gt;rc.local&lt;/em&gt; 文件&lt;br&gt;
来实现启动项的添加。但是这一套在 macOS 上面玩不转了，因为我们需要通过一个完全不一样的机制—— &lt;strong&gt;Launch Daemon&lt;/strong&gt; 来实现这个功能。&lt;/p&gt;
    
    </summary>
    
    
      <category term="macOS" scheme="http://davidleee.com/tags/macOS/"/>
    
      <category term="Launch Daemons" scheme="http://davidleee.com/tags/Launch-Daemons/"/>
    
      <category term="Launch Agent" scheme="http://davidleee.com/tags/Launch-Agent/"/>
    
      <category term="plist" scheme="http://davidleee.com/tags/plist/"/>
    
      <category term="launchctl" scheme="http://davidleee.com/tags/launchctl/"/>
    
  </entry>
  
  <entry>
    <title>SVG 从“完全不懂”到“足够开个入门分享”</title>
    <link href="http://davidleee.com/2018/10/25/SVG-from-nothing-to-something/"/>
    <id>http://davidleee.com/2018/10/25/SVG-from-nothing-to-something/</id>
    <published>2018-10-25T07:08:10.000Z</published>
    <updated>2020-05-05T03:43:31.442Z</updated>
    
    <content type="html"><![CDATA[<p>最近需要在 React-Native 项目里实现一个填满特定图形的效果，找很久都没发现能满足需求的开源库，于是就打算用 SVG 自己怼一个。好在这方面教程还不少，虽然不能一步到位，但几篇文章加一起也能把效果实现出来，于是在这里把入门过程记录一下，希望帮后来者省点功夫。</p><a id="more"></a><h2 id="svg-是个啥？">SVG 是个啥？</h2><p>SVG（Scalable Vector Graphics） 是一种基于 XML 语法的图像格式。跟基于像素处理的图片格式不同，它是基于对图像形状的描述来实现的，本质上是一个文本文件，体积上较小，而且在放大的时候也不会失真。</p><p>因为 SVG 是基于 XML 语法的，所以对于前端开发者来说，写起来应该比较顺手；对于 React-Native 的项目，因为 JSX 的关系，用起 SVG 来也是没有“语言障碍”的。</p><h2 id="svg-长什么样？">SVG 长什么样？</h2><p>直接上源码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">'100'</span> <span class="attr">height</span>=<span class="string">"100"</span> <span class="attr">viewBox</span>=<span class="string">"0 0 100 100"</span> <span class="attr">version</span>=<span class="string">"1.1"</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/2000/svg"</span> <span class="attr">xmlns:xlink</span>=<span class="string">"http://www.w3.org/1999/xlink"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">defs</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">clipPath</span> <span class="attr">id</span>=<span class="string">"heart"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">"M81.495,13.923c-11.368-5.261-26.234-0.311-31.489,11.032C44.74,13.612,29.879,8.657,18.511,13.923  C6.402,19.539,0.613,33.883,10.175,50.804c6.792,12.04,18.826,21.111,39.831,37.379c20.993-16.268,33.033-25.344,39.819-37.379  C99.387,33.883,93.598,19.539,81.495,13.923z"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">clipPath</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">defs</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">'0'</span> <span class="attr">y</span>=<span class="string">'0'</span> <span class="attr">fill</span>=<span class="string">'rgb(217,217,217)'</span> <span class="attr">width</span>=<span class="string">"100%"</span> <span class="attr">height</span>=<span class="string">"100%"</span> <span class="attr">clip-path</span>=<span class="string">"url(#heart)"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">'0%'</span> <span class="attr">y</span>=<span class="string">"50%"</span> <span class="attr">fill</span>=<span class="string">'red'</span> <span class="attr">width</span>=<span class="string">"100%"</span> <span class="attr">height</span>=<span class="string">"100%"</span> <span class="attr">clip-path</span>=<span class="string">"url(#heart)"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这张 SVG 图渲染出来是这样的：<br><img src="/uploads/SVG-from-nothing-to-something/57D524DA-6FD7-4538-A238-B002D099D91A.png" alt></p><blockquote><p>直接把上面的代码保存为文本，就可以用浏览器打开并显示了。macOS 的用户还可以直接空格预览。</p></blockquote><p>配合一些参数的改变，做动画也是分分钟的事情。对于之前没有怎么用过 SVG 的我来说，简直是打开了新世界的大门。</p><p>接下来就让我们一起探究一下上面这个图是怎么来的。</p><h2 id="svg-显示原理">SVG 显示原理</h2><p>根据上面的例子，我们可以大胆猜测一下： <code>&lt;path&gt;</code> 标签下 <code>d</code> 属性的值就是用来描绘这个心形的外框路径的。既然描绘路径已经是确定的了，那一张 SVG 图片是怎么实现缩放不失真的特性的呢？<br>要回答这个问题，就要让我们先了解一下 SVG 的一些基本显示原理。</p><h3 id="the-svg-canvas">The SVG Canvas</h3><p>假设我们要将一个 SVG 图形绘制到一张画布（Canvas）上，概念上这张画布应该是无限大的，这样我们的图形才可以是任意大小。然而，实际上 SVG 图片是显示在一个有限的区域里的，就像我们透过窗户看窗外的风景一样，这个有限区域被称为“观察孔”（Viewport）。</p><h3 id="the-viewport">The Viewport</h3><p>“观察孔”指的是 SVG 图片可见的那一部分，想象我们透过窗户看窗外的风景，这个窗子就是外面风景的观察孔。</p><blockquote><p>类似的，我们在浏览网页的时候面对的也是这种情况，网页的大小通常比浏览器的窗口要大，这时候浏览器就是这个网页的观察孔了。</p></blockquote><p>我们通过设置 <code>&lt;svg&gt;</code> 标签的 <code>width</code> 和 <code>height</code> 属性来确定这张 SVG 的观察孔大小，对于上面的心形来说，观察孔是 100x100 的正方形：</p><figure class="highlight svg"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- the viewport will be 100px by 100px --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"100"</span> <span class="attr">height</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- SVG content drawn onto the SVG canvas --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>在 SVG 里，数值的单位是可选的。在我们不主动提供的时候，默认会以 <code>px</code> 为单位。可选的单位有 <code>em</code>、<code>ex</code>、<code>px</code>、<code>pt</code>、<code>pc</code>、<code>cm</code>、<code>mm</code>、<code>in</code> 和百分比。</p></blockquote><h3 id="坐标系统">坐标系统</h3><p>在观察孔的大小确定下来之后，SVG 就会建立一套初始的坐标系统：以最左上角为 <code>(0, 0)</code> 点，x 轴和 y 轴分别向右和向下延伸（就像移动客户端和网页显示里那样）。在这个基础上，我们刚刚创建的观察孔也就有了属于自己的一套位置标识：<code>(x: 0, y: 0, width: 100, height: 100)</code>。</p><h2 id="the-viewbox">The <code>viewbox</code></h2><p>在了解了上述知识之后，我们就可以来说说 <code>viewbox</code> 这个属性了。</p><p>我们可以把 <code>viewbox</code> 理解为“真正的坐标系统”，因为它决定了 SVG 图形是怎么绘制到画布上的。一个 SVG 图形的大小可以与观察孔不一样，它可能会完整地显示出来，也可能会被观察孔裁减掉一部分。</p><blockquote><p>就像一张普通图片一样，当你需要把图形完整地放进一个视图里面时，可以调节图片的拉伸模式，一边让图片的大小更为合理。SVG 里对应的属性是 <code>preserveAspectRatio</code>。</p></blockquote><p><code>viewbox</code>  会一次性设置4个参数：</p><figure class="highlight svg"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">viewbox</span>=<span class="string">"&lt;min-x&gt; &lt;min-y&gt; &lt;width&gt; &lt;height&gt;"</span>&gt;</span><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中，<code>&lt;min-x&gt;</code> 和 <code>&lt;min-y&gt;</code> 不能设置为负数，<code>&lt;width&gt;</code> 和 <code>&lt;height&gt;</code> 设置为 0 的话，元素就压根不会绘制了。</p><p>所以说，<code>viewbox=&quot;0 0 100 100&quot;</code> 就做了下面几件事情：</p><ol><li>在画布上划分出来一个 100x100 大小的区域，放在 (0, 0) 点上</li><li>把 SVG 图形缩放成合适这个区域的样子</li><li>将整个区域（包括里面的图形）放大到铺满整个观察孔</li><li>将这个坐标系统<strong>按比例</strong>映射到到初始坐标系统上</li></ol><p>那对于上面的爱心图片来说，我们尝试调整一下 <code>viewbox</code> 的原点，将它设置为 <code>viewbox=&quot;50 50 100 100&quot;</code> 试试：<br><img src="/uploads/SVG-from-nothing-to-something/353B4442-E68D-4F8A-8D53-CE5EEED21F36.png" alt><br>可以看到，就像地图软件一样，镜头往画面的右下方移动了一段。这也相当于把整个画面往左上方推了过去一点，我们可以通过设置画布的 <code>transform</code> 属性来实现相同的效果：<code>transform=&quot;translate(-50 -50)&quot;</code>。</p><blockquote><p>当设计师给你一张 SVG 图片的时候，其中的图案路径可能是按照一定的大小和位移来绘制的，比如从(10, 10) 点开始画的一张 40x40 的图，这时候你的 <code>viewbox</code> 就应该设置为 <code>viewbox=&quot;10 10 40 40&quot;</code> ，让图片放到最合适的坐标系统上。</p></blockquote><h2 id="小结">小结</h2><p>上面的例子演示了一张 SVG 图的常规操作，限于篇幅原因，还有一些有意思的情况没有展示到，比如当 <code>viewbox</code> 里设置的宽高比与我们在 <code>&lt;svg&gt;</code> 标签里设置的宽高比不一样会发生什么呢？这种情况下，就需要我们去了解一下 <code>preserveAspectRatio</code> 属性了。</p><p>在参考文章 <a href="https://www.sarasoueidan.com/blog/svg-coordinate-systems/" target="_blank" rel="noopener">Understanding SVG Coordinate Systems and Transformations (Part 1) </a> 里，有对这方面更详细的解释，而且作者还提供了非常直观的在线预览工具，相信会对偏向于使用图像思维的同学们更有帮助。</p><h2 id="参考文章">参考文章</h2><ul><li><a href="https://www.sarasoueidan.com/blog/svg-coordinate-systems/" target="_blank" rel="noopener">Understanding SVG Coordinate Systems and Transformations (Part 1) </a></li><li><a href="http://www.ruanyifeng.com/blog/2018/08/svg.html" target="_blank" rel="noopener">SVG 图像入门教程 - 阮一峰的网络日志</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近需要在 React-Native 项目里实现一个填满特定图形的效果，找很久都没发现能满足需求的开源库，于是就打算用 SVG 自己怼一个。好在这方面教程还不少，虽然不能一步到位，但几篇文章加一起也能把效果实现出来，于是在这里把入门过程记录一下，希望帮后来者省点功夫。&lt;/p&gt;
    
    </summary>
    
    
      <category term="svg" scheme="http://davidleee.com/tags/svg/"/>
    
      <category term="xml" scheme="http://davidleee.com/tags/xml/"/>
    
      <category term="markup" scheme="http://davidleee.com/tags/markup/"/>
    
      <category term="react-native" scheme="http://davidleee.com/tags/react-native/"/>
    
      <category term="viewbox" scheme="http://davidleee.com/tags/viewbox/"/>
    
      <category term="clippath" scheme="http://davidleee.com/tags/clippath/"/>
    
  </entry>
  
  <entry>
    <title>CSS 句法</title>
    <link href="http://davidleee.com/2018/10/19/CSS-syntax/"/>
    <id>http://davidleee.com/2018/10/19/CSS-syntax/</id>
    <published>2018-10-19T11:54:42.000Z</published>
    <updated>2020-05-05T03:43:31.441Z</updated>
    
    <content type="html"><![CDATA[<p>CSS 是声明型语言，这让它的句法（syntax）非常直白易懂。</p><p>除此之外，它还有很好的错误恢复机制，它能避免在错误发生时把所有东西都弄得一团乱：比如说在它碰到不认识的声明时，它会直接忽略掉这个东西。但从另一方面来说，这也让错误更难被发现了。</p><p>借着最近前端同事事务繁忙的机会，我这客户端工程师赶鸭子上架怼了一个静态网页出来，顺便产下了两篇副产品，都与 CSS 基础相关，这是第二篇（第一篇在此： <a href="/2018/10/19/How-CSS-works/" title="CSS 是怎么运作的">CSS 是怎么运作的</a>），希望对其他可能有相同需要的同志送上一些帮助。</p><a id="more"></a><h2 id="名词解释">名词解释</h2><p>正如<a href="/2018/10/19/How-CSS-works/" title="上一篇文章">上一篇文章</a>里说到的，CSS 是由选择器和一组属性组成的。其中，属性部分是由一系列的键值对组成，在 CSS 的世界里，它们有着自己的名字：</p><ul><li>属性（Properties）：以“说人话”的方式表明这个玩意儿是干什么的</li><li>值（Values）：每个属性都会有对应的值，表示你想要怎么修改这个东西</li></ul><p>这样的一组“属性-值”的组合，我在前面直接称呼为“键值对”了，但它在 CSS 世界里的本名其实是 <strong>CSS 声明（CSS declaration）</strong>。<br>被一对大括号包裹起来的一组 CSS 声明被称为 <strong>CSS 声明块（CSS declaration blocks）</strong>。<br>最后，一个 CSS 声明块会跟一个选择器搭配起来，称为 <strong>CSS 规则（CSS Rulesets/Rules）</strong>。</p><h3 id="css-声明">CSS 声明</h3><p>把 CSS 属性设置为一个特定的值，可以说是 CSS 这门语言的最核心功能了。需要注意的是，属性和值都是区分大小写的，它们之间用 “:” 来分隔。</p><p>目前，CSS 世界里一共有<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Reference" target="_blank" rel="noopener">300 种不同的属性</a>，每种属性都有其对应的可选值。</p><blockquote><p>在 CSS 语法里（包括其他 web 标准中），美式拼写是唯一的拼写标准。比如说，在需要设置颜色的时候，<code>color</code> 永远优于 <code>colour</code>。</p></blockquote><h3 id="css-声明块">CSS 声明块</h3><p>CSS 声明以代码块的形式存在，用一对大括号括起来。</p><blockquote><p>CSS 声明块可以是空的（里面不带任何声明）</p></blockquote><p>CSS 声明块里的不同声明是通过 “;” 来分隔的。</p><blockquote><p>实际上，最后一组声明是可以不用分号结尾的，但是好好的干嘛要逼死强迫症呢？</p></blockquote><h3 id="css-选择器和规则">CSS 选择器和规则</h3><p>在写好了声明块之后，我们还需要告诉浏览器这些属性要用到哪里去，这就需要在这个声明块前面加上一个前缀——选择器了。</p><p>选择器可以是非常复杂的：你可以把一个声明块应用到好几个选择器上，通过逗号分隔；你还可以链式地构造一个指向性更明确的选择器，比如：选择一个类名是 “abc” 的元素，它要在 <code>&lt;article&gt;</code> 标签下，而且只有鼠标移动到它上面的时候才生效。</p><p>一个元素可能被多个选择器看上，所以同一个属性可能会被改变多次，CSS 会通过层叠算法（cascade algorithm）来判断这些属性修改的优先级。</p><blockquote><p>对于同一个声明块，在使用复杂选择器的时候（比如存在多个选择器），如果其中的某一项选择有误，那么其他的选择器是不会被影响的，该怎么工作还是怎么工作。</p></blockquote><h3 id="css-语句">CSS 语句</h3><p>除了上面看到的声明块之外， CSS 里还有一些其他类型的语句：</p><ul><li><strong>At-规则</strong> 用来传达元数据、条件信息或其他描述性信息。比如说：<ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@charset" target="_blank" rel="noopener">@charset</a>  和  <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@import" target="_blank" rel="noopener">@import</a>  (元数据)</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@media" target="_blank" rel="noopener">@media</a>  或者  <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@document" target="_blank" rel="noopener">@document</a>  (条件信息，也叫内部语法)</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face" target="_blank" rel="noopener">@font-face</a>  (描述性信息)<br>完整的写法是这样的：</li></ul></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">'custom.css'</span>; <span class="comment">/* 从另一个 css 文件中引入规则 */</span></span><br></pre></td></tr></table></figure><ul><li><strong>内部语法（Nested statements）</strong> 是 at-规则 的一个子集，这类规则只会在特定条件下才会生效：<ul><li><code>@media</code> 运行设备符合某些条件时才执行</li><li><code>@supports</code> 浏览器支持某些测试特性的时候才执行</li><li><code>@document</code> 当前页面符合某些条件时才执行<br>举个例子：</li></ul></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width:</span> <span class="number">801px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">800px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述针对 <code>body</code> 的规则，只在设备宽度大于 800px 的时候才会生效。</p><h2 id="小结">小结</h2><p>分两篇叙述的 CSS 相关知识就讲完了。这两篇文章的主要目的是把我们领进前端世界的大门，读完之后，我们应该可以实现一些简单的静态页面了！<sub>（小声说：虽然具体怎么用还需要自己去谷歌百度一下）</sub>当然，前端的魅力还远不止如此，要想把 CSS 玩出花儿来，还需要持续的磨练。</p><p>我这个半吊子的前端工程师总算是把整个静态页面的需求给怼出来啦！接下来如果有时间的话，我会再把页面里用到的一些 JS 实现的逻辑也拉出来溜一溜。要是这下一篇文章真的有诞生之日的话，那读到完整三个部分的同学们就会在前端界六得飞起<sub>（假的）</sub>了！</p><h2 id="参考文章">参考文章</h2><p><a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Introduction_to_CSS/Syntax" target="_blank" rel="noopener">CSS syntax - Learn web development | MDN</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSS 是声明型语言，这让它的句法（syntax）非常直白易懂。&lt;/p&gt;
&lt;p&gt;除此之外，它还有很好的错误恢复机制，它能避免在错误发生时把所有东西都弄得一团乱：比如说在它碰到不认识的声明时，它会直接忽略掉这个东西。但从另一方面来说，这也让错误更难被发现了。&lt;/p&gt;
&lt;p&gt;借着最近前端同事事务繁忙的机会，我这客户端工程师赶鸭子上架怼了一个静态网页出来，顺便产下了两篇副产品，都与 CSS 基础相关，这是第二篇（第一篇在此： &lt;a href=&quot;/2018/10/19/How-CSS-works/&quot; title=&quot;CSS 是怎么运作的&quot;&gt;CSS 是怎么运作的&lt;/a&gt;），希望对其他可能有相同需要的同志送上一些帮助。&lt;/p&gt;
    
    </summary>
    
    
      <category term="css" scheme="http://davidleee.com/tags/css/"/>
    
      <category term="html" scheme="http://davidleee.com/tags/html/"/>
    
      <category term="web" scheme="http://davidleee.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>CSS 是怎么运作的</title>
    <link href="http://davidleee.com/2018/10/19/How-CSS-works/"/>
    <id>http://davidleee.com/2018/10/19/How-CSS-works/</id>
    <published>2018-10-19T11:28:35.000Z</published>
    <updated>2020-05-05T03:43:31.441Z</updated>
    
    <content type="html"><![CDATA[<p>CSS 全称 Cascading Style Sheets，网页内容（HTML）会被浏览器转换为 DOM（Document Object Model）以供显示，而 CSS 就是作用在 DOM 上以改变它们的样式、布局或行为等。对于前端工程师来说，这是很常见的基本操作了，但是对其他不常敲网页代码的程序员来说，却可能会有些陌生。</p><p>借着最近前端同事事务繁忙的机会，我这客户端工程师赶鸭子上架怼了一个静态网页出来，顺便产下了两篇副产品，都与 CSS 基础相关，这是第一篇，希望能对其他可能有相同需要的同志送上一些帮助。</p><a id="more"></a><blockquote><p>文章的内容基本是翻译 MDN 文档来的，怕有什么遗漏的同学可以直接翻到文末看官文，也欢迎指出本文的错误 :)</p></blockquote><h2 id="css-是怎么作用到-html-上的？">CSS 是怎么作用到 HTML 上的？</h2><p>网页浏览器会把 CSS 规则应用到文档上，以改变文档内容的表现形式，一个单一的 CSS 规则是由下面这两个东西组成的：</p><ol><li>一组属性（Properties）：这些参数会更新 HTML 的内容，让它在显示的时候与众不同</li><li>一个选择器（Selector）：用来挑选要作用到哪个元素上</li></ol><p>一个 CSS 规则约定了某个元素长什么样，一个包含了一组 CSS 规则（Rulesets/Rules）的 <code>stylesheet</code> 就定义了一个网页的长相。</p><h3 id="举个例子">举个例子</h3><p>来看一个简单的 HTML 文档，这个例子里包含了 <code>&lt;h1&gt;</code> 和 <code>&lt;p&gt;</code> 标签，而 <code>stylesheet</code> 则是通过 <code>&lt;link&gt;</code> 元素实现的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>My CSS experiment<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"style.css"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is my first CSS example<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后看两个 CSS 的规则：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">  <span class="attribute">background-color</span>: yellow;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这两个 CSS 规则是写在 <em>style.css</em> 文件里的，跟上面的 <em>.html</em> 文件放在一起就可以通过相对路径引用到</p></blockquote><p>大括号签名的标签（<code>h1</code> 和 <code>p</code>）就是选择器，它告诉浏览器这些规则要作用在什么标签上；而大括号里的键值对就约定了这些标签的内容的显示规则。</p><h2 id="原理呢？">原理呢？</h2><p>浏览器在处理网页的时候，会分两步走：</p><ol><li>把 HTML 和 CSS 转换为 DOM，DOM 会把内容和样式融合到一起</li><li>把 DOM 的内容显示出来<br><img src="/uploads/How-CSS-works/D90AF498-F58B-4AEF-91B9-9E38F4863B92.png" alt="DOM"></li></ol><h2 id="介绍一下-dom">介绍一下 DOM</h2><p>一个 DOM 的内容是以树状结构保存的。每个通过 markup 语言表述的元素、属性、文字等会变成 DOM 节点保存在树上。</p><h3 id="dom-的真面目">DOM 的真面目</h3><p>假设我们有一段 HTML 代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  Let's use:</span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Cascading<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Style<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Sheets<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将它转换为 DOM 之后，这个 DOM 会是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">P</span><br><span class="line">├─ &quot;Let&apos;s use:&quot;</span><br><span class="line">├─ SPAN</span><br><span class="line">|  └─ &quot;Cascading&quot;</span><br><span class="line">├─ SPAN</span><br><span class="line">|  └─ &quot;Style&quot;</span><br><span class="line">└─ SPAN</span><br><span class="line">   └─ &quot;Sheets&quot;</span><br></pre></td></tr></table></figure><p>现在来加一个 CSS 约束试试：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">  <span class="attribute">background-color</span>: lime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>emmm…还是跟刚刚一样的 DOM，不过这些 CSS 约束会被加到 <code>span</code> 选择器上面去，于是渲染出来的样子就不一样了。</p><h2 id="三种使用-css-的方法">三种使用 CSS 的方法</h2><h3 id="外部-stylesheet">外部 stylesheet</h3><p>就是上面例子里用到的方法，CSS 约束是写在一个单独的 <em>.css</em> 文件里的</p><h3 id="内部-stylesheet">内部 stylesheet</h3><p>即直接通过 <code>&lt;style&gt;</code> 标签来定义元素的长相，这个 <code>&lt;style&gt;</code> 需要写在 <code>&lt;head&gt;</code> 标签下才会生效：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>My CSS experiment<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">      h1 &#123;</span><br><span class="line">        color: blue;</span><br><span class="line">        background-color: yellow;</span><br><span class="line">        border: 1px solid black;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      p &#123;</span><br><span class="line">        color: red;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is my first CSS example<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个例子跟之前的例子是同样效果的。</p><h3 id="内联样式">内联样式</h3><p>对于只想改变单独一个标签元素的情况下，可以通过标签的 <code>style</code> 属性实现：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>My CSS experiment<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">"color: blue;background-color: yellow;border: 1px solid black;"</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"color:red;"</span>&gt;</span>This is my first CSS example<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然而这种做法并没有很受待见，因为这样定义的样式没办法复用，你可能需要在好几个文档里面写上同样的几个样式，维护成本大大升高了。</p><p>另一方面，把 HTML 语法跟 CSS 语法混合在一起，看起来就不那么清晰易懂了，建议是把不同类型的代码分开，保持纯粹。</p><h2 id="小结">小结</h2><p>到这里，我们已经不止能写 HTML 网页了，还能通过 CSS 给这简陋的网页披上华丽丽的外衣。在下一篇文章里，我们会继续深入学习 CSS 的句法，距离踏入前端世界的大门又要近一些了！</p><h2 id="参考文章">参考文章</h2><p><a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Introduction_to_CSS/How_CSS_works" target="_blank" rel="noopener">How CSS works - Learn web development | MDN</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSS 全称 Cascading Style Sheets，网页内容（HTML）会被浏览器转换为 DOM（Document Object Model）以供显示，而 CSS 就是作用在 DOM 上以改变它们的样式、布局或行为等。对于前端工程师来说，这是很常见的基本操作了，但是对其他不常敲网页代码的程序员来说，却可能会有些陌生。&lt;/p&gt;
&lt;p&gt;借着最近前端同事事务繁忙的机会，我这客户端工程师赶鸭子上架怼了一个静态网页出来，顺便产下了两篇副产品，都与 CSS 基础相关，这是第一篇，希望能对其他可能有相同需要的同志送上一些帮助。&lt;/p&gt;
    
    </summary>
    
    
      <category term="css" scheme="http://davidleee.com/tags/css/"/>
    
      <category term="html" scheme="http://davidleee.com/tags/html/"/>
    
      <category term="web" scheme="http://davidleee.com/tags/web/"/>
    
      <category term="dom" scheme="http://davidleee.com/tags/dom/"/>
    
  </entry>
  
  <entry>
    <title>关于 macOS 输入框你需要了解的一些基础</title>
    <link href="http://davidleee.com/2018/09/11/the-basic-of-macos-text-view-system/"/>
    <id>http://davidleee.com/2018/09/11/the-basic-of-macos-text-view-system/</id>
    <published>2018-09-11T06:48:40.000Z</published>
    <updated>2020-05-05T03:43:31.445Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是 macOS 开发系列的第三篇文章 —— 文本输入系统基础。</p><p>电脑的文字编辑功能比手机上的强大（难搞）真不是吹！</p></blockquote><a id="more"></a><h2 id="认识输入框">认识输入框</h2><blockquote><p>The Macintosh operating system has provided sophisticated text handling and typesetting capabilities from its beginning. In fact, these features sparked the desktop publishing revolution. —— Apple</p></blockquote><p>在 macOS 的世界里，要显示或者编辑文字主要会用到两个控件，一个是 <a href="https://developer.apple.com/documentation/appkit/nstextview" target="_blank" rel="noopener">NSTextView</a>，另一个是 <a href="https://developer.apple.com/documentation/appkit/nstextfield" target="_blank" rel="noopener">NSTextField</a>。</p><blockquote><p>虽然控件库里面有个叫 Label 的东西，但是拖出来之后就会发现，它其实也是一个  <a href="https://developer.apple.com/documentation/appkit/nstextfield" target="_blank" rel="noopener">NSTextField</a></p></blockquote><p>它们的继承关系是这样的：<br><img src="/uploads/the-basic-of-macos-text-view-system/7004648D-1B33-476E-8788-8D894D8B08E9.png" alt></p><p>NSTextView 是苹果花了大心血打造的一个“满足几乎所有显示和管理文字需求”的一个控件，也是 macOS 引以为傲的文字编辑系统的主心骨；NSTextField 则相当于一个简化版的 NSTextView，在大多数情况下它可以满足字数较少的输入需求。</p><p>正如我们在 iOS 开发里常做的那样，在需要用户输入的地方，通常是直接展示一个 Text 相关的控件，然后通过 delegate 方法来控制输入的内容；又或者继承一个官方的控件，然后在内部直接实现想要的内容控制逻辑。</p><p>在 macOS 上，这个流程也是大致相同的。</p><blockquote><p>以前写过一篇简单介绍 NSTextView 用法的文章（ <a href="/2017/09/11/Windows-in-macOS/" title="20分钟手把手教你写 macOS 文本编辑器">20分钟手把手教你写 macOS 文本编辑器</a>），等不及的童鞋们可以在这篇文章里过过瘾。</p></blockquote><h2 id="文本输入的幕后玩家">文本输入的幕后玩家</h2><p>虽然从使用上来看，跟开发者直接打交道的就是 NSTextView 和 NSTextField 这两个类，最多再加上它们带着的一些协议/代理，但是继续往深了看，会发现有一个未知的世界在支撑这这一切。</p><h3 id="field-editor">Field Editor</h3><p>macOS 上有一个叫 Field Editor 的概念。</p><p>在输入框获得焦点的时候，系统会实例化一个 NSTextView 作为 Field Editor，并把它作为 first responder 插入到这个输入框的事件响应链当中。如此一来，Field Editor 会负责处理所有的用户输入事件，在这个过程中，获得焦点的输入框会作为 Field Editor 的代理，以便对文本的内容进行控制处理。</p><p><img src="/uploads/the-basic-of-macos-text-view-system/field_editor_2x.png" alt></p><blockquote><p>这就是为什么 NSWindow 的 <code>firstResponder</code> 返回的是一个不可见的对象，而不是我们获取了焦点的输入框，因为这个对象就是上面说的 Field Editor。</p></blockquote><p>Field Editor 是同一个窗口里所有输入框共用的，所以在我们用 Tab 键切换输入框的时候，Field Editor 就会切换事件响应的对象。另一方面，这个机制也确保了同一个窗口中只能有一个控件去响应用户输入事件。不过，我们也可以实现自定义的 Field Editor 来推翻上面说的这些功能。</p><blockquote><p>虽然 Field Editor 一般会是一个 NSTextView 的实例，但是它们对 Tab 和 Return 的事件处理是不同的。对于 Field Editor 来说，这两个键盘事件是“结束编辑”的意思。</p></blockquote><h3 id="nstextinputcontext">NSTextInputContext</h3><p>这是外界和文本输入系统之间沟通的桥梁。</p><p>在用户进行输入的时候，<code>keyDown</code> 消息会被传递到获取了焦点的输入框里，输入框接下来会调用 <a href="https://developer.apple.com/documentation/appkit/nstextinputcontext" target="_blank" rel="noopener">NSTextInputContext</a> 的 <code>handleEvent</code> 方法，以便让 NSTextInputContext 告诉自己需要怎么处理这个用户事件。而作为响应，NSTextInputContext 会把处理结果通过 <a href="https://developer.apple.com/documentation/appkit/nstextinputclient" target="_blank" rel="noopener">NSTextInputClient</a> 这个协议告知输入框。</p><p><img src="/uploads/the-basic-of-macos-text-view-system/F200783C-8569-4396-BC36-4DAD92E810DF.png" alt></p><p>从上图可以看到，NSTextInputContext 会跟一个叫 Key-bindings dictionary 的字典保持密切联系。这个字典默认来自于 AppKit 内部的一个文件（<em>/System/Library/Frameworks/AppKit.framework/Resources/StandardKeyBinding.dict</em>），里面保存了系统默认定义好的所有快捷键，只有当用户输入的值在这个字典里找不到匹配的键值对时，这次输入才会作为普通字符回调给输入框，否则 NSTextInputContext 就会在这里把这次输入拦截下来，并让输入框执行相应的特殊操作。</p><blockquote><p>我们可以通过修改 <em>~/Library/KeyBindings/DefaultKeyBinding.dict</em> 里的值来覆盖默认的快捷键</p></blockquote><h2 id="小结">小结</h2><p>到此为止，macOS 文本编辑系统的一些内在机理已经了解地差不多了。在往后使用 NSTextView 和 NSTextField 的过程中，碰到一些不明觉厉的问题也能有个大概的问题排查方向了。（不过也仅限于“大概方向”了）</p><p>好吧，我知道这篇文章偏理论了一些，大多数情况下也不会用到。更多详细的说明可以在文章里提供的各种链接上找到。</p><p>在后续的文章里，还会讲到 NSTextField 实际应用上的一些内容。NSTextView 因为暂时没有用上，所以可能会等有机会研究清楚些再讲咯。</p><h2 id="参考文章">参考文章</h2><p><a href="https://developer.apple.com/library/archive/documentation/TextFonts/Conceptual/CocoaTextArchitecture/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009459-CH1-SW1" target="_blank" rel="noopener">About the Cocoa Text System</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这是 macOS 开发系列的第三篇文章 —— 文本输入系统基础。&lt;/p&gt;
&lt;p&gt;电脑的文字编辑功能比手机上的强大（难搞）真不是吹！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="macOS" scheme="http://davidleee.com/tags/macOS/"/>
    
      <category term="AppKit" scheme="http://davidleee.com/tags/AppKit/"/>
    
      <category term="NSTextField" scheme="http://davidleee.com/tags/NSTextField/"/>
    
      <category term="Cocoa" scheme="http://davidleee.com/tags/Cocoa/"/>
    
      <category term="NSTextView" scheme="http://davidleee.com/tags/NSTextView/"/>
    
      <category term="Text System" scheme="http://davidleee.com/tags/Text-System/"/>
    
      <category term="Field Editor" scheme="http://davidleee.com/tags/Field-Editor/"/>
    
  </entry>
  
  <entry>
    <title>react-navigation-redux-helpers 从 v1 到 v2</title>
    <link href="http://davidleee.com/2018/09/10/upgrade-react-navigation-redux-helpers-to-v2/"/>
    <id>http://davidleee.com/2018/09/10/upgrade-react-navigation-redux-helpers-to-v2/</id>
    <published>2018-09-10T08:40:21.000Z</published>
    <updated>2020-05-05T03:43:31.445Z</updated>
    
    <content type="html"><![CDATA[<p>在使用 <a href="https://reactnavigation.org" target="_blank" rel="noopener">React Navigation</a> 的项目中，想要集成 redux 就必须要引入 <a href="https://github.com/react-navigation/react-navigation-redux-helpers" target="_blank" rel="noopener">react-navigation-redux-helpers</a> 这个库。最近整理第三方库的时候，发现这两个库的版本都比较旧了，在尝试更新的时候踩了一些坑，于是就有了这篇文章。</p><a id="more"></a><h2 id="navigator">Navigator</h2><p>升级之后，配置上唯一的不同在于 v2 版本中干掉了 <code>createReduxBoundAddListener(Key)</code> 方法，取而代之的是 <code>reduxifyNavigator(Navigator, Key)</code>。</p><p>在 v1 版本中，我们需要把前者构造出来的 <code>addListener</code> 作为参数传给 AppNavigator：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  StackNavigator,</span><br><span class="line">  addNavigationHelpers,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'react-navigation'</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  createReduxBoundAddListener</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'react-navigation-redux-helpers'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> AppNavigator = StackNavigator(AppRouteConfigs)</span><br><span class="line"><span class="keyword">const</span> addListener = createReduxBoundAddListener(<span class="string">"root"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;AppNavigator navigation=&#123;addNavigationHelpers(&#123;</span><br><span class="line">        dispatch: <span class="keyword">this</span>.props.dispatch,</span><br><span class="line">        state: <span class="keyword">this</span>.props.nav,</span><br><span class="line">        addListener, <span class="comment">// --&gt; 就是这里</span></span><br><span class="line">      &#125;)&#125; /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在 v2 版本中，使用新方法可以简化上述步骤：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  createStackNavigator, <span class="comment">// new creator of StackNavigator</span></span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'react-navigation'</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  reduxifyNavigator</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'react-navigation-redux-helpers'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> AppNavigator = createStackNavigator(AppRouteConfigs)</span><br><span class="line"><span class="keyword">const</span> App = reduxifyNavigator(AppNavigator, <span class="string">"root"</span>) <span class="comment">// --&gt; 干净清爽！</span></span><br></pre></td></tr></table></figure><h2 id="mapstatetoprops">mapStateToProps</h2><p>原来 <code>state.nav</code> 对应的 <code>props</code> 键叫 “nav”，现在改为 “state” 了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// v1</span></span><br><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state</span>) =&gt;</span> (&#123;</span><br><span class="line">  nav: state.nav</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// v2</span></span><br><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state</span>) =&gt;</span> (&#123;</span><br><span class="line">  state: state.nav, <span class="comment">// nav -&gt; state</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>另外，之前为了处理 Android 返回按钮的问题，可能会自定义一个类包裹着上面构造出来的 AppNavigator，然后通过 react-redux 的 <code>connect</code> 方法把 <code>mapStateToProps</code> 给作用到这个自定义的类上去，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReduxNavigation</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* additional setup for back button handling */</span></span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">/* more setup code here! this is not a runnable snippet */</span>*</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">AppNavigator</span> <span class="attr">navigation</span>=<span class="string">&#123;navigation&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps)(ReduxNavigation)</span><br></pre></td></tr></table></figure><p>经测试发现，在 v2 版本里，这种操作会报 “undefined is not an object(evaluating ‘state.routes’)” 的错误，猜测可能跟 Props 的键值变化有关。把 <code>connect</code> 的调用提前，让它先作用到 AppNavigator 再包裹到自定义类里面即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ConnectedNavigator = connect(mapStateToProps)(AppNavigator)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReduxNavigation</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* additional setup for back button handling */</span></span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">/* more setup code here! this is not a runnable snippet */</span>*</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ConnectedNavigator</span> <span class="attr">navigation</span>=<span class="string">&#123;navigation&#125;/</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ReduxNavigation</span><br></pre></td></tr></table></figure><h2 id="full-example">Full Example</h2><p>对于同一个 Navigator， <code>reduxifyNavigator</code> 如果在 <code>connect</code> 之后调用，会报重复定义<code>navigation</code> 属性的错误。所以加上前面的配置过程，完整的例子应该长这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* importing the whole world */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> AppNavigator = createStackNavigator(AppRouteConfigs)</span><br><span class="line"><span class="comment">// 下面两句顺序不能变</span></span><br><span class="line"><span class="keyword">const</span> App = reduxifyNavigator(AppNavigator, <span class="string">"root"</span>)</span><br><span class="line"><span class="keyword">const</span> ConnectedNavigator = connect(mapStateToProps)(App)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReduxNavigation</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* additional setup for back button handling */</span></span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">/* more setup code here! this is not a runnable snippet */</span>*</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ConnectedNavigator</span>/&gt;</span></span> <span class="comment">// 不需要 `navigation` 参数了</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ReduxNavigation</span><br></pre></td></tr></table></figure><h2 id="参考文章">参考文章</h2><p><a href="https://reactnavigation.org/docs/en/redux-integration.html" target="_blank" rel="noopener">Redux integration · React Navigation</a><br><a href="https://v1.reactnavigation.org/docs/redux-integration.html" target="_blank" rel="noopener">Redux integration · React Navigation (v1)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用 &lt;a href=&quot;https://reactnavigation.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;React Navigation&lt;/a&gt; 的项目中，想要集成 redux 就必须要引入 &lt;a href=&quot;https://github.com/react-navigation/react-navigation-redux-helpers&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;react-navigation-redux-helpers&lt;/a&gt; 这个库。最近整理第三方库的时候，发现这两个库的版本都比较旧了，在尝试更新的时候踩了一些坑，于是就有了这篇文章。&lt;/p&gt;
    
    </summary>
    
    
      <category term="react-native" scheme="http://davidleee.com/tags/react-native/"/>
    
      <category term="react-navigation" scheme="http://davidleee.com/tags/react-navigation/"/>
    
      <category term="redux" scheme="http://davidleee.com/tags/redux/"/>
    
      <category term="react-navigation-redux-helpers" scheme="http://davidleee.com/tags/react-navigation-redux-helpers/"/>
    
  </entry>
  
  <entry>
    <title>让人眼花缭乱的 macOS 菜单</title>
    <link href="http://davidleee.com/2018/08/22/how-menus-work/"/>
    <id>http://davidleee.com/2018/08/22/how-menus-work/</id>
    <published>2018-08-22T09:44:37.000Z</published>
    <updated>2020-05-05T03:43:31.443Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是 macOS 开发系列的第二篇文章——让人眼花缭乱的 macOS 菜单。</p><p>这有什么好说的，你不要骗我！手机上的菜单都是我用自定义视图撸出来的！</p></blockquote><a id="more"></a><h2 id="菜单的类型">菜单的类型</h2><p>在 macOS 开发中，所谓“菜单”并不只是一个自定义视图了（虽然自定义视图也可以实现），在 AppKit 里面名字直接叫“菜单”的类就占了两席之地，分别是 <a href="https://developer.apple.com/documentation/appkit/nsmenu" target="_blank" rel="noopener">NSMenu</a> 和 <a href="https://developer.apple.com/documentation/appkit/nsmenuitem" target="_blank" rel="noopener">NSMenuItem</a>。</p><p>在实际应用中，菜单对应了 5 种表现形式：</p><ul><li><p>应用的菜单栏，在屏幕的最上方<br><img src="/uploads/how-menus-work/D54DBE49-05EB-4638-AEC3-FA37D500ECC7.png" alt></p></li><li><p>弹出菜单，可以出现在当前窗口中的任何地方<br><img src="/uploads/how-menus-work/3D50179E-F77C-4A53-85E5-9296B53895D7.png" alt></p></li><li><p>状态栏，从屏幕上方的菜单栏右边开始向左延伸<br><img src="/uploads/how-menus-work/WX20180821-170602@2x.png" alt></p></li><li><p>“上下文菜单”（Contextual Menus），点击右键或 “control + 左键” 触发<br><img src="/uploads/how-menus-work/56863C68-CAB1-4BCE-B0DD-82C7E4C03F5F.png" alt></p></li><li><p>Dock 菜单，对程序坞（Dock）的应用图片点击右键或 “control + 左键” 触发<br><img src="/uploads/how-menus-work/4948EFFA-1E19-4922-AB52-5FD4518F4268.png" alt></p></li></ul><p>看着挺多，但是用起来倒是挺简单方便的。下面就把这几个新玩具都拉出来溜一溜～</p><h2 id="应用菜单栏-application-menu">应用菜单栏（Application Menu）</h2><p>这个菜单栏在上一篇文章（<a href="/2018/08/21/storyboard-in-macos/" title="不一样的 macOS Storyboard">不一样的 macOS Storyboard</a>）里已经纠结过了。</p><p>概括一下：每个应用初始化的时候就自带了一个应用菜单栏，如果是使用 Storyboard 开发的项目，在 “Main.storyboard” 里面就可以直接对这个菜单栏进行各种各样功能上的调整了（也就限于逻辑，样子大概是改不动了，只能用系统控件…）</p><h2 id="弹出菜单-pop-up-menu">弹出菜单（Pop-up Menu）</h2><p>这种菜单的含义比较宽泛，所有在当前窗口里面出现的、带有“弹出”感觉的菜单都可以属于这一类。从视觉上大致可以分成两种：对话框型 &amp; 按钮型。</p><h3 id="对话框型">对话框型</h3><p>这中文名是我自己取的…因为它长得像呀！它就是上面类型介绍里的图片所示的样子，对应的类是 <a href="https://developer.apple.com/documentation/appkit/nspopover" target="_blank" rel="noopener">NSPopover</a>。</p><p>这玩意儿在 iOS 9 和更老的版本中有类似的用法叫 <a href="https://developer.apple.com/documentation/uikit/uipopovercontroller" target="_blank" rel="noopener">UIPopoverController</a>，在 iOS 9 之后就变成了 UIViewController 的一种展现方式了，具体参见 <a href="https://developer.apple.com/documentation/uikit/uipopoverpresentationcontroller" target="_blank" rel="noopener">UIPopoverPresentationController</a>。</p><p>NSPopover 用起来跟上面说的几个类也是差不多的，只是它本身不是一个 ViewController，所以在展示之前需要先设置 <code>contentViewController</code> 以负责界面的显示。</p><p>更多风骚的用法还是参考官方文档为好 -  <a href="https://developer.apple.com/documentation/appkit/nspopover" target="_blank" rel="noopener">NSPopover</a>。</p><h3 id="按钮型">按钮型</h3><p>顾名思义，这是个看起来很像按钮的菜单，打开系统偏好设置 -&gt; 通用，就能见到大把的按钮型弹出菜单，它们对应的类是 <a href="https://developer.apple.com/documentation/appkit/nspopupbutton" target="_blank" rel="noopener">NSPopUpButton</a>。</p><p>在 xib 或者 storyboard 里面拖一个出来，能看到它跟普通按钮相比多出了这么一些独有的配置：<br><img src="/uploads/how-menus-work/A7088EFE-96C5-4124-BA69-05E917716EB1.png" alt></p><p>其中 “Type” 部分有两个可选值：Pop up &amp; Pull Down，它们最直观的区别在于按钮后面跟着的蓝色部分，前者是上下箭头，后者则只有一个向下的箭头：<br><img src="/uploads/how-menus-work/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%884.40.57.png" alt></p><p>当然，它们在列表展开方式和使用场景上也是不一样的，想要追究其中细节的童鞋们，推荐一篇官方文档：<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MenuList/Articles/ManagingPopUpItems.html#//apple_ref/doc/uid/20000274-BAJDEEJA" target="_blank" rel="noopener">Managing Pop-Up Buttons and Pull-Down Lists</a></p><h2 id="状态栏-status-bar">状态栏（Status Bar）</h2><p>作为一个中规中矩的菜单，状态栏菜单也是由两个部件组成的：<a href="https://developer.apple.com/documentation/appkit/nsstatusbar" target="_blank" rel="noopener">NSStatusBar</a> &amp; <a href="https://developer.apple.com/documentation/appkit/nsstatusitem" target="_blank" rel="noopener">NSStatusItem</a>，从名字就能看出它们的关系了，具体用法也是看文档咯。</p><blockquote><p>额外推荐一篇很详细的文章：<a href="https://www.raywenderlich.com/450-menus-and-popovers-in-menu-bar-apps-for-macos" target="_blank" rel="noopener">Menus and Popovers in Menu Bar Apps for macOS | Ray Wenderlich</a></p></blockquote><p>根据官方的说法，状态栏的位置稀缺，不保证你应用的菜单在上面一直是可用的，所以建议把它放在最后考虑（是的，甚至在 Dock Menu 之后）。做事比较克制的微信只把它用来显示未读消息条数，点击回调也只是打开微信主窗口而已。</p><p>而且苹果还建议我们提供一个隐藏的选项，在必要时给用户隐藏掉我们状态栏图标的机会。</p><p>Emmm….虽然苹果的话我们也不一定听就是了…</p><h2 id="上下文菜单-contextual-menus">“上下文菜单”（Contextual Menus）</h2><p>也就是俗称的右键菜单？</p><blockquote><p>macOS 上还可以用 control + 左键触发</p></blockquote><p>它跟应用菜单栏一样，是通过最常见的菜单样式来展现的，对应的类是： <a href="https://developer.apple.com/documentation/appkit/nsmenu" target="_blank" rel="noopener">NSMenu</a> &amp; <a href="https://developer.apple.com/documentation/appkit/nsmenuitem" target="_blank" rel="noopener">NSMenuItem</a>。</p><p>唯一不同的是，它不是通过点击一个什么按钮去触发的，而是通过重载 NSView 的 <code>defaultMenu</code> 属性来实现的，我们只需要定义好菜单的样子和内部逻辑，打开/收起菜单这样的琐事就交给系统去做好了。</p><p>在 xib 或 storyboard 里，把菜单链接到其他视图的 Outlets -&gt; menu 上面，同样能实现右键触发的效果：<br><img src="/uploads/how-menus-work/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-22%20%E4%B8%8B%E5%8D%885.16.55.png" alt></p><p>话说上图这个界面本身也是一个 Contextual Menu 呢。</p><h2 id="dock-菜单-dock-menu">Dock 菜单（Dock Menu）</h2><p>阿哈！这也是个普普通通的 Menu，通过实现 <a href="https://developer.apple.com/documentation/appkit/nsdocktileplugin" target="_blank" rel="noopener">NSDockTilePlugIn</a> 这个协议里的 <code>dockMenu()</code> 方法就可以返回一个我们自定义的菜单啦。</p><p>我们还可以通过它来自定我们的应用图标在 Dock 上面的样子，比如加个角标或者改一下图标颜色什么的，不过在这样做之前，我们还需要看看这个类 <a href="https://developer.apple.com/documentation/appkit/nsdocktile" target="_blank" rel="noopener">NSDockTile</a>。这就超纲了啊，不说了不说了。</p><h2 id="总结">总结</h2><p>虽说自定义视图和显隐逻辑也可以实现菜单的功能，但是 AppKit 已经为我们封装了好几个类，让我们可以方便快捷地怼出一个功能丰富的应用了，它们是：</p><ul><li><a href="https://developer.apple.com/documentation/appkit/nsmenu" target="_blank" rel="noopener">NSMenu</a> &amp; <a href="https://developer.apple.com/documentation/appkit/nsmenuitem" target="_blank" rel="noopener">NSMenuItem</a></li><li><a href="https://developer.apple.com/documentation/appkit/nspopover" target="_blank" rel="noopener">NSPopover</a> &amp; <a href="https://developer.apple.com/documentation/appkit/nspopupbutton" target="_blank" rel="noopener">NSPopUpButton</a></li><li><a href="https://developer.apple.com/documentation/appkit/nsstatusbar" target="_blank" rel="noopener">NSStatusBar</a> &amp; <a href="https://developer.apple.com/documentation/appkit/nsstatusitem" target="_blank" rel="noopener">NSStatusItem</a></li><li><a href="https://developer.apple.com/documentation/appkit/nsdocktile" target="_blank" rel="noopener">NSDockTile</a> &amp; <a href="https://developer.apple.com/documentation/appkit/nsdocktileplugin" target="_blank" rel="noopener">NSDockTilePlugIn</a></li></ul><p>除了一些特殊的应用之外，我们的主要功能应该是在窗口里面提供的，而菜单通常都是些锦上添花的东西。不过在有余力的时候，为我们的用户增添一分“意外之喜”也是极好的吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这是 macOS 开发系列的第二篇文章——让人眼花缭乱的 macOS 菜单。&lt;/p&gt;
&lt;p&gt;这有什么好说的，你不要骗我！手机上的菜单都是我用自定义视图撸出来的！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://davidleee.com/tags/Swift/"/>
    
      <category term="macOS" scheme="http://davidleee.com/tags/macOS/"/>
    
      <category term="AppKit" scheme="http://davidleee.com/tags/AppKit/"/>
    
      <category term="NSMenus" scheme="http://davidleee.com/tags/NSMenus/"/>
    
      <category term="NSPopover" scheme="http://davidleee.com/tags/NSPopover/"/>
    
      <category term="NSPopupButton" scheme="http://davidleee.com/tags/NSPopupButton/"/>
    
      <category term="Dock" scheme="http://davidleee.com/tags/Dock/"/>
    
      <category term="NSDockTile" scheme="http://davidleee.com/tags/NSDockTile/"/>
    
      <category term="NSStatusBar" scheme="http://davidleee.com/tags/NSStatusBar/"/>
    
  </entry>
  
  <entry>
    <title>不一样的 macOS Storyboard</title>
    <link href="http://davidleee.com/2018/08/21/storyboard-in-macos/"/>
    <id>http://davidleee.com/2018/08/21/storyboard-in-macos/</id>
    <published>2018-08-21T01:12:40.000Z</published>
    <updated>2020-05-05T03:43:31.444Z</updated>
    
    <content type="html"><![CDATA[<p>从 iOS 转来 macOS 阵营已经有几个月了，断断续续踩了一些这样那样的坑，特此写一个系列记录下来。这个系列碰到的问题都是已经找到了解决方法的，希望对其他人也能有些帮助。</p><blockquote><p>这是 macOS 开发系列的第一篇文章。</p><p>从项目开始的地方讲起 —— Storyboard。</p></blockquote><a id="more"></a><h2 id="main-storyboard">Main.Storyboard</h2><p>新建 macOS 项目的时候，如果勾上了 “Use Storyboards” 的话，工程里会自带了一个 “Main.storyboard”。</p><p>打开看看，发现跟 iOS 项目中的样子大同小异，不同的地方在于，原来的 “Navigation Controller” 在这里变成了 “Window Controller”，而且上面还多了一个没见过的 “Main Menu”。（关于菜单的内容会在第三篇文章里讲到）</p><p><img src="/uploads/storyboard-in-macos/4BB6559C-64F4-421D-A8D5-6427C96EF774.png" alt></p><p>如果把应用跑起来，会发现 “Window Controller” 对应的是应用的启动窗口，而 “Main Menu” 对应的是显示在顶部的系统菜单栏。</p><p><img src="/uploads/storyboard-in-macos/6D230E15-056A-495D-8063-96FA6F4E9792.png" alt></p><p>到目前为止，一切都还是合乎逻辑的，直到某天我手贱把 Main.storyboard 删掉了…</p><h2 id="自定义-storyboard">自定义 Storyboard</h2><p>按照我们在 iOS 里学来的经验，这没什么大不了的嘛！</p><p>让我们重新创建一个 Storyboard<br><img src="/uploads/storyboard-in-macos/AAA78593-47E1-4E34-A6FE-34D08C3D5328.png" alt></p><p>拖一个 “Window Controller” 出来，程序入口也要设置上（就是图片中间那个小箭头，位置在 Window Controller -&gt; Attributes Inspector -&gt; “Is Initial Controller”）<br><img src="/uploads/storyboard-in-macos/7BCBD120-A01E-48A9-9146-9A07CD956C81.png" alt></p><p>然后到项目配置里设置一下<br><img src="/uploads/storyboard-in-macos/35E29846-E2B3-4A94-A221-C9CB866FFC42.png" alt></p><p>Done！好像忘了点什么…不过先跑起来看看！<br><img src="/uploads/storyboard-in-macos/7AC50D3E-EF1B-43AE-80CE-0D12D5520CFE.png" alt></p><p>Emmm….菜单栏你怎么了！我的菜单栏呢！</p><h2 id="拯救被误删的-main-storyboard">拯救被误删的 Main.storyboard</h2><p>回到新建的 ”Main.storyboard“ 里瞅瞅，发现跟自带的 Storyboard 相比，少了 “Main Menu“ 这个玩意儿，相应的，在左边的场景列表里，应该要有一个叫 “Application Scene” 的场景。</p><p><img src="/uploads/storyboard-in-macos/BCD3A74F-812C-47F1-992C-E8BA3E1B5EE1.png" alt></p><p>翻遍了控件库，都没有找到任何与 “Application” 和 “Main Menu” 相关的东西，最后在一个 StackOverflow 的问题里找到了答案</p><blockquote><p><a href="https://stackoverflow.com/questions/24418936/create-application-scene-in-blank-os-x-storyboard" target="_blank" rel="noopener">macos - Create Application Scene in blank OS X Storyboard - Stack Overflow</a></p></blockquote><p>简单总结一下就是：即使时隔多年，macOS 上还是不怎么支持让一个不是基于 Storyboard 开发的应用升级到使用 Storyboard 的版本，所以控件库里压根就没有提供 Application Scene。</p><p>难道就没有办法了？</p><p>虽然没有试过在非 Storyboard 项目上集成 Storyboard，但是对于误删的情况还是有救的：（答案也来自于上面的链接里）</p><ol><li>创建一个新的、带 Storyboard 的项目</li><li>查看新项目里的 Main.storyboard 的源码</li><li>将下图 <code>&lt;!--Application--&gt;</code> 注释下面的 <code>&lt;Scene&gt;...&lt;/Scene&gt;</code> 的全部内容都拷贝到我们刚刚新创建的 Storyboard 里面<br><img src="/uploads/storyboard-in-macos/35685F05-E093-4A08-93B4-80332BE704B0.png" alt></li></ol><p>保存后重新打开 Storyboard，你会发现世界又恢复到原本的样子了！我们的菜单栏终于又回来了！</p><p>当然，因为是复制粘贴过来的，菜单栏里的一些信息还是新项目里的样子，在 Storyboard 稍加修改就可以了。</p><h2 id="总结">总结</h2><p>虽说长得差不多，但 macOS 开发里用到的 Storyboard 和 iOS 上的还是有不少的出入。</p><p>比如有时候 IB 里修改了文案，但是跑起来却不一样了，那可能是 Storyboard 生成了国际化配置文件，在里面搜索一下也许会找到元凶：<br><img src="/uploads/storyboard-in-macos/E490581B-53D5-4537-97B2-FC377985545E.png" alt></p><p>而更多的时候，在 IB 里调整了颜色之类的配置是不能直接看到效果的，还是要跑起来验证一下，以实际运行效果为准。</p><p>总而言之，在 macOS 开发过程中使用 Storyboard 需要更多的耐心和实际运行验证，这样的情况也许要到 macOS 支持 UIKit 的时候才能改善了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从 iOS 转来 macOS 阵营已经有几个月了，断断续续踩了一些这样那样的坑，特此写一个系列记录下来。这个系列碰到的问题都是已经找到了解决方法的，希望对其他人也能有些帮助。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这是 macOS 开发系列的第一篇文章。&lt;/p&gt;
&lt;p&gt;从项目开始的地方讲起 —— Storyboard。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://davidleee.com/tags/Swift/"/>
    
      <category term="macOS" scheme="http://davidleee.com/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>小心避开 RxSwift 里的坑（Top Mistakes in RxSwift you want to avoid）</title>
    <link href="http://davidleee.com/2018/04/24/Top-Mistakes-in-RxSwift/"/>
    <id>http://davidleee.com/2018/04/24/Top-Mistakes-in-RxSwift/</id>
    <published>2018-04-24T00:56:05.000Z</published>
    <updated>2020-05-05T03:43:31.442Z</updated>
    
    <content type="html"><![CDATA[<p>每当我们要学习一样新的语言或者框架时，总是会犯下这样那样的错误。这就是人类学习新知识的方法。下文列出了一些使用 RxSwift 过程中常见的错误，供大家参考。</p><a id="more"></a><p>原文链接在文末。</p><h2 id="combinelatest-vs-withlatestfrom">combineLatest vs withLatestFrom</h2><p>前者会在内部的任意一个 Observable 发出消息时发出一个总的消息，所以把两个按钮的 tap 事件 combineLatest 不是一个合理的做法。这种情况就要看看后者的使用方式了。</p><h2 id="observable-应该延迟初始化">Observable 应该延迟初始化</h2><p>当一个 Observable 是为了把耗时操作的结果通知出去时，这个 Observable 本身应该被延迟初始化，这样才能避免在有人 subscribe 之前就在做那个耗时操作。<br>举个栗子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rx_myFunction</span><span class="params">()</span></span> -&gt; <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> someCalculationResult: <span class="type">Int</span> = calculate()</span><br><span class="line">    <span class="keyword">return</span> .just(someCalculationResult)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>calculte()</code> 是一个耗时操作，这样用户在调用这个方法的时候就已经在跑真正的计算了，而我们写这个方法的本意应该是有人 subscribe 的时候才去执行操作。所以上面的方法应该做一下这样的小修改：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rx_myFunction</span><span class="params">()</span></span> -&gt; <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Observable</span>.deferred &#123;</span><br><span class="line">        <span class="keyword">let</span> someCalculationResult: <span class="type">Int</span> = <span class="keyword">self</span>.calculate()</span><br><span class="line">        <span class="keyword">return</span> .just(someCalculationResult)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="disposebag-的错误使用">DisposeBag 的错误使用</h2><p>这玩意儿的作用是把一堆 <code>Disposable</code> 在某个对象 <code>deinit</code> 的时候全部结束掉，所以这个管理对象的选择就尤为重要。</p><p>比如我们在 tableViewCell 里面进行了一些订阅，该用的 DisposeBag 是 cell 本身声明的一个属性，而不应该直接用 VC 里面的那个，因为 cell 会发生重用，所以这里的 Disposable 的管理应该更积极一点：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">dataSource.configureCell = &#123; <span class="number">_</span>, tableView, indexPath, cellViewModel <span class="keyword">in</span></span><br><span class="line"><span class="keyword">let</span> cell: <span class="type">TheCell</span> = tableView.dequeueCell(at: indexPath)</span><br><span class="line">cellViewModel.image</span><br><span class="line">.drive(cell.avatarView.image)</span><br><span class="line">.disposed(by: cell.disposeBag)</span><br><span class="line"><span class="keyword">return</span> cell</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//somewhere in TheCell.swift file</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TheCell</span>: <span class="title">UITableViewCell</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">prepareForReuse</span><span class="params">()</span></span> &#123;</span><br><span class="line">disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="没有在-ui-层使用-drivers">没有在 UI 层使用 drivers</h2><p>Driver 的设计是为了避免线程的混乱，对于 Driver 的订阅的通知都会发生在主线程上，所以可以降低线程问题的概率。具体要看看这个东西的详细用法。</p><h2 id="异常处理">异常处理</h2><p>当 Observable 抛出异常的时候，它会终止整个流程。如果使用了 <code>flatMap</code> 这类转换方法，那抛出异常的时候被终止的是源头的主流程。</p><p>也就是说，如果把一个可能抛出异常的流程绑定到了按钮的点击事件上，一旦这个流程抛出了异常，按钮的点击事件就再也不会响应了。</p><p>解决方法是使用 <code>Observable&lt;Result&lt;User&gt;&gt;</code> 或者 <code>materialize()</code> 之类的方法。</p><h2 id="同一个-observable-订阅多次">同一个 Observable 订阅多次</h2><p>Observable 是不可变的类。每一个处理方法都是返回一个新的 Observable 而不会对原来的那个做任何变动。</p><p>在需要共享某些流程的结果时，可能会对某个 Observable 进行分别处理和订阅，这时候就应该用 <code>share</code> 或者 <code>shareReplay(1)</code> 来避免事件的重复发出：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> items: <span class="type">Observable</span>&lt;[<span class="type">Item</span>]&gt; = itemsProvider.items</span><br><span class="line">.share()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">let</span> <span class="built_in">count</span>: <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt; = items</span><br><span class="line">.<span class="built_in">map</span> &#123; $<span class="number">0</span>.<span class="built_in">count</span> &#125;</span><br><span class="line">    </span><br><span class="line">items.subscribe(onNext: &#123; items <span class="keyword">in</span> </span><br><span class="line"><span class="comment">//do something with items</span></span><br><span class="line">&#125;) </span><br><span class="line">    </span><br><span class="line">numberOfItems.subscribe(onNext: &#123; <span class="built_in">count</span> <span class="keyword">in</span> </span><br><span class="line"><span class="comment">//do something with count</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>如果不加 <code>share()</code>，下面的两次 <code>subscribe</code> 就会触发两次 <code>itemProvider.items</code> 的 <code>get</code> 方法，但是显然我们只需要获取一次就可以满足下面两个订阅了</p></blockquote><h2 id="过度使用-subjects-variables">过度使用 subjects &amp; variables</h2><p>Rx 的世界应该是由“不可变变量”组成的，一旦一个事件已经形成，那么我们不应该对它本身做出任何改动，而是操作事件的流向最终得到我们想要的结果。</p><p>而 Subjects &amp; Variables 正是 Rx 世界里的“可变变量”。</p><p>不是说不能用它们，而是说我们在大多数时候并不需要用上它们。在更多情况下，我们可以用 <code>merge</code> 、<code>concat</code>、<code>publish</code>&amp;<code>refCount</code> 、<code>defer</code> 和其他一些方法去替代这两个玩意儿。</p><ul><li>原文链接：<a href="http://adamborek.com/top-7-rxswift-mistakes/" target="_blank" rel="noopener">Top mistakes in RxSwift you want to avoid - Code in a suit</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每当我们要学习一样新的语言或者框架时，总是会犯下这样那样的错误。这就是人类学习新知识的方法。下文列出了一些使用 RxSwift 过程中常见的错误，供大家参考。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://davidleee.com/tags/Swift/"/>
    
      <category term="Reactive" scheme="http://davidleee.com/tags/Reactive/"/>
    
      <category term="RxSwift" scheme="http://davidleee.com/tags/RxSwift/"/>
    
  </entry>
  
  <entry>
    <title>【译】符号化iOS崩溃报告</title>
    <link href="http://davidleee.com/2018/03/08/Symbolicating-Your-iOS-Crash-Reports/"/>
    <id>http://davidleee.com/2018/03/08/Symbolicating-Your-iOS-Crash-Reports/</id>
    <published>2018-03-08T07:09:39.000Z</published>
    <updated>2020-05-05T03:43:31.442Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接：<a href="https://possiblemobile.com/2015/03/symbolicating-your-ios-crash-reports/" target="_blank" rel="noopener">Symbolicating Your iOS Crash Reports</a></p></blockquote><p>你拿到一份 App 的崩溃报告，结果发现里面全是难以理解的内存地址。作为一名合格的开发，应该做些什么呢？简单来说，你需要把调试符号应用到崩溃日志上，让它变得更可读，这个过程叫做符号化（Symbolication）。</p><a id="more"></a><p>崩溃报告通常是一个 <code>.crash</code> 格式的文件。要拿到这个玩意儿有这几种方式：</p><ol><li>从 iTunes Connect 上获取</li><li>通过 Xcode 从连接的设备上直接获取（Windows -&gt; Devices）</li><li>直接从连接设备上获取（ iOS 11 上的位置是：设置 -&gt; 隐私 -&gt; 分析）</li><li>通过第三方的框架去获取</li></ol><p>如果你已经在用第三方的崩溃收集服务的话，崩溃日志应该已经是符号化之后的可读格式了。</p><p>然后我们还需要拿到下面两个文件之一，来帮我们定位问题：</p><ol><li>崩溃应用的 <code>.app</code> 文件。这个包里面存有应用的二进制文件，可能还直接保存了调试符号（如果你手上的是 <code>.ipa</code> 文件，你可以直接把它当成一个压缩包去解压，里面会找到 <code>.app</code> 文件的）</li><li>编译崩溃应用时生成的 <code>.dSYM</code> 文件。如果你编译应用的时候，没有指定把调试符号添加到 <code>.app</code> 文件里，那它们就会把这些符号单独放到这个 <code>.dSYM</code> 文件里</li></ol><p>到底要拿哪一个呢？到 Xcode 项目里的 Build Setting 里面找一个叫 “Strip Debug Symbols During Copy”（<code>COPY_PHASE_STRIP</code>） 的字段，如果它是 <code>YES</code> 的话，调试符号就会从 <code>.app</code> 文件里剔除，并放到 <code>.dSYM</code> 文件里面。</p><blockquote><p>默认情况下，出于代码混淆的考虑，打包 release 版本的时候调试信息会被放到 <code>.dSYM</code> 文件里。</p></blockquote><h2 id="等等-调试符号是什么鬼？">等等，调试符号是什么鬼？</h2><p>从程序员的角度看，调试符号就相当于我们给方法起的那个可读性高的名字。为了提高代码的混淆度，编译器会在编译过程中把我们的调试符号替换成它自己的。而且编译器每一次编译都可能会改变它自己的符号，即使我们的代码完全没有变化。</p><h2 id="开始调试崩溃">开始调试崩溃</h2><p>如果你是从 Xcode 的 Organizer 里拿到的崩溃日志，那它里面与 iOS 框架（UIKit 等）相关的部分可能已经被符号化了，而且如果 Xcode 还记得这一次编译的话，整个崩溃日志的符号化过程也可以省掉了。</p><p>那在没那么好运的情况下呢？</p><h3 id="symbolicatecrash-工具">Symbolicatecrash 工具</h3><p>最简单的方式就是使用苹果官方提供的 Symbolicatecrash 工具了，本质上它就是一个脚本，可以帮我们拿到调试符号并应用到指定的崩溃日志上。</p><p>在 Xcode 7.3 之后，这个工具在这个位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Applications/Xcode.app/Contents/SharedFrameworks/DVTFoundation.framework/Versions/A/Resources/symbolicatecrash</span><br></pre></td></tr></table></figure><p>在 Xcode 6 到 7.2 的版本下，它在这里：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Applications/Xcode.app/Contents/SharedFrameworks/DTDeviceKitBase.framework/Versions/Current/Resources/symbolicatecrash</span><br></pre></td></tr></table></figure><p>如果是更早的版本，可以到这里碰碰运气：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/PrivateFrameworks/DTDeviceKitBase.framework/Versions/Current/Resources/symbolicatecrash</span><br></pre></td></tr></table></figure><p>用这个工具之前，要先配置一个环境变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export DEVELOPER_DIR=”/Applications/Xcode.app/Contents/Developer”</span><br></pre></td></tr></table></figure><p>然后把 <code>.crash</code>、<code>.app</code> 和 <code>.dSYM</code> 文件都放到同一个目录下，并执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">symbolicatecrash &lt;#YourAppName&gt;.crash &gt; Symbolicated.crash</span><br><span class="line"></span><br><span class="line">// 如果需要明确指定应用二进制文件的话...</span><br><span class="line">// symbolicatecrash &lt;#YourAppName&gt;.crash ./&lt;#YourAppName&gt;.app/&lt;#YourAppName&gt; &gt; Symbolicated.crash</span><br></pre></td></tr></table></figure><h3 id="验证文件是否正确">验证文件是否正确</h3><p>如果符号化的过程碰到了问题，可以加上 <code>-v</code> 参数让 Symbolicatecrash 告诉我们更多信息。大多数情况下是因为 <code>.dSYM</code> 文件或者 <code>.app</code> 文件拿错了，可以用下面的指令来验证一下 UUID 是否正确：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// App 文件</span><br><span class="line">dwarfdump -u &lt;#YourAppName&gt;.app/&lt;#YourAppName&gt;</span><br><span class="line"></span><br><span class="line">// dSYM 文件</span><br><span class="line">dwarfdump -u &lt;#YourAppName&gt;.app.dSYM/Contents/Resources/DWARF/&lt;#YourAppName&gt;</span><br></pre></td></tr></table></figure><p>对比看看两次输出的 UUID 是不是一致的，然后看看崩溃日志里的 UUID 是不是输出的这一个。</p><h3 id="定位-symbolicatecrash-的问题">定位 Symbolicatecrash 的问题</h3><p>经过上面的步骤之后，如果还是没法输出有效的信息，那就要仔细看看符号化之后的日志了。官方符号化的工具会尝试寻找与崩溃 App 的 UUID 相匹配的文件和动态库，如果符号化失败的话，从输出的日志里确认它寻找的 App 名称和 UUID 是不是你要的。一般来说，会有这样的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">......fetching symbol file for Crasher[K–[undef] Searching []…– NO MATCH Searching in Spotlight for dsym with UUID of b00cdf0c29653095b1e86078b12d79e5 ... Number of symbols in /Users/You/Workspace/Crasher.app/Crasher: 1 + 106 = 107 Found executable /Users/You/Workspace/Crasher.app/Crasher — MATCH</span><br></pre></td></tr></table></figure><p>如果 Spotlight 找不到 <code>.dSYM</code> 文件，输出是这样子的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Did not find executable for dsym Warning: Can’t find any unstripped binary that matches version of /private/var/mobile/Containers/Bundle/Application/956755E3-6C66-4E87-A8BC-352FD4BE3711/Crasher.app/Crasher</span><br></pre></td></tr></table></figure><p>如果 <code>.dSYM</code> 文件有问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Number of symbols in ./Crasher: + = 0 ./Crasher appears to be stripped, skipping.</span><br></pre></td></tr></table></figure><p>非法输入的情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/lipo: can’t figure out the architecture type of: ./Crasher.app.dSYM.zip ./Crasher.app.dSYM.zip doesn’t contain armv7 slice</span><br></pre></td></tr></table></figure><p>Xcode 6 上的 <code>symbolicatecrash</code> 会尝试修复 Xcode 5 上没办法解决的 Spotlight 问题，如果你的 <code>symbolicatecrash</code> 版本比较旧，可以尝试手动修复一下 Spotlight 的索引问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdimport -g /Applications/Xcode.app/Contents/Library/Spotlight/uuid.mdimporter</span><br></pre></td></tr></table></figure><h3 id="命令行工具链">命令行工具链</h3><p>让我们再深入一步，使用命令行工具去一行行符号化堆栈信息。</p><p>先看一行崩溃日志里的堆栈信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">... 13 Crasher 0x000aeef6 0xa8000 + 28406 ...</span><br></pre></td></tr></table></figure><p>第一段十六进制数（<code>0x000aeef6</code>）是栈地址。第二段十六进制数（<code>0xa8000</code>）是程序加载地址。接下来的运算操作（<code>+ 28406</code>）是一个十进制的加法操作，这三个信息表示了一个等式：0x000aeef6 = 0xa8000 + 0x6EF6（== 28406）。</p><p>顺着崩溃日志往下看，会发现 “Binary Images” 这个字段的内容里包含了我们的程序加载地址，它代表了崩溃应用里加载了的一系列动态库占用的内存地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Binary Images: 0xa8000 – 0xaffff Crasher armv7 /var/mobile/Containers/Bundle/Application/956755E3-6C66-4E87-A8BC-352FD4BE3711/Crasher.app/Crasher</span><br></pre></td></tr></table></figure><p>接下来，我们还需要看看崩溃应用的可执行文件的编译架构，可以用 <code>file</code> 或 <code>lipo -info</code> 命令查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file Crasher.app/Crasher</span><br></pre></td></tr></table></figure><p>输出会是这个样子的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Crasher.app/Crasher: Mach-O universal binary with 2 architectures Crasher.app/Crasher (for architecture armv7): Mach-O executable arm Crasher.app/Crasher (for architecture arm64): Mach-O 64-bit executable</span><br></pre></td></tr></table></figure><p>现在我们知道所有需要的信息了。使用 <code>atos</code> 指令，可以把地址信息转化为调试符号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atos -arch armv7 -o Crasher.app/Crasher -l 0xa8000 0x000aeef6</span><br></pre></td></tr></table></figure><p>这里我们需要知道的参数是：应用的编译架构、应用位置、加载地址和栈地址。</p><p>输出会是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main (in Crasher) (main.m:14)</span><br></pre></td></tr></table></figure><p>完成！如果你还有兴趣继续深入，可以了解一下 Mach-O 对象文件的格式，并尝试使用以下 Mach-O 相关的命令行工具，比如 <code>otool</code> 和 <code>lipo</code>。</p><h2 id="延伸阅读">延伸阅读</h2><ul><li><a href="https://developer.apple.com/library/ios/technotes/tn2151/_index.html#//apple_ref/doc/uid/DTS40008184" target="_blank" rel="noopener">Technical Note TN2151: Understanding and Analyzing iOS Application Crash Reports</a></li><li><a href="https://developer.apple.com/library/ios/qa/qa1765/_index.html#//apple_ref/doc/uid/DTS40012196" target="_blank" rel="noopener">Technical Q&amp;A QA1765: How to Match a Crash Report to a Build</a></li><li><a href="https://developer.apple.com/library/mac/documentation/DeveloperTools/Conceptual/MachOTopics/0-Introduction/introduction.html" target="_blank" rel="noopener">Mach-O Programming Topics</a></li><li><a href="http://www.objc.io/issue-6/mach-o-executables.html" target="_blank" rel="noopener">Objc.io on Mach-O Executables</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://possiblemobile.com/2015/03/symbolicating-your-ios-crash-reports/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Symbolicating Your iOS Crash Reports&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你拿到一份 App 的崩溃报告，结果发现里面全是难以理解的内存地址。作为一名合格的开发，应该做些什么呢？简单来说，你需要把调试符号应用到崩溃日志上，让它变得更可读，这个过程叫做符号化（Symbolication）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://davidleee.com/tags/iOS/"/>
    
      <category term="Crash" scheme="http://davidleee.com/tags/Crash/"/>
    
  </entry>
  
  <entry>
    <title>20分钟手把手教你写 macOS 文本编辑器</title>
    <link href="http://davidleee.com/2017/09/11/Windows-in-macOS/"/>
    <id>http://davidleee.com/2017/09/11/Windows-in-macOS/</id>
    <published>2017-09-11T07:22:15.000Z</published>
    <updated>2020-05-05T03:43:31.443Z</updated>
    
    <content type="html"><![CDATA[<p>相较于 iOS 上火热的开发势头，macOS 开发简直就是一片蓝海。让人不禁有些好奇，本是同根生的 macOS 开发究竟是一番怎样的光景？在略微接触之后发现，除了 UIKit 被 AppKit 替换之外，最明显的是 macOS 对待 Window 的态度转变，想想也是，毕竟桌面端应用的效率优势很大一部分就是体现在窗口多开上。然而找了找现有的资料，关于 macOS 开发的实在不多，于是就在学习的过程中翻译一篇国外教程，为社区做点贡献。</p><p>本文是 <a href="https://www.raywenderlich.com/" target="_blank" rel="noopener">RayWenderlich</a> 上的一篇翻译文，里面带着读者从无到有地构建了一个简单的文本编辑器，内容会涉及到 macOS 上 Window 相关的一些使用基础。翻译里加入了一点个人理解，但是技术部分是忠于原文的，不放心的可以直接到官网上看：</p><p>原文链接：<a href="https://www.raywenderlich.com/159287/windows-windowcontroller-tutorial-macos" target="_blank" rel="noopener">Windows and WindowController Tutorial for macOS</a></p><p>说太多了，来看正文啦！</p><a id="more"></a><p>Window 是一切 macOS 应用的界面载体，它定义了一个专属于某个应用的区域，并作为多任务处理的标识展现给用户。</p><p>一切 macOS Apps 都不外乎是下面三种类型之一：</p><ul><li>单一窗口工具型应用（一个界面就完成所有功能），比如<strong>计算器</strong></li><li>单一窗口图书馆式应用（一个窗口完成所有功能，但这个窗口里的界面可能有许多个），比如<strong>照片</strong></li><li>多窗口的基于文档的应用，比如<strong>文本编辑</strong></li></ul><p>这篇教程将会涵盖下列知识：</p><ul><li>Windows 和 windowControllers</li><li>文档（Document）架构</li><li>NSTextView</li><li>模态窗口</li><li>菜单栏和菜单项</li></ul><p>而看这篇文章的读者们可能需要提前掌握这些知识：</p><ul><li>Swift 3 或更高版本的 Swift 语法</li><li>Xcode 和 Storyboards 的基本操作</li><li>在 Mac App 上实现一个 Hello world</li><li>控件的响应链</li></ul><h2 id="那么就开始吧">那么就开始吧</h2><p>同创建一个计算器 App 不同的是，我们将要创建的是一个基于文档的应用，在创建工程项目的时候，Xcode 会给出提示让你选择应用的类型：</p><img src="/uploads/Windows-in-macOS/create-project.png" class="center" title="Create Project"><p>上面的内容可以自由发挥，唯独红框的部分要注意一下：</p><ul><li>Create Document-Based Application 要勾上，此时 Xcode 会为你生成基于文档型应用的示例代码，能省去我们不少工作量</li><li>Document Extension 是告诉 Xcode 我们这个应用要操作的文档的后缀，我这个 Demo 的名字叫 “MyTextEditor”，所以我就取首字母 “mte” 作为后缀了</li><li>下面是关于数据库和测试的部分，同样是勾了就会有示例代码，但我们这里不需要，所以不勾选它们以排除一些干扰</li></ul><p>项目创建好后马上就可以运行了，原始的 MyTextEditor 应该是这个样子的：</p><img src="/uploads/Windows-in-macOS/raw-window.png" class="center" title="Empty Window"><p>而且它已经具有一些基本功能了，比如你已经可以新建很多个窗口（不过这些窗口是重叠在一起的，你可能要拖动一下才能看到后来的窗口）：</p><img src="/uploads/Windows-in-macOS/Open-Many.png" class="center" title="New Windows"><h2 id="文档-documents">文档（Documents）</h2><p>在继续之前，我们要先来了解一下文档类型应用是怎么工作的。</p><h3 id="文档-document-架构">文档（Document）架构</h3><p>一个文档对应的是一个 <code>NSDocument</code> 类型的对象，它相当于这个文档的控制器。通过它，我们可以读取文件的内容或往里面写东西，而且它既可以是本地硬盘上的文件，也可以是存在 iCloud 上的。</p><p>NSDocument 是一个抽象类，也就是说你需要用一个子类去实现具体功能。在文档架构中还有两个很主要的类：<code>NSWindowController</code> 和 <code>NSDocumentController</code>，它们作用分别是：</p><ul><li><code>NSDocument</code>：创建和保管文档数据</li><li><code>NSWindowController</code>：管理用来展示文档的窗口</li><li><code>NSDocumentController</code>：管理一个应用中的所有文档对象</li></ul><img src="/uploads/Windows-in-macOS/DocArchitecture.png" class="center" title="Document Architecture"><h3 id="文档操作">文档操作</h3><p>还记得创建工程的时候，我们告诉了 Xcode 这个 App 是一个文档型应用吗？聪明的 Xcode 知道了这一点之后，会给我们的应用內建许多文档操作，但一些具体的逻辑还是需要我们继承 <code>NSDocument</code> 去实现。（Xcode 其实已经给了我们一个叫 <code>Document</code> 的子类作为例子了）</p><p>打开 <strong>Document.swift</strong>，可以看到已经有用于文件读写的空方法了（<code>data(ofType:)</code> 和 <code>read(from:ofType:)</code>）。运行这个 App 时，你可能已经发现顶部菜单栏里很多功能都是已经实现了的，比如新建、打开、保存等等，不过我们这个 Demo 里面不涉及“保存”，所以我们需要删除相关的逻辑，也借此看看 Xcode 帮我们做了些什么。</p><p>打开项目里唯一的 Storyboard，然后像下图这样取消菜单项和实际逻辑之间的关联：</p><img src="/uploads/Windows-in-macOS/TargetAction.png" class="center" title="Target-Action"><p>把 <strong>Open</strong>、<strong>Save</strong>、<strong>Save As</strong>、<strong>Revert to Saved</strong> 的关联都干掉，因为这些我们都不会用到。</p><p>接下来打开 <strong>Document.swift</strong>，添加以下代码，我们要在用户尝试保存的时候弹一个提示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">save</span><span class="params">(withDelegate delegate: <span class="keyword">Any</span>?, didSave didSaveSelector: Selector?, contextInfo: UnsafeMutableRawPointer?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> userInfo = [<span class="type">NSLocalizedDescriptionKey</span>: <span class="string">"Sorry, no saving for you, sir! Click \"Don't save\" to quit."</span>]</span><br><span class="line">        <span class="keyword">let</span> error = <span class="type">NSError</span>(domain: <span class="type">NSOSStatusErrorDomain</span>, code: unimpErr, userInfo: userInfo)</span><br><span class="line">        <span class="type">NSAlert</span>(error: error).runModal()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><img src="/uploads/Windows-in-macOS/no-saving-for-you.jpg" class="center" title="No saving for you"><p>现在重新运行项目，你会发现菜单栏里我们刚才取消关联的选项已经无法选中了：</p><img src="/uploads/Windows-in-macOS/menuDisabled.png" class="center" title="Menu Disabled"><p>好了，清除掉了障碍，现在要开始真正的开工了！</p><h2 id="窗口位置">窗口位置</h2><p>首先我们要修复的一个问题是：新建的窗口都是死死盖在原来的窗口上面的。我们会通过继承一个窗口控制器来实现这部分逻辑。</p><h3 id="继承一个-nswindowcontroller">继承一个 <code>NSWindowController</code></h3><p>新建一个 <code>NSWindowController</code> 的子类，确保语言选了 Swift，并且不要勾选创建 xib 的那个选项：</p><img src="/uploads/Windows-in-macOS/WindowController.png" class="center" title="New WindowController"><p>然后打开 Storyboard ，将里面的 Window Controller 的 Custom Class 配置为我们刚刚新建的 <code>WindowController</code>：</p><img src="/uploads/Windows-in-macOS/windowcontroller-class.png" class="center" title="Set Custom Class"><p>然后开始解 Bug！在我们的 WindowController.swift 里面，重写父类的一个初始化方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">required</span> <span class="keyword">init</span>?(coder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">  <span class="keyword">super</span>.<span class="keyword">init</span>(coder: coder)</span><br><span class="line">  shouldCascadeWindows = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行！</p><img src="/uploads/Windows-in-macOS/new-window.png" class="center" title="New Windows"><p>除了第二个窗口不是很听话，后续的窗口都已经会排好队了。</p><h3 id="用-tabs-绕过这个问题">用 Tabs 绕过这个问题</h3><p>这第二个窗口是怎么回事呢？我们后面将初始化窗口位置的时候再回答，现在我们先用另一种新建窗口的方式去绕过这个问题~（正式开发中千万不能绕开问题啊！）</p><p>其实将新建窗口变为新建 Tabs 超级简单，只需要在 Storyboard 里面配置一下就好了：</p><img src="/uploads/Windows-in-macOS/tabbing-mode-preferred.png" class="center" title="Tabbing Mode"><p>重新运行，这次当你新建窗口时，这些窗口就会以一个个 Tab 的形式出现了：</p><img src="/uploads/Windows-in-macOS/raw-windows-with-tabs.png" class="center" title="New Windows in Tabbing Mode"><h3 id="在-ib-中设置窗口的位置">在 IB 中设置窗口的位置</h3><p>回到我们绕过的问题本身：窗口的位置。</p><p>在 Storyboard 里，当 Window Controller 里的 Window 被选中时，可以在右侧的 Size Inspector 中看到对窗口位置和大小的配置，其中 “Initial Position” 里设置的就是窗口的初始化位置：</p><img src="/uploads/Windows-in-macOS/windowposition.png" class="center" title="Initial Position"><blockquote><p>在 macOS 中，坐标轴的原点在左下角，横轴是 X 轴，纵轴是 Y 轴，跟 iPhone 上的坐标系要区别开来。</p></blockquote><p>你也可以直接拖动那个小界面里的灰色窗口来设置初始位置。注意小界面下面的两个下拉框的内容变化：</p><ul><li>Proportional Horizontal/Vertical：初始化位置会根据屏幕的大小按比例来设置</li><li>Fixed From Left/Right/Top/Bottom：写死一个固定的初始化位置</li></ul><p>在这个 Demo 里，我们会让窗口固定在左下角 (200,200) 的位置出现：</p><ul><li>设置下拉框内容为 Fixed From Left 和 Fixed From Bottom</li><li>将初始值设置为 X:200 和 Y:200</li></ul><blockquote><p>macOS 会记录每次应用启动后的窗口位置，所以为了看到这里的设置引起的变化，你要先把所有的窗口的关掉，再编译运行项目。</p></blockquote><h3 id="用代码设置窗口的位置">用代码设置窗口的位置</h3><p>这一小节其实就是把上一节做的事情用代码重新做一遍，以防你们以为 Swift 程序员不会写代码。</p><p>用代码设置还是有它的好处的，比如你可以在应用运行的过程中决定窗口要在哪里出现。</p><p>打开 <strong>WindowController.swift</strong>，把里面的 <code>windowDidLoad</code> 方法的实现改成下面这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">windowDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">super</span>.windowDidLoad()</span><br><span class="line">  <span class="comment">//1.</span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> window = window, <span class="keyword">let</span> screen = window.screen &#123;</span><br><span class="line">    <span class="keyword">let</span> offsetFromLeftOfScreen: <span class="type">CGFloat</span> = <span class="number">100</span></span><br><span class="line">    <span class="keyword">let</span> offsetFromTopOfScreen: <span class="type">CGFloat</span> = <span class="number">100</span></span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    <span class="keyword">let</span> screenRect = screen.visibleFrame</span><br><span class="line">    <span class="comment">//3.</span></span><br><span class="line">    <span class="keyword">let</span> newOriginY = screenRect.maxY - window.frame.height - offsetFromTopOfScreen</span><br><span class="line">    <span class="comment">//4.</span></span><br><span class="line">    window.setFrameOrigin(<span class="type">NSPoint</span>(x: offsetFromLeftOfScreen, y: newOriginY))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>取到窗口和屏幕对象（还记得 Swift 是怎么安全的获取 Optional 对象的值吗？就是这样~）</li><li>取得屏幕的可视范围</li><li>计算 Y 坐标的值（别忘了坐标轴原点是左下角，这里计算的是底边的高度）</li><li>更新窗口的坐标</li></ol><p><code>visibleFrame</code> 这个属性不包含 Dock 和菜单栏的范围，如果不用这个参数来计算的话，可能会出现窗口被这两个控件挡住的情况。</p><p>重新编译运行，窗口应该就会出现在距离屏幕（不算菜单栏高度）左上角 (100,100) 的位置了。</p><h2 id="打造一个迷你文字编辑器">打造一个迷你文字编辑器</h2><p>Cocoa 自带了一些很神奇的 UI 和功能，就等着你把它们用起来了。接下来我们会接触到多才多艺的 <code>NSTextView</code>，但首先我们要先了解一下 <code>NSWindow</code> 自带的 content view。</p><h3 id="the-content-view">The Content View</h3><p><code>contentView</code> 是一个窗口中所有视图层级中的根视图，<code>NSWindow</code> 里的 content view 由它带着的 <code>ViewController</code> 来体现。</p><img src="/uploads/Windows-in-macOS/contentVIew.png" class="center" title="Content View"><p>喏，那个蓝的发亮的就是 <code>contentView</code></p><h3 id="添加-text-view">添加 Text View</h3><p>打开 <strong>Main.storyboard</strong>，从右边栏拖一个 <code>NSTextView</code> 到上面说到的 <code>contentView</code> 里面去，把它调节到一个舒服的大小，然后点击右下角的小三角形，选择 <strong>Reset to Suggested Constraints</strong>。</p><img src="/uploads/Windows-in-macOS/autolayout.png" class="center" title="AutoLayout"><p>这里我们让系统自动帮我们布局这个视图，省点事儿。</p><p>编译运行，你应该能看到我们简陋的文字编辑器了。尝试拉伸一下窗口，Text View 会跟着窗口一起变大变小，这是 AutoLayout 的功劳，这个 Demo 里面不会讲咯。</p><img src="/uploads/Windows-in-macOS/mini_text_editor.png" class="center" title="Mini Text Editor"><p>好好探索一下我们的第一个文字编辑器吧，你会发现 Format - Font - Show Font 功能并不可用，我们接下来就解决这个问题。</p><h3 id="打开字体设置框">打开字体设置框</h3><p>在 <strong>Main.storyboard</strong> 里的 Main Menu 上找到 Show Font 这个菜单项，按住 Ctrl 把 Show Font 拖到 First Responder 上，然后在随之出现的弹框中找到 <code>orderFrontFontPanel:</code> 并选择它：</p><img src="/uploads/Windows-in-macOS/font-to-first-responder.png" class="center" title="Show Fonts"><p>然后重新编译运行项目，Show Font 功能就被打开啦！</p><p>在不写一行代码的前提下，你实现了改变字体的功能，这是怎么做到的呢？其实是 <code>NSFontManager</code> 和 <code>NSTextView</code> 把所有的脏活累活都给干掉了。</p><ul><li><code>NSFontManager</code> 是一个管理字体变化系统的类，它就是刚刚弹框中 <code>orderFrontFontPanel:</code> 方法的实际实现的地方，我们刚才的操作是把响应链上的信息发送（forward）给了它，然后它负责展示系统默认的字体设置框</li><li>当我们在字体设置框中对字体进行操作，<code>NSFontManager</code> 会发送一个 <code>changeFont</code> 消息给当前的第一响应对象（First Responder）</li><li><code>NSTextView</code> 实现了 <code>changeFont</code> 方法，当我们操作它里面的文字时（比如选中某个单词），它就自动成为了第一响应对象，然后一切就联系起来了</li></ul><h3 id="富文本">富文本</h3><p>要看到 <code>NSTextView</code> 的真正实力，你可以先从<a href="https://koenig-media.raywenderlich.com/uploads/2017/04/BabyScript.rtfd_.zip" target="_blank" rel="noopener">这里</a>下载一段富文本，然后把它设置为 <code>NSTextView</code> 的默认文字，编译运行！</p><img src="/uploads/Windows-in-macOS/rich_text.png" class="center" title="RichText"><p>嗯？文本里的图片哪里去了呢？</p><p>因为 IB 里面的设置默认文字的地方不能保存图片，所以图片就被丢弃掉了。不过我们还是可以通过复制粘贴或者拖拽的方式，把图片添加到 Text View 里面去。</p><p>玩耍过后，在你想要关闭这个窗口的时候，你会发现我们在文章开头设置的弹窗生效了！（我们在前面禁用了保存功能）</p><h3 id="把帅气的刻度尺显示出来">把帅气的刻度尺显示出来</h3><p>打开 <strong>ViewController.swift</strong>，把 <code>viewDidLoad</code> 附近的代码替换成下面这段：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IBOutlet</span> <span class="keyword">var</span> text: <span class="type">NSTextView!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">  text.toggleRuler(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后回到 <strong>Main.storyboard</strong>，把我们手写的 <code>text</code> 和 IB 里的 Text View 关联起来：按住 Ctrl，把代表 ViewController 的蓝色小圆圈拖向 Text View，选择 text。</p><img src="/uploads/Windows-in-macOS/connect_outlet.png" class="center" title="Connect Outlets"><p>再跑一遍，看起来是不是高大上了一些：</p><img src="/uploads/Windows-in-macOS/RulerShowing.png" class="center" title="Show Ruler"><h2 id="模态窗口">模态窗口</h2><p>模态窗口是 Window 世界中最霸道的存在，一旦出现，它会吃掉所有的事件，知道它们被主动 dismiss 掉。保存和打开文件的弹窗就是模态窗口的范例，总的来说，有三种方式展示模态窗口：</p><ol><li>当做一个常规窗口使用，通过调用 <code>NSApplication.runModal(for:)</code> 显示</li><li>当做一个表单（Sheet）用，通过调用 <code>NSWindow.beginSheet(_:completionHandler:)</code> 显示</li><li>通过一个模态会话来展示，这是一个高级用法，这里不讲</li></ol><p>前面尝试关闭窗口时弹出的保存提醒框就是一个表单型的模态窗口：</p><img src="/uploads/Windows-in-macOS/sheet-modal.png" class="center" title="Save Window"><p>嘛，这玩意儿就这样，我们在这里也不会接着深入了。但是我们会看看一个分离式的模态窗口怎么出现的。</p><h3 id="添加一个新-window">添加一个新 Window</h3><p>打开 <strong>Main.storyboard</strong>，从右边栏拖一个 Window Controller 到画面上，这会生成两个东西，一个 Window Controller Scene 和一个 View Controller Scene：</p><img src="/uploads/Windows-in-macOS/newwindowcontroller.png" class="center" title="New Window with IB"><p>选中 Window Controller Scene 下面的 Window，把它的 Content Size 改为宽300高150，顺带也把 View Controller Scene 下面的 view 也做这样的修改：</p><img src="/uploads/Windows-in-macOS/wc-window-frame.png" class="center" title="Set Content Size"><img src="/uploads/Windows-in-macOS/wc-view-frame.png" class="center" title="Set View Size"><p>然后我们要禁用这个窗口左上角的那些控制按钮，让用户必须沿着我们设定的交互走：</p><img src="/uploads/Windows-in-macOS/wordcount-props.png" class="center" title="Window Controls"><h3 id="新窗口里的界面布局">新窗口里的界面布局</h3><p>就像上文对 Text View 的布局那样，把我们的新窗口也进行一番鼓捣，留给大家自由发挥啦。Demo 里使用了4个 Label 和一个 Button，最终长这个样子：</p><img src="/uploads/Windows-in-macOS/word_count_ui.png" class="center" title="WordCountWindow UI"><h3 id="创建对应的-view-controller-类">创建对应的 View Controller 类</h3><p>为了控制这个窗口的内容，我们要从 <code>NSViewController</code> 继承一个子类：</p><img src="/uploads/Windows-in-macOS/new_word_count_vc.png" class="center" title="New WordCountViewController"><p>接着在 IB 里关联一下界面和这个子类：</p><img src="/uploads/Windows-in-macOS/wc-configure-custom-class-368x320.png" class="center" title="Set Custom Class for WordCountViewController"><h3 id="界面与数据绑定">界面与数据绑定</h3><p>接下来，我们用 macOS 上的一个神奇功能，实现界面与数据的直接绑定。</p><p>打开 <strong>WordCountViewController.swift</strong>，给这个类添加两个属性：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dynamic</span> <span class="keyword">var</span> wordCount = <span class="number">0</span></span><br><span class="line"><span class="keyword">dynamic</span> <span class="keyword">var</span> paragraphCount = <span class="number">0</span></span><br></pre></td></tr></table></figure><p><code>dynamic</code> 关键字使得这两个属性可以被用作 <strong>Cocoa Bindings</strong> 的绑定对象。</p><p>回到我们的 <strong>Main.storyboard</strong>，选中上面添加的 “Word Count” 后面的那个 “0”，然后在右边栏进行设置，将这个 Text View 的内容跟 <code>wordCount</code> 属性的值进行绑定：</p><img src="/uploads/Windows-in-macOS/bind-wordcount.png" class="center" title="Cocoa Bindings"><p>对 <strong>Paragraph Count</strong> 后面跟着的 Text View 也进行相同的操作，但是这次要绑定到 <code>paragrahCount</code> 属性上去。</p><blockquote><p><strong>Cocoa Bindings</strong> 是一个很有用的 UI 技巧，在文章<a href="https://www.raywenderlich.com/141297/cocoa-bindings-macos" target="_blank" rel="noopener">《Cocoa Bindings on macOS》</a>中会有更详细的介绍。（如果有机会，这里也会尝试翻译一下这篇文章）</p></blockquote><p>最后，给我们的 WordCountViewController 所属的 Window 加上一个 Storyboard ID，方便我们后续在代码里面找到它：</p><img src="/uploads/Windows-in-macOS/WCControllerStoryboardId.png" class="center" title="Setting Storyboard ID"><blockquote><p>这个 ID 是可以带有空格的，但是个人习惯不喜欢有空格，这张图是原文章里的。</p></blockquote><h2 id="模态窗口的显示与隐藏">模态窗口的显示与隐藏</h2><p>有了前面的准备工作，这个可以显示字数和段落数的窗口已经是可用的了。接下来我们就找个合适的地方把它显示出来。</p><h3 id="显示">显示</h3><p>打开 <strong>ViewController.swift</strong>，添加一个按钮事件：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">showWordCountWindow</span><span class="params">(<span class="number">_</span> sender: AnyObject)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">let</span> storyboard = <span class="type">NSStoryboard</span>(name: <span class="string">"Main"</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line">  <span class="keyword">let</span> wordCountWindowController = storyboard.instantiateController(withIdentifier: <span class="string">"Word Count Window Controller"</span>) <span class="keyword">as</span>! <span class="type">NSWindowController</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> wordCountWindow = wordCountWindowController.window, <span class="keyword">let</span> textStorage = text.textStorage &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">let</span> wordCountViewController = wordCountWindow.contentViewController <span class="keyword">as</span>! <span class="type">WordCountViewController</span></span><br><span class="line">    wordCountViewController.wordCount = textStorage.words.<span class="built_in">count</span></span><br><span class="line">    wordCountViewController.paragraphCount = textStorage.paragraphs.<span class="built_in">count</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">let</span> application = <span class="type">NSApplication</span>.shared()</span><br><span class="line">    application.runModal(<span class="keyword">for</span>: wordCountWindow)</span><br><span class="line">    <span class="comment">// 4</span></span><br><span class="line">    wordCountWindow.close()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分解动作：</p><ol><li>通过刚刚设置的 Storyboard ID 初始化一个 WordCountWindowController（注意是 <strong>WindowController</strong>，不是我们自己创建的 <strong>ViewController</strong>）</li><li>从我们的内容里取得字数和段落数，设置到 <strong>WordCountViewController</strong> 的属性里</li><li>显示一个模态窗口</li><li>关闭一个模态窗口</li></ol><p>你可能会觉得奇怪，我们在显示之后立马就把它给关闭了，那还看什么？</p><p>事实上，当一个窗口以 <code>runModel(for:)</code> 的方式显示出来之后，应用会进入一个<strong>模态过程</strong>。这个动作相当于启动了一个阻塞的线程，启动方法调用之后的所有代码都会被阻塞住，只有在调用了 <code>stopModel</code> 停止 <strong>模态过程</strong> 后，代码才会继续执行。</p><h3 id="隐藏">隐藏</h3><p>关闭模态窗口的代码需要由模态窗口本身去调用，因为其他地方都被阻塞住了呀。在 <strong>WordCountViewController.swift</strong> 里加上这段代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">dismissWordCountWindow</span><span class="params">(<span class="number">_</span> sender: NSButton)</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> application = <span class="type">NSApplication</span>.shared()</span><br><span class="line">  application.stopModal()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只是让应用退出了 <strong>模态过程</strong>，真正关闭窗口的代码我们已经在上面写好了（就是 <code>close</code> 那个方法）</p><p>好咯，这个按钮事件怎么关联到那个 “OK” 按钮呢？留给你们自己去发现~</p><h3 id="触发窗口的显示">触发窗口的显示</h3><p>显示的代码写好了，但是在哪里地方调用它好呢？不如在菜单里加一个选项吧。</p><p>增加菜单项跟之前添加视图没有扫描区别，菜单项的名字叫 “Menu Item”，直接拖到菜单里面去就好了，然后在右边栏里进行一下设置：</p><img src="/uploads/Windows-in-macOS/add-word-count-window.png" class="center" title="Add Menu Item"><blockquote><p>Key Equivalent 设置的是快捷键</p></blockquote><p>然后 Ctrl + 拖动，把这个菜单项跟我们写的方法联系起来：</p><img src="/uploads/Windows-in-macOS/connect-menu.png" class="center" title="Menu Action"><p>完成了！编译运行！我们的统计功能就上线了！</p><h2 id="接下来呢？">接下来呢？</h2><p>不知不觉，你其实已经学到了蛮多东西了：</p><ul><li>MVC 设计模式的一点应用</li><li>创建一个多窗口 app</li><li>macOS app 的常见结构</li><li>通过 IB 和代码改变窗口的布局</li><li>将 UI 中的事件传递到响应链上</li><li>用模态窗口来展示附加信息</li><li>…</li></ul><p>不过这都只是 macOS app 的冰山一角。<br>如果你对窗口感兴趣，可以看看苹果的官方文章 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/WinPanel/Introduction.html" target="_blank" rel="noopener">Window Programming Guide</a>。如果想要继续深入研究 Mac 应用开发，则推荐 <a href="https://developer.apple.com/library/content/documentation/General/Conceptual/MOSXAppProgrammingGuide/Introduction/Introduction.html" target="_blank" rel="noopener">Mac App Programming Guide</a>。</p><p>这个 Demo 完整的代码在<a href="https://koenig-media.raywenderlich.com/uploads/2017/05/BabyScriptWithSave.zip" target="_blank" rel="noopener">这里</a>。这是原文里的链接，连保存的功能也实现好了，虽然没什么注释，但是代码很好懂。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相较于 iOS 上火热的开发势头，macOS 开发简直就是一片蓝海。让人不禁有些好奇，本是同根生的 macOS 开发究竟是一番怎样的光景？在略微接触之后发现，除了 UIKit 被 AppKit 替换之外，最明显的是 macOS 对待 Window 的态度转变，想想也是，毕竟桌面端应用的效率优势很大一部分就是体现在窗口多开上。然而找了找现有的资料，关于 macOS 开发的实在不多，于是就在学习的过程中翻译一篇国外教程，为社区做点贡献。&lt;/p&gt;
&lt;p&gt;本文是 &lt;a href=&quot;https://www.raywenderlich.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RayWenderlich&lt;/a&gt; 上的一篇翻译文，里面带着读者从无到有地构建了一个简单的文本编辑器，内容会涉及到 macOS 上 Window 相关的一些使用基础。翻译里加入了一点个人理解，但是技术部分是忠于原文的，不放心的可以直接到官网上看：&lt;/p&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://www.raywenderlich.com/159287/windows-windowcontroller-tutorial-macos&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Windows and WindowController Tutorial for macOS&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;说太多了，来看正文啦！&lt;/p&gt;
    
    </summary>
    
    
      <category term="macOS" scheme="http://davidleee.com/tags/macOS/"/>
    
      <category term="Window" scheme="http://davidleee.com/tags/Window/"/>
    
      <category term="Controller" scheme="http://davidleee.com/tags/Controller/"/>
    
      <category term="TextView" scheme="http://davidleee.com/tags/TextView/"/>
    
      <category term="Modal" scheme="http://davidleee.com/tags/Modal/"/>
    
      <category term="Document" scheme="http://davidleee.com/tags/Document/"/>
    
      <category term="Menu" scheme="http://davidleee.com/tags/Menu/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 Swift 中的问号感叹号</title>
    <link href="http://davidleee.com/2017/07/14/Dive-in-Swift-Optional/"/>
    <id>http://davidleee.com/2017/07/14/Dive-in-Swift-Optional/</id>
    <published>2017-07-14T13:16:57.000Z</published>
    <updated>2020-05-05T03:43:31.441Z</updated>
    
    <content type="html"><![CDATA[<p>对于写惯了 OC 代码的程序员来说，不判空直接调用对象方法可能已经成为习惯了；而当方法的返回值是对象时，通常也是拿来就用。这些情况在 Swift 下都不存在了，因为 Swift 中出现了一个全新的概念：Optional（? &amp; !）。</p><a id="more"></a><p>Optional 用于表示一种值可能为空的对象类型。一个 Optional 对象表示了两种可能性：要么对象有值，你可以通过 “unwrap” 去获取到这个值；要么对象里面没有任何东西。</p><blockquote><p>unwrap（解包）：在对象后加 “?” 或 “!” 称为将对象 “unwrap”，可以获取到 Optional 里面的关联值</p></blockquote><p>Optional 这个概念在 C 语言或 Objective-C 里面并不存在。在 OC 中最接近的概念是：本来要返回对象的方法可能会返回 nil，这个 nil 表示“没有有效的对象可以返回”；然而，这只在对象身上有效，它不能作用在结构体、基础 C 类型或枚举上。这些类型的变量如果没有值，OC 会用 <code>NSNotFound</code> 来表示，它需要方法的调用者意识到这些特殊返回值的存在，并作出特殊的处理。</p><p>Optional 解决了上述问题，在 Swift 中，Optional 可以处理任何类型的空值，而不需要用一个特殊的常量去表示。</p><p>举个栗子：<br>当我们需要将字符串转换为数字时，在 Swift 中会使用 <code>Int</code> 的构造方法，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> possibleNumber = <span class="string">"123"</span></span><br><span class="line"><span class="keyword">let</span> convertedNumber = <span class="type">Int</span>(possibleNumber)</span><br></pre></td></tr></table></figure><p>此时，<code>convertedNumber</code> 就是一个 Optional，看一下文档可以发现，这个构造方法返回的是 <code>Int?</code>。</p><p>原因是这个构造器可能会失败： <code>possibleNumber</code> 也许并不能被转化为数字。这里的 <code>?</code> 表示返回的对象是一个可选值，它可能是某个 <code>Int</code> 类型的对象，也可能什么都没有。（它不可能是别的类型的对象，因为 Swift 是强类型的）</p><h2 id="nil">nil</h2><p>这里可以套用 OC 中的概念，<code>nil</code> 表示空值，但是在 Swift 中，它只能被赋值给 Optional 对象。当声明一个 Optional 的变量又没有给它赋值时，它会自动被赋值为 <code>nil</code> ：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> surveyAnswer: <span class="type">String?</span></span><br><span class="line"><span class="comment">// surveyAnswer == nil</span></span><br></pre></td></tr></table></figure><blockquote><p>本质上 Swift 的 <code>nil</code> 跟 OC 的 <code>nil</code> 是不一样的。<br>在 OC 中，<code>nil</code> 是指向一个不存在对象的指针；在 Swift 中，<code>nil</code> 不是一个指针，它是一个带有特定类型的表示数值缺失的值，任何类型的 Optional 都可以设置为 <code>nil</code> 而不只是对象类型。</p></blockquote><h2 id="if-和强制解包">If 和强制解包</h2><p>可以使用 <code>if</code> 来判断一个 Optional 对象是否有值，就像常见的判空操作。在判空后，这个 Optional 对象可以使用 <code>!</code> 来强制解包，这相当于告诉编译器：“我确定这个 Optional 对象肯定有值，直接取出来用吧！”</p><p>举个栗子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> convertedNumber != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"convertedNumber has an integer value of \(convertedNumber!)."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当 <code>!</code> 被用在一个空值时，你的程序就会“卡蹦”一声崩掉！</p></blockquote><h2 id="optional-binding">Optional Binding</h2><p>这个机制可以用来判断一个 Optional 对象是否有值，如果有值就将它复制给一个局部变量或常量，否则不执行任何操作。</p><p>我们用 Optional Binding 来改写上一小节中的例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> actualNumber = <span class="type">Int</span>(possibleNumber) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\"\(possibleNumber)\" 是一个整型数字 \(actualNumber)"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\"\(possibleNumber)\" 不能被转化为整型"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>Int()</code> 返回的对象有值，这个值就会被直接赋给前面的 <code>actualNumber</code> ，所以这个变量就不是一个 Optional，可以不需要解包而直接使用了。</p><p>在这种用法下，<code>if</code> 原来的作用还是存在的，可以用逗号分隔不同类型的判断，比如这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> firstNumber = <span class="type">Int</span>(<span class="string">"4"</span>), <span class="keyword">let</span> secondNumber = <span class="type">Int</span>(<span class="string">"42"</span>), firstNumber &lt; secondNumber &amp;&amp; secondNumber &lt; <span class="number">100</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(firstNumber) &lt; \(secondNumber) &lt; 100"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果其中一个 Optional 没有值，或者最后那个判断的结果为 false，整个 if 判断会直接返回 false</span></span><br></pre></td></tr></table></figure><blockquote><p>通过 Optional Binding 声明的变量的作用于只在这个 <code>if</code> 之内，除非用 <code>guard</code> 去声明，详情参见官方文档 <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/ControlFlow.html#//apple_ref/doc/uid/TP40014097-CH9-ID525" target="_blank" rel="noopener">Early Exit</a></p></blockquote><h2 id="隐式解包">隐式解包</h2><p>有时候，在特定的代码结构下，一个 Optional 对象可以被确保永远都有值（或者说理应永远都有值）。这种时候，每次使用这个对象都进行判空和解包就显得非常多余了，于是我们可以在声明这个对象的时候用隐式解包来处理：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> forcedString: <span class="type">String!</span></span><br><span class="line"><span class="built_in">print</span>(forcedString) <span class="comment">// 不需要写成 “forcedString!”</span></span><br></pre></td></tr></table></figure><p>事实上，例子中的 <code>forcedString</code> 还是一个 Optional 没变，但是我们让它在使用的时候自动解包，不需要我们手动加 <code>!</code> 了。</p><h2 id="链式调用">链式调用</h2><p>如果我们要取得的对象被包裹在了一层又一层的 Optional 之中，取得它的过程可能非常繁琐：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> label: <span class="type">UILabel?</span></span><br><span class="line"><span class="keyword">if</span> label != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> temp1 = label.text &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> temp2 = temp1.hashText &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候，可以使用链式调用的方式改写：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> hashText = label?.text?.hashText &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这句话当中，<code>?</code> 表达的意思是：“如果这个对象有值就取出来，继续下面的步骤；如果没有值，就当我没写过这句话吧”。</p><h2 id="默认值">默认值</h2><p>在一些情况下，我们会想要 Optional 对象为 <code>nil</code> 的时候给出一个默认值。比如我们使用一个 <code>String?</code> 给 <code>label.text</code> 赋值时，我们并不希望设置一个 <code>nil</code> 上去，因为那会让 UILabel 的高度变为0。<br>一种很简便的写法是这样的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s: <span class="type">String?</span></span><br><span class="line">s = ...</span><br><span class="line">label.text = s ?? <span class="string">"placeholder"</span></span><br></pre></td></tr></table></figure><p>这样，当 <code>s</code> 为空时，<code>label.text</code> 的值就会是 “placeholder”。</p><h2 id="总结">总结</h2><p>Swift 中的 Optional 其实是一个 enum：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Optional</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">none</span></span><br><span class="line"><span class="keyword">case</span> some(<span class="type">T</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而它现在所见到的使用方法都可以认为是 Swift 的语法糖：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: <span class="type">String?</span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="type">Optional</span>&lt;<span class="type">String</span>&gt;.<span class="keyword">none</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x: <span class="type">String?</span> = <span class="string">"hello"</span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="type">Optional</span>&lt;<span class="type">String</span>&gt;.some(<span class="string">"hello"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> y = x!</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">switch</span>(x) &#123;</span><br><span class="line"><span class="keyword">case</span> .some(<span class="keyword">let</span> value): y = value</span><br><span class="line"><span class="keyword">case</span> .<span class="keyword">none</span>: <span class="comment">// 抛个异常并整死你的应用:)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> y = x &#123;</span><br><span class="line">y.doSomething()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">switch</span>(x) &#123;</span><br><span class="line"><span class="keyword">case</span> .some(<span class="keyword">let</span> y):y.doSomething()</span><br><span class="line"><span class="keyword">case</span> .<span class="keyword">none</span>: <span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>什么？你想问这是哪门子的 enum？推荐你去看看官方文档 <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Enumerations.html#//apple_ref/doc/uid/TP40014097-CH12-ID145" target="_blank" rel="noopener">Enumeration</a></p></blockquote><h2 id="参考资料">参考资料</h2><ul><li><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID309" target="_blank" rel="noopener">The Swift Programming Language (Swift 4)</a></li><li><a href="https://itunes.apple.com/us/course/developing-ios-10-apps-with-swift/id1198467120" target="_blank" rel="noopener">Developing iOS 10 Apps with Swift</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于写惯了 OC 代码的程序员来说，不判空直接调用对象方法可能已经成为习惯了；而当方法的返回值是对象时，通常也是拿来就用。这些情况在 Swift 下都不存在了，因为 Swift 中出现了一个全新的概念：Optional（? &amp;amp; !）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://davidleee.com/tags/Swift/"/>
    
      <category term="Optional" scheme="http://davidleee.com/tags/Optional/"/>
    
      <category term="nil" scheme="http://davidleee.com/tags/nil/"/>
    
  </entry>
  
</feed>
